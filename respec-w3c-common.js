window.respecVersion = "25.6.0", function () {
  "use strict"; const e = !!window.require; if (!e) { const e = function (e, t) { const n = e.map(e => { if (!(e in window.require.modules)) throw new Error("Unsupported dependency name: " + e); return window.require.modules[e] }); Promise.all(n).then(e => t(...e)) }; e.modules = {}, window.require = e } function t(t, n) { e || (window.require.modules[t] = n) } const n = new Map; function r(e, ...t) { if (!n.has(e)) return; if (Array.from(n.get(e)).forEach(e => { try { e(...t) } catch (t) { r("error", `Error when calling function ${e.name}. See developer console.`), console.error(t) } }), window.parent === window.self) return; const o = t.map(e => String(JSON.stringify(e.stack || e))); window.parent.postMessage({ topic: e, args: o }, window.parent.location.origin) } function o(e, t, r = { once: !1 }) { return r.once ? o(e, (function r(...o) { !function ({ topic: e, cb: t }) { const r = n.get(e); if (!r || !r.has(t)) return console.warn("Already unsubscribed:", e, t), !1; r.delete(t) }({ topic: e, cb: r }), t(...o) })) : (n.has(e) ? n.get(e).add(t) : n.set(e, new Set([t])), { topic: e, cb: t }) } o("error", e => { console.error(e, e.stack) }), o("warn", e => { console.warn(e) }), t("core/pubsubhub", { sub: o }), window.addEventListener("error", e => { console.error(e.error, e.message, e) }); const i = [Promise.resolve().then((function () { return Bn })), Promise.resolve().then((function () { return xr })), Promise.resolve().then((function () { return Cr })), Promise.resolve().then((function () { return Sr })), Promise.resolve().then((function () { return b })), Promise.resolve().then((function () { return po })), Promise.resolve().then((function () { return ho })), Promise.resolve().then((function () { return go })), Promise.resolve().then((function () { return yo })), Promise.resolve().then((function () { return $o })), Promise.resolve().then((function () { return So })), Promise.resolve().then((function () { return or })), Promise.resolve().then((function () { return Zn })), Promise.resolve().then((function () { return Eo })), Promise.resolve().then((function () { return Ao })), Promise.resolve().then((function () { return ii })), Promise.resolve().then((function () { return ai })), Promise.resolve().then((function () { return ci })), Promise.resolve().then((function () { return ui })), Promise.resolve().then((function () { return ms })), Promise.resolve().then((function () { return bs })), Promise.resolve().then((function () { return ys })), Promise.resolve().then((function () { return vs })), Promise.resolve().then((function () { return $s })), Promise.resolve().then((function () { return Es })), Promise.resolve().then((function () { return Ls })), Promise.resolve().then((function () { return Ds })), Promise.resolve().then((function () { return Js })), Promise.resolve().then((function () { return ra })), Promise.resolve().then((function () { return Ii })), Promise.resolve().then((function () { return oa })), Promise.resolve().then((function () { return wa })), Promise.resolve().then((function () { return Xi })), Promise.resolve().then((function () { return Na })), Promise.resolve().then((function () { return Da })), Promise.resolve().then((function () { return Pa })), Promise.resolve().then((function () { return Wa })), Promise.resolve().then((function () { return za })), Promise.resolve().then((function () { return Fa })), Promise.resolve().then((function () { return Ha })), Promise.resolve().then((function () { return Xa })), Promise.resolve().then((function () { return sc })), Promise.resolve().then((function () { return mc })), Promise.resolve().then((function () { return wc })), Promise.resolve().then((function () { return _c })), Promise.resolve().then((function () { return Ec })), Promise.resolve().then((function () { return Rc })), Promise.resolve().then((function () { return Ic })), Promise.resolve().then((function () { return Fs })), Promise.resolve().then((function () { return Fc })), Promise.resolve().then((function () { return Gc })), Promise.resolve().then((function () { return Jc })), Promise.resolve().then((function () { return Qc })), Promise.resolve().then((function () { return tl })), Promise.resolve().then((function () { return rl })), Promise.resolve().then((function () { return ll })), Promise.resolve().then((function () { return fl })), Promise.resolve().then((function () { return Fr })), Promise.resolve().then((function () { return gl }))]; (async () => { const [e, { ui: t }, ...n] = await Promise.all(i); try { t.show(), await async function () { "loading" === document.readyState && await new Promise(e => document.addEventListener("DOMContentLoaded", e)) }(); r("warn", '"respec-w3c-common" profile has been deprecated in favor of the "respec-w3c" profile and will not receive any future updates, including the support for W3C 2020 process. [Please migrate to "respec-w3c" profile.](https://github.com/w3c/respec/wiki/respec-w3c-common-migration-guide)'), await e.runAll(n) } finally { t.enable() } })().catch(e => { console.error(e) }); const s = {}, a = e => Object.assign(s, e), c = ["githubToken", "githubUser"]; o("start-all", a), o("amend-user-config", a), o("end-all", () => { const e = document.createElement("script"); e.id = "initialUserConfig", e.type = "application/json"; for (const e of c) e in s && delete s[e]; e.innerHTML = JSON.stringify(s, null, 2), document.head.appendChild(e) }), o("start-all", (function (e) { const t = document.location.search.replace(/;/g, "&"), n = new URLSearchParams(t), o = Array.from(n).filter(([e, t]) => !!e && !!t).map(([e, t]) => { const n = decodeURIComponent(e), r = decodeURIComponent(t.replace(/%3D/g, "=")); let o; try { o = JSON.parse(r) } catch { o = r } return [n, o] }), i = Object.fromEntries(o); Object.assign(e, i), r("amend-user-config", i) }), { once: !0 }); const l = new Promise(e => { o("end-all", e, { once: !0 }) }); let u; Object.defineProperty(document, "respecIsReady", { get: () => l }); const d = new Promise(e => { u = e }); let p; o("plugins-done", async e => { const t = []; if (Array.isArray(e.postProcess)) { const n = e.postProcess.filter(e => { const t = "function" == typeof e; return t || r("error", "Every item in `postProcess` must be a JS function."), t }).map(async t => { try { return await t(e, document) } catch (e) { r("error", `Function ${t.name} threw an error during \`postProcess\`. See developer console.`), console.error(e) } }), o = await Promise.all(n); t.push(...o) } "function" == typeof e.afterEnd && t.push(await e.afterEnd(e, document)), u(t) }, { once: !0 }); const f = new Promise(e => { p = e }); o("start-all", async e => { const t = []; if (Array.isArray(e.preProcess)) { const n = e.preProcess.filter(e => { const t = "function" == typeof e; return t || r("error", "Every item in `preProcess` must be a JS function."), t }).map(async t => { try { return await t(e, document) } catch (e) { r("error", `Function ${t.name} threw an error during \`preProcess\`. See developer console.`), console.error(e) } }), o = await Promise.all(n); t.push(...o) } p(t) }, { once: !0 }); const h = document.documentElement; h && !h.hasAttribute("lang") && (h.lang = "en", h.hasAttribute("dir") || (h.dir = "ltr")); const m = {}, g = h.lang; var b = Object.freeze({ __proto__: null, name: "core/l10n", l10n: m, lang: g, run: function (e) { e.l10n = m[g] || m.en } }); let y, v; const w = new WeakMap, x = new WeakMap, k = new WeakMap, $ = new WeakMap, C = new WeakMap; let S = { get(e, t, n) { if (e instanceof IDBTransaction) { if ("done" === t) return x.get(e); if ("objectStoreNames" === t) return e.objectStoreNames || k.get(e); if ("store" === t) return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]) } return T(e[t]) }, set: (e, t, n) => (e[t] = n, !0), has: (e, t) => e instanceof IDBTransaction && ("done" === t || "store" === t) || t in e }; function _(e) { return e !== IDBDatabase.prototype.transaction || "objectStoreNames" in IDBTransaction.prototype ? (v || (v = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])).includes(e) ? function (...t) { return e.apply(A(this), t), T(w.get(this)) } : function (...t) { return T(e.apply(A(this), t)) } : function (t, ...n) { const r = e.call(A(this), t, ...n); return k.set(r, t.sort ? t.sort() : [t]), T(r) } } function E(e) { return "function" == typeof e ? _(e) : (e instanceof IDBTransaction && function (e) { if (x.has(e)) return; const t = new Promise((t, n) => { const r = () => { e.removeEventListener("complete", o), e.removeEventListener("error", i), e.removeEventListener("abort", i) }, o = () => { t(), r() }, i = () => { n(e.error || new DOMException("AbortError", "AbortError")), r() }; e.addEventListener("complete", o), e.addEventListener("error", i), e.addEventListener("abort", i) }); x.set(e, t) }(e), t = e, (y || (y = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])).some(e => t instanceof e) ? new Proxy(e, S) : e); var t } function T(e) { if (e instanceof IDBRequest) return function (e) { const t = new Promise((t, n) => { const r = () => { e.removeEventListener("success", o), e.removeEventListener("error", i) }, o = () => { t(T(e.result)), r() }, i = () => { n(e.error), r() }; e.addEventListener("success", o), e.addEventListener("error", i) }); return t.then(t => { t instanceof IDBCursor && w.set(t, e) }).catch(() => { }), C.set(t, e), t }(e); if ($.has(e)) return $.get(e); const t = E(e); return t !== e && ($.set(e, t), C.set(t, e)), t } const A = e => C.get(e); const R = ["get", "getKey", "getAll", "getAllKeys", "count"], L = ["put", "add", "delete", "clear"], N = new Map; function D(e, t) { if (!(e instanceof IDBDatabase) || t in e || "string" != typeof t) return; if (N.get(t)) return N.get(t); const n = t.replace(/FromIndex$/, ""), r = t !== n, o = L.includes(n); if (!(n in (r ? IDBIndex : IDBObjectStore).prototype) || !o && !R.includes(n)) return; const i = async function (e, ...t) { const i = this.transaction(e, o ? "readwrite" : "readonly"); let s = i.store; r && (s = s.index(t.shift())); const a = await s[n](...t); return o && await i.done, a }; return N.set(t, i), i } S = (e => ({ ...e, get: (t, n, r) => D(t, n) || e.get(t, n, r), has: (t, n) => !!D(t, n) || e.has(t, n) }))(S); var P = Object.freeze({ __proto__: null, deleteDB: function (e, { blocked: t } = {}) { const n = indexedDB.deleteDatabase(e); return t && n.addEventListener("blocked", () => t()), T(n).then(() => { }) }, openDB: function (e, t, { blocked: n, upgrade: r, blocking: o, terminated: i } = {}) { const s = indexedDB.open(e, t), a = T(s); return r && s.addEventListener("upgradeneeded", e => { r(T(s.result), e.oldVersion, e.newVersion, T(s.transaction)) }), n && s.addEventListener("blocked", () => n()), a.then(e => { i && e.addEventListener("close", () => i()), o && e.addEventListener("versionchange", () => o()) }).catch(() => { }), a }, unwrap: A, wrap: T }); function j(e, t, n, r, o, { level: i = "error", autofix: s, ruleName: a } = {}) { function c(n) { return n > 0 ? e.slice(t, t + n) : e.slice(Math.max(t + n, 0), t) } function l(n, { precedes: r } = {}) { const o = n.map(e => e.trivia + e.value).join(""), i = e[t]; return "eof" === i.type ? o : r ? o + i.trivia : o.slice(i.trivia.length) } const u = "eof" !== e[t].type ? e[t].line : e.length > 1 ? e[t - 1].line : 1, d = function (e) { const t = e.split("\n"); return t[t.length - 1] }(l(c(-5), { precedes: !0 })), p = c(5), f = l(p), h = d + f.split("\n")[0] + "\n" + (" ".repeat(d.length) + "^"), m = "Syntax" === o ? "since" : "inside", g = `${o} error at line ${u}${e.name ? " in " + e.name : ""}${n && n.name ? `, ${m} \`${n.partial ? "partial " : ""}${n.type} ${n.name}\`` : ""}:\n${h}`; return { message: `${g} ${r}`, bareMessage: r, context: g, line: u, sourceName: e.name, level: i, ruleName: a, autofix: s, input: f, tokens: p } } function I(e, t, n, r) { return j(e, t, n, r, "Syntax") } function O(e, t, n, r, o = {}) { return o.ruleName = n, j(t.source, e.index, t, r, "Validation", o) } class q { constructor({ source: e, tokens: t }) { Object.defineProperties(this, { source: { value: e }, tokens: { value: t, writable: !0 }, parent: { value: null, writable: !0 }, this: { value: this } }) } toJSON() { const e = { type: void 0, name: void 0, inheritance: void 0 }; let t = this; for (; t !== Object.prototype;) { const n = Object.getOwnPropertyDescriptors(t); for (const [t, r] of Object.entries(n)) (r.enumerable || r.get) && (e[t] = this[t]); t = Object.getPrototypeOf(t) } return e } } function W(e, t, { useNullableInner: n } = {}) { if (!e.union) { const r = t.unique.get(e.idlType); if (!r) return; if ("typedef" === r.type) { const { typedefIncludesDictionary: n } = t.cache; if (n.has(r)) return n.get(r); t.cache.typedefIncludesDictionary.set(r, void 0); const o = W(r.idlType, t); if (t.cache.typedefIncludesDictionary.set(r, o), o) return { reference: e, dictionary: o.dictionary } } if ("dictionary" === r.type && (n || !e.nullable)) return { reference: e, dictionary: r } } for (const n of e.subtype) { const e = W(n, t); if (e) return n.union ? e : { reference: n, dictionary: e.dictionary } } } class M extends Array { constructor({ source: e, tokens: t }) { super(), Object.defineProperties(this, { source: { value: e }, tokens: { value: t }, parent: { value: null, writable: !0 } }) } } class z extends q { static parser(e, t) { return () => { const n = e.consume(t); if (n) return new z({ source: e.source, tokens: { value: n } }) } } get value() { return re(this.tokens.value.value) } } function F(e, t) { return oe(e, { parser: z.parser(e, t), listName: t + " list" }) } const U = ["identifier", "decimal", "integer", "string"], B = new Map([...["NoInterfaceObject", "LenientSetter", "LenientThis", "TreatNonObjectAsNull", "Unforgeable"].map(e => [e, "Legacy" + e]), ["NamedConstructor", "LegacyFactoryFunction"], ["OverrideBuiltins", "LegacyOverrideBuiltIns"], ["TreatNullAs", "LegacyNullToEmptyString"]]); function H(e) { for (const t of U) { const n = F(e, t); if (n.length) return n } e.error("Expected identifiers, strings, decimals, or integers but none found") } class G extends q { static parse(e) { const t = { assign: e.consume("=") }, n = me(new G({ source: e.source, tokens: t })); return t.assign && (t.secondaryName = e.consume(...U)), t.open = e.consume("("), t.open ? (n.list = n.rhsIsList ? H(e) : ce(e), t.close = e.consume(")") || e.error("Unexpected token in extended attribute argument list")) : n.hasRhs && !t.secondaryName && e.error("No right hand side to extended attribute assignment"), n.this } get rhsIsList() { return this.tokens.assign && !this.tokens.secondaryName } get rhsType() { return this.rhsIsList ? this.list[0].tokens.value.type + "-list" : this.tokens.secondaryName ? this.tokens.secondaryName.type : null } } class V extends q { static parse(e) { const t = e.consume("identifier"); if (t) return new V({ source: e.source, tokens: { name: t }, params: G.parse(e) }) } constructor({ source: e, tokens: t, params: n }) { super({ source: e, tokens: t }), n.parent = this, Object.defineProperty(this, "params", { value: n }) } get type() { return "extended-attribute" } get name() { return this.tokens.name.value } get rhs() { const { rhsType: e, tokens: t, list: n } = this.params; if (!e) return null; return { type: e, value: this.params.rhsIsList ? n : re(t.secondaryName.value) } } get arguments() { const { rhsIsList: e, list: t } = this.params; return !t || e ? [] : t } *validate(e) { const { name: t } = this; if ("LegacyNoInterfaceObject" === t) { const e = "`[LegacyNoInterfaceObject]` extended attribute is an undesirable feature that may be removed from Web IDL in the future. Refer to the [relevant upstream PR](https://github.com/heycam/webidl/pull/609) for more information."; yield O(this.tokens.name, this, "no-nointerfaceobject", e, { level: "warning" }) } else if (B.has(t)) { const e = `\`[${t}]\` extended attribute is a legacy feature that is now renamed to \`[${B.get(t)}]\`. Refer to the [relevant upstream PR](https://github.com/heycam/webidl/pull/870) for more information.`; yield O(this.tokens.name, this, "renamed-legacy", e, { level: "warning", autofix: (n = this, () => { const { name: e } = n; n.tokens.name.value = B.get(e), "TreatNullAs" === e && (n.params.tokens = {}) }) }) } var n; for (const t of this.arguments) yield* t.validate(e) } } class Z extends M { static parse(e) { const t = {}; if (t.open = e.consume("["), !t.open) return new Z({}); const n = new Z({ source: e.source, tokens: t }); return n.push(...oe(e, { parser: V.parse, listName: "extended attribute" })), t.close = e.consume("]") || e.error("Unexpected closing token of extended attribute"), n.length || e.error("Found an empty extended attribute"), e.probe("[") && e.error("Illegal double extended attribute lists, consider merging them"), n } *validate(e) { for (const t of this) yield* t.validate(e) } } function Y(e, t) { const n = e.consume("?"); n && (t.tokens.nullable = n), e.probe("?") && e.error("Can't nullable more than once") } function X(e, t) { let n = function (e, t) { const n = e.consume("FrozenArray", "Promise", "sequence", "record"); if (!n) return; const r = me(new K({ source: e.source, tokens: { base: n } })); switch (r.tokens.open = e.consume("<") || e.error("No opening bracket after " + n.type), n.type) { case "Promise": { e.probe("[") && e.error("Promise type cannot have extended attribute"); const n = ue(e, t) || e.error("Missing Promise subtype"); r.subtype.push(n); break } case "sequence": case "FrozenArray": { const o = le(e, t) || e.error(`Missing ${n.type} subtype`); r.subtype.push(o); break } case "record": { e.probe("[") && e.error("Record key cannot have extended attribute"); const n = e.consume(...ye) || e.error("Record key must be one of: " + ye.join(", ")), o = new K({ source: e.source, tokens: { base: n } }); o.tokens.separator = e.consume(",") || e.error("Missing comma after record key type"), o.type = t; const i = le(e, t) || e.error("Error parsing generic type record"); r.subtype.push(o, i); break } }return r.idlType || e.error("Error parsing generic type " + n.type), r.tokens.close = e.consume(">") || e.error("Missing closing bracket after " + n.type), r.this }(e, t) || ae(e); if (!n) { const t = e.consume("identifier", ...ye, ...be); if (!t) return; n = new K({ source: e.source, tokens: { base: t } }), e.probe("<") && e.error("Unsupported generic type " + t.value) } return "Promise" === n.generic && e.probe("?") && e.error("Promise type cannot be nullable"), n.type = t || null, Y(e, n), n.nullable && "any" === n.idlType && e.error("Type `any` cannot be made nullable"), n } class K extends q { static parse(e, t) { return X(e, t) || function (e, t) { const n = {}; if (n.open = e.consume("("), !n.open) return; const r = me(new K({ source: e.source, tokens: n })); for (r.type = t || null; ;) { const t = le(e) || e.error("No type after open parenthesis or 'or' in union type"); "any" === t.idlType && e.error("Type `any` cannot be included in a union type"), "Promise" === t.generic && e.error("Type `Promise` cannot be included in a union type"), r.subtype.push(t); const n = e.consume("or"); if (!n) break; t.tokens.separator = n } return r.idlType.length < 2 && e.error("At least two types are expected in a union type but found less"), n.close = e.consume(")") || e.error("Unterminated union type"), Y(e, r), r.this }(e, t) } constructor({ source: e, tokens: t }) { super({ source: e, tokens: t }), Object.defineProperty(this, "subtype", { value: [], writable: !0 }), this.extAttrs = new Z({}) } get generic() { return this.subtype.length && this.tokens.base ? this.tokens.base.value : "" } get nullable() { return Boolean(this.tokens.nullable) } get union() { return Boolean(this.subtype.length) && !this.tokens.base } get idlType() { if (this.subtype.length) return this.subtype; return re([this.tokens.prefix, this.tokens.base, this.tokens.postfix].filter(e => e).map(e => e.value).join(" ")) } *validate(e) { yield* this.extAttrs.validate(e); const t = !this.union && e.unique.get(this.idlType), n = this.union ? this : t && "typedef" === t.type ? t.idlType : void 0; if (n && this.nullable) { const { reference: t } = W(n, e) || {}; if (t) { const e = (this.union ? t : this).tokens.base, n = "Nullable union cannot include a dictionary type"; yield O(e, this, "no-nullable-union-dict", n) } } else for (const t of this.subtype) yield* t.validate(e) } } class J extends q { static parse(e) { const t = e.consume("="); if (!t) return null; const n = ie(e) || e.consume("string", "null", "[", "{") || e.error("No value for default"), r = [n]; if ("[" === n.type) { const t = e.consume("]") || e.error("Default sequence value must be empty"); r.push(t) } else if ("{" === n.type) { const t = e.consume("}") || e.error("Default dictionary value must be empty"); r.push(t) } return new J({ source: e.source, tokens: { assign: t }, expression: r }) } constructor({ source: e, tokens: t, expression: n }) { super({ source: e, tokens: t }), n.parent = this, Object.defineProperty(this, "expression", { value: n }) } get type() { return se(this.expression[0]).type } get value() { return se(this.expression[0]).value } get negative() { return se(this.expression[0]).negative } } class Q extends q { static parse(e) { const t = e.position, n = {}, r = me(new Q({ source: e.source, tokens: n })); return r.extAttrs = Z.parse(e), n.optional = e.consume("optional"), r.idlType = le(e, "argument-type"), r.idlType ? (n.optional || (n.variadic = e.consume("...")), n.name = e.consume("identifier", ...ve), n.name ? (r.default = n.optional ? J.parse(e) : null, r.this) : e.unconsume(t)) : e.unconsume(t) } get type() { return "argument" } get optional() { return !!this.tokens.optional } get variadic() { return !!this.tokens.variadic } get name() { return re(this.tokens.name.value) } *validate(e) { yield* this.idlType.validate(e); const t = W(this.idlType, e, { useNullableInner: !0 }); if (t) if (this.idlType.nullable) { const e = "Dictionary arguments cannot be nullable."; yield O(this.tokens.name, this, "no-nullable-dict-arg", e) } else if (this.optional) { if (!this.default) { const e = "Optional dictionary arguments must have a default value of `{}`."; yield O(this.tokens.name, this, "dict-arg-default", e, { autofix: ee(this) }) } } else if (this.parent && !function e(t, n) { if (n.cache.dictionaryIncludesRequiredField.has(t)) return n.cache.dictionaryIncludesRequiredField.get(t); if (n.cache.dictionaryIncludesRequiredField.set(t, void 0), t.inheritance) { const r = n.unique.get(t.inheritance); if (!r) return !0; if (e(r, n)) return !0 } const r = t.members.some(e => e.required); return n.cache.dictionaryIncludesRequiredField.set(t, r), r }(t.dictionary, e) && function (e) { const t = e.parent.arguments || e.parent.list, n = t.indexOf(e); return !t.slice(n + 1).some(e => !e.optional) }(this)) { const e = "Dictionary argument must be optional if it has no required fields"; yield O(this.tokens.name, this, "dict-arg-optional", e, { autofix: (n = this, () => { const e = he(n.idlType); n.tokens.optional = { type: "optional", value: "optional", trivia: e.trivia }, e.trivia = " ", ee(n)() }) }) } var n } } function ee(e) { return () => { e.default = J.parse(new $e(" = {}")) } } class te extends q { static parse(e, { special: t, regular: n } = {}) { const r = { special: t }, o = me(new te({ source: e.source, tokens: r })); return t && "stringifier" === t.value && (r.termination = e.consume(";"), r.termination) ? (o.arguments = [], o) : (t || n || (r.special = e.consume("getter", "setter", "deleter")), o.idlType = ue(e) || e.error("Missing return type"), r.name = e.consume("identifier", "includes"), r.open = e.consume("(") || e.error("Invalid operation"), o.arguments = ce(e), r.close = e.consume(")") || e.error("Unterminated operation"), r.termination = e.consume(";") || e.error("Unterminated operation, expected `;`"), o.this) } get type() { return "operation" } get name() { const { name: e } = this.tokens; return e ? re(e.value) : "" } get special() { return this.tokens.special ? this.tokens.special.value : "" } *validate(e) { if (!this.name && ["", "static"].includes(this.special)) { const e = "Regular or static operations must have both a return type and an identifier."; yield O(this.tokens.open, this, "incomplete-op", e) } this.idlType && (yield* this.idlType.validate(e)); for (const t of this.arguments) yield* t.validate(e) } } class ne extends q { static parse(e, { special: t, noInherit: n = !1, readonly: r = !1 } = {}) { const o = e.position, i = { special: t }, s = me(new ne({ source: e.source, tokens: i })); if (t || n || (i.special = e.consume("inherit")), "inherit" === s.special && e.probe("readonly") && e.error("Inherited attributes cannot be read-only"), i.readonly = e.consume("readonly"), r && !i.readonly && e.probe("attribute") && e.error("Attributes must be readonly in this context"), i.base = e.consume("attribute"), i.base) { switch (s.idlType = le(e, "attribute-type") || e.error("Attribute lacks a type"), s.idlType.generic) { case "sequence": case "record": e.error(`Attributes cannot accept ${s.idlType.generic} types`) }return i.name = e.consume("identifier", "async", "required") || e.error("Attribute lacks a name"), i.termination = e.consume(";") || e.error("Unterminated attribute, expected `;`"), s.this } e.unconsume(o) } get type() { return "attribute" } get special() { return this.tokens.special ? this.tokens.special.value : "" } get readonly() { return !!this.tokens.readonly } get name() { return re(this.tokens.name.value) } *validate(e) { yield* this.extAttrs.validate(e), yield* this.idlType.validate(e) } } function re(e) { return e.startsWith("_") ? e.slice(1) : e } function oe(e, { parser: t, allowDangler: n, listName: r = "list" }) { const o = t(e); if (!o) return []; o.tokens.separator = e.consume(","); const i = [o]; for (; o.tokens.separator;) { const o = t(e); if (!o) { n || e.error("Trailing comma in " + r); break } if (o.tokens.separator = e.consume(","), i.push(o), !o.tokens.separator) break } return i } function ie(e) { return e.consume("true", "false", "Infinity", "-Infinity", "NaN", "decimal", "integer") } function se({ type: e, value: t }) { switch (e) { case "true": case "false": return { type: "boolean", value: "true" === e }; case "Infinity": case "-Infinity": return { type: "Infinity", negative: e.startsWith("-") }; case "[": return { type: "sequence", value: [] }; case "{": return { type: "dictionary" }; case "decimal": case "integer": return { type: "number", value: t }; case "string": return { type: "string", value: t.slice(1, -1) }; default: return { type: e } } } function ae(e) { const { source: t } = e, n = function () { const n = e.consume("unsigned"), r = e.consume("short", "long"); if (r) { const o = e.consume("long"); return new K({ source: t, tokens: { prefix: n, base: r, postfix: o } }) } n && e.error("Failed to parse integer type") }() || function () { const n = e.consume("unrestricted"), r = e.consume("float", "double"); if (r) return new K({ source: t, tokens: { prefix: n, base: r } }); n && e.error("Failed to parse float type") }(); if (n) return n; const r = e.consume("boolean", "byte", "octet"); return r ? new K({ source: t, tokens: { base: r } }) : void 0 } function ce(e) { return oe(e, { parser: Q.parse, listName: "arguments list" }) } function le(e, t) { const n = Z.parse(e), r = K.parse(e, t); return r && (me(r).extAttrs = n), r } function ue(e, t) { const n = K.parse(e, t || "return-type"); if (n) return n; const r = e.consume("void"); if (r) { const t = new K({ source: e.source, tokens: { base: r } }); return t.type = "return-type", t } } function de(e) { const t = e.consume("stringifier"); if (!t) return; return ne.parse(e, { special: t }) || te.parse(e, { special: t }) || e.error("Unterminated stringifier") } function pe(e) { const t = e.split("\n"); if (t.length) { const e = t[t.length - 1].match(/^\s+/); if (e) return e[0] } return "" } function fe(e) { return () => { if (e.extAttrs.length) { const t = new $e("Exposed=Window,"), n = V.parse(t); n.tokens.separator = t.consume(","); const r = e.extAttrs[0]; /^\s/.test(r.tokens.name.trivia) || (r.tokens.name.trivia = " " + r.tokens.name.trivia), e.extAttrs.unshift(n) } else { me(e).extAttrs = Z.parse(new $e("[Exposed=Window]")); const t = e.tokens.base.trivia; e.extAttrs.tokens.open.trivia = t, e.tokens.base.trivia = "\n" + pe(t) } } } function he(e) { if (e.extAttrs.length) return e.extAttrs.tokens.open; if ("operation" === e.type && !e.special) return he(e.idlType); return Object.values(e.tokens).sort((e, t) => e.index - t.index)[0] } function me(e, t) { return t || (t = e), e ? new Proxy(e, { get(e, t) { const n = e[t]; return Array.isArray(n) ? me(n, e) : n }, set(e, n, r) { if (e[n] = r, !r) return !0; if (Array.isArray(r)) for (const e of r) void 0 !== e.parent && (e.parent = t); else void 0 !== r.parent && (r.parent = t); return !0 } }) : e } const ge = { decimal: /-?(?=[0-9]*\.|[0-9]+[eE])(([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([Ee][-+]?[0-9]+)?|[0-9]+[Ee][-+]?[0-9]+)/y, integer: /-?(0([Xx][0-9A-Fa-f]+|[0-7]*)|[1-9][0-9]*)/y, identifier: /[_-]?[A-Za-z][0-9A-Z_a-z-]*/y, string: /"[^"]*"/y, whitespace: /[\t\n\r ]+/y, comment: /((\/(\/.*|\*([^*]|\*[^/])*\*\/)[\t\n\r ]*)+)/y, other: /[^\t\n\r 0-9A-Za-z]/y }, be = ["ArrayBuffer", "DataView", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint16Array", "Uint32Array", "Uint8ClampedArray", "Float32Array", "Float64Array", "any", "object", "symbol"], ye = ["ByteString", "DOMString", "USVString"], ve = ["async", "attribute", "callback", "const", "constructor", "deleter", "dictionary", "enum", "getter", "includes", "inherit", "interface", "iterable", "maplike", "namespace", "partial", "required", "setlike", "setter", "static", "stringifier", "typedef", "unrestricted"], we = ["-Infinity", "FrozenArray", "Infinity", "NaN", "Promise", "boolean", "byte", "double", "false", "float", "long", "mixin", "null", "octet", "optional", "or", "readonly", "record", "sequence", "short", "true", "unsigned", "void"].concat(ve, ye, be), xe = ["(", ")", ",", "...", ":", ";", "<", "=", ">", "?", "[", "]", "{", "}"], ke = ["_constructor", "toString", "_toString"]; class $e { constructor(e) { this.source = function (e) { const t = []; let n = 0, r = "", o = 1, i = 0; for (; n < e.length;) { const a = e.charAt(n); let c = -1; if (/[\t\n\r ]/.test(a) ? c = s("whitespace", { noFlushTrivia: !0 }) : "/" === a && (c = s("comment", { noFlushTrivia: !0 })), -1 !== c) { const e = t.pop().value; o += (e.match(/\n/g) || []).length, r += e, i -= 1 } else if (/[-0-9.A-Z_a-z]/.test(a)) { if (c = s("decimal"), -1 === c && (c = s("integer")), -1 === c) { c = s("identifier"); const e = t.length - 1, n = t[e]; if (-1 !== c) { if (ke.includes(n.value)) { const r = re(n.value) + " is a reserved identifier and must not be used."; throw new Ce(I(t, e, null, r)) } we.includes(n.value) && (n.type = n.value) } } } else '"' === a && (c = s("string")); for (const s of xe) if (e.startsWith(s, n)) { t.push({ type: s, value: s, trivia: r, line: o, index: i }), r = "", n += s.length, c = n; break } if (-1 === c && (c = s("other")), -1 === c) throw new Error("Token stream not progressing"); n = c, i += 1 } return t.push({ type: "eof", value: "", trivia: r }), t; function s(s, { noFlushTrivia: a } = {}) { const c = ge[s]; c.lastIndex = n; const l = c.exec(e); return l ? (t.push({ type: s, value: l[0], trivia: r, line: o, index: i }), a || (r = ""), c.lastIndex) : -1 } }(e), this.position = 0 } error(e) { throw new Ce(I(this.source, this.position, this.current, e)) } probe(e) { return this.source.length > this.position && this.source[this.position].type === e } consume(...e) { for (const t of e) { if (!this.probe(t)) continue; const e = this.source[this.position]; return this.position++, e } } unconsume(e) { this.position = e } } class Ce extends Error { constructor({ message: e, bareMessage: t, context: n, line: r, sourceName: o, input: i, tokens: s }) { super(e), this.name = "WebIDLParseError", this.bareMessage = t, this.context = n, this.line = r, this.sourceName = o, this.input = i, this.tokens = s } } class Se extends z { static parse(e) { const t = e.consume("string"); if (t) return new Se({ source: e.source, tokens: { value: t } }) } get type() { return "enum-value" } get value() { return super.value.slice(1, -1) } } class _e extends q { static parse(e) { const t = {}; if (t.base = e.consume("enum"), !t.base) return; t.name = e.consume("identifier") || e.error("No name for enum"); const n = me(new _e({ source: e.source, tokens: t })); return e.current = n.this, t.open = e.consume("{") || e.error("Bodyless enum"), n.values = oe(e, { parser: Se.parse, allowDangler: !0, listName: "enumeration" }), e.probe("string") && e.error("No comma between enum values"), t.close = e.consume("}") || e.error("Unexpected value in enum"), n.values.length || e.error("No value in enum"), t.termination = e.consume(";") || e.error("No semicolon after enum"), n.this } get type() { return "enum" } get name() { return re(this.tokens.name.value) } } class Ee extends q { static parse(e) { const t = e.consume("identifier"); if (!t) return; const n = { target: t }; if (n.includes = e.consume("includes"), n.includes) return n.mixin = e.consume("identifier") || e.error("Incomplete includes statement"), n.termination = e.consume(";") || e.error("No terminating ; for includes statement"), new Ee({ source: e.source, tokens: n }); e.unconsume(t.index) } get type() { return "includes" } get target() { return re(this.tokens.target.value) } get includes() { return re(this.tokens.mixin.value) } } class Te extends q { static parse(e) { const t = {}, n = me(new Te({ source: e.source, tokens: t })); if (t.base = e.consume("typedef"), t.base) return n.idlType = le(e, "typedef-type") || e.error("Typedef lacks a type"), t.name = e.consume("identifier") || e.error("Typedef lacks a name"), e.current = n.this, t.termination = e.consume(";") || e.error("Unterminated typedef, expected `;`"), n.this } get type() { return "typedef" } get name() { return re(this.tokens.name.value) } *validate(e) { yield* this.idlType.validate(e) } } class Ae extends q { static parse(e, t) { const n = { base: t }, r = me(new Ae({ source: e.source, tokens: n })); return n.name = e.consume("identifier") || e.error("Callback lacks a name"), e.current = r.this, n.assign = e.consume("=") || e.error("Callback lacks an assignment"), r.idlType = ue(e) || e.error("Callback lacks a return type"), n.open = e.consume("(") || e.error("Callback lacks parentheses for arguments"), r.arguments = ce(e), n.close = e.consume(")") || e.error("Unterminated callback"), n.termination = e.consume(";") || e.error("Unterminated callback, expected `;`"), r.this } get type() { return "callback" } get name() { return re(this.tokens.name.value) } *validate(e) { yield* this.extAttrs.validate(e), yield* this.idlType.validate(e) } } class Re extends q { static parse(e, t, { type: n, inheritable: r, allowedMembers: o }) { const { tokens: i } = t; for (i.name = e.consume("identifier") || e.error("Missing name in " + t.type), e.current = t, t = me(t), r && Object.assign(i, function (e) { const t = e.consume(":"); return t ? { colon: t, inheritance: e.consume("identifier") || e.error("Inheritance lacks a type") } : {} }(e)), i.open = e.consume("{") || e.error("Bodyless " + n), t.members = []; ;) { if (i.close = e.consume("}"), i.close) return i.termination = e.consume(";") || e.error("Missing semicolon after " + n), t.this; const r = Z.parse(e); let s; for (const [t, ...n] of o) if (s = me(t(e, ...n)), s) break; s || e.error("Unknown member"), s.extAttrs = r, t.members.push(s.this) } } get partial() { return !!this.tokens.partial } get name() { return re(this.tokens.name.value) } get inheritance() { return this.tokens.inheritance ? re(this.tokens.inheritance.value) : null } *validate(e) { for (const t of this.members) t.validate && (yield* t.validate(e)) } } class Le extends q { static parse(e) { const t = {}; if (t.base = e.consume("const"), !t.base) return; let n = ae(e); if (!n) { const t = e.consume("identifier") || e.error("Const lacks a type"); n = new K({ source: e.source, tokens: { base: t } }) } e.probe("?") && e.error("Unexpected nullable constant type"), n.type = "const-type", t.name = e.consume("identifier") || e.error("Const lacks a name"), t.assign = e.consume("=") || e.error("Const lacks value assignment"), t.value = ie(e) || e.error("Const lacks a value"), t.termination = e.consume(";") || e.error("Unterminated const, expected `;`"); const r = new Le({ source: e.source, tokens: t }); return me(r).idlType = n, r } get type() { return "const" } get name() { return re(this.tokens.name.value) } get value() { return se(this.tokens.value) } } class Ne extends q { static parse(e) { const t = e.position, n = {}, r = me(new Ne({ source: e.source, tokens: n })); if (n.readonly = e.consume("readonly"), n.readonly || (n.async = e.consume("async")), n.base = n.readonly ? e.consume("maplike", "setlike") : n.async ? e.consume("iterable") : e.consume("iterable", "maplike", "setlike"), !n.base) return void e.unconsume(t); const { type: o } = r, i = "maplike" === o, s = i || "iterable" === o, a = r.async && "iterable" === o; n.open = e.consume("<") || e.error(`Missing less-than sign \`<\` in ${o} declaration`); const c = le(e) || e.error(`Missing a type argument in ${o} declaration`); return r.idlType = [c], r.arguments = [], s && (c.tokens.separator = e.consume(","), c.tokens.separator ? r.idlType.push(le(e)) : i && e.error(`Missing second type argument in ${o} declaration`)), n.close = e.consume(">") || e.error(`Missing greater-than sign \`>\` in ${o} declaration`), e.probe("(") && (a ? (n.argsOpen = e.consume("("), r.arguments.push(...ce(e)), n.argsClose = e.consume(")") || e.error("Unterminated async iterable argument list")) : e.error("Arguments are only allowed for `async iterable`")), n.termination = e.consume(";") || e.error(`Missing semicolon after ${o} declaration`), r.this } get type() { return this.tokens.base.value } get readonly() { return !!this.tokens.readonly } get async() { return !!this.tokens.async } *validate(e) { for (const t of this.idlType) yield* t.validate(e); for (const t of this.arguments) yield* t.validate(e) } } class De extends q { static parse(e) { const t = e.consume("constructor"); if (!t) return; const n = { base: t }; n.open = e.consume("(") || e.error("No argument list in constructor"); const r = ce(e); n.close = e.consume(")") || e.error("Unterminated constructor"), n.termination = e.consume(";") || e.error("No semicolon after constructor"); const o = new De({ source: e.source, tokens: n }); return me(o).arguments = r, o } get type() { return "constructor" } *validate(e) { this.idlType && (yield* this.idlType.validate(e)); for (const t of this.arguments) yield* t.validate(e) } } function Pe(e) { const t = e.consume("static"); if (!t) return; return ne.parse(e, { special: t }) || te.parse(e, { special: t }) || e.error("No body in static member") } class je extends Re { static parse(e, t, { partial: n = null } = {}) { const r = { partial: n, base: t }; return Re.parse(e, new je({ source: e.source, tokens: r }), { type: "interface", inheritable: !n, allowedMembers: [[Le.parse], [De.parse], [Pe], [de], [Ne.parse], [ne.parse], [te.parse]] }) } get type() { return "interface" } *validate(e) { if (yield* this.extAttrs.validate(e), !this.partial && this.extAttrs.every(e => "Exposed" !== e.name) && this.extAttrs.every(e => "LegacyNoInterfaceObject" !== e.name)) { const e = "Interfaces must have `[Exposed]` extended attribute. To fix, add, for example, `[Exposed=Window]`. Please also consider carefully if your interface should also be exposed in a Worker scope. Refer to the [WebIDL spec section on Exposed](https://heycam.github.io/webidl/#Exposed) for more information."; yield O(this.tokens.name, this, "require-exposed", e, { autofix: fe(this) }) } const t = this.extAttrs.filter(e => "Constructor" === e.name); for (const e of t) { const t = "Constructors should now be represented as a `constructor()` operation on the interface instead of `[Constructor]` extended attribute. Refer to the [WebIDL spec section on constructor operations](https://heycam.github.io/webidl/#idl-constructors) for more information."; yield O(e.tokens.name, this, "constructor-member", t, { autofix: Ie(this, e) }) } if (this.extAttrs.some(e => "Global" === e.name)) { const e = this.extAttrs.filter(e => "LegacyFactoryFunction" === e.name); for (const t of e) { const e = "Interfaces marked as `[Global]` cannot have factory functions."; yield O(t.tokens.name, this, "no-constructible-global", e) } const t = this.members.filter(e => "constructor" === e.type); for (const e of t) { const t = "Interfaces marked as `[Global]` cannot have constructors."; yield O(e.tokens.base, this, "no-constructible-global", t) } } yield* super.validate(e), this.partial || (yield* function* (e, t) { const n = new Set(s(t).map(e => e.name)), r = e.partials.get(t.name) || [], o = e.mixinMap.get(t.name) || []; for (const e of [...r, ...o]) { const r = s(e); yield* i(r, n, e, t); for (const e of r) n.add(e.name) } function* i(e, t, n, r) { for (const o of e) { const { name: e } = o; if (e && t.has(e)) { const t = `The operation "${e}" has already been defined for the base interface "${r.name}" either in itself or in a mixin`; yield O(o.tokens.name, n, "no-cross-overload", t) } } } function s(e) { return e.members.filter(({ type: e }) => "operation" === e) } }(e, this)) } } function Ie(e, t) { return e = me(e), () => { const n = pe(e.extAttrs.tokens.open.trivia), r = e.members.length ? pe(he(e.members[0]).trivia) : function (e) { const t = pe(e), n = t.includes("\t") ? "\t" : "  "; return t + n }(n), o = De.parse(new $e(`\n${r}constructor();`)); o.extAttrs = new Z({}), me(o).arguments = t.arguments; const i = function (e, t) { const n = e.slice().reverse().findIndex(t); return -1 === n ? n : e.length - n - 1 }(e.members, e => "constructor" === e.type); e.members.splice(i + 1, 0, o); const { close: s } = e.tokens; s.trivia.includes("\n") || (s.trivia += "\n" + n); const { extAttrs: a } = e, c = a.indexOf(t), l = a.splice(c, 1); a.length ? a.length === c ? a[c - 1].tokens.separator = void 0 : a[c].tokens.name.trivia.trim() || (a[c].tokens.name.trivia = l[0].tokens.name.trivia) : a.tokens.open = a.tokens.close = void 0 } } class Oe extends Re { static parse(e, t, { partial: n } = {}) { const r = { partial: n, base: t }; if (r.mixin = e.consume("mixin"), r.mixin) return Re.parse(e, new Oe({ source: e.source, tokens: r }), { type: "interface mixin", allowedMembers: [[Le.parse], [de], [ne.parse, { noInherit: !0 }], [te.parse, { regular: !0 }]] }) } get type() { return "interface mixin" } } class qe extends q { static parse(e) { const t = {}, n = me(new qe({ source: e.source, tokens: t })); return n.extAttrs = Z.parse(e), t.required = e.consume("required"), n.idlType = le(e, "dictionary-type") || e.error("Dictionary member lacks a type"), t.name = e.consume("identifier") || e.error("Dictionary member lacks a name"), n.default = J.parse(e), t.required && n.default && e.error("Required member must not have a default"), t.termination = e.consume(";") || e.error("Unterminated dictionary member, expected `;`"), n.this } get type() { return "field" } get name() { return re(this.tokens.name.value) } get required() { return !!this.tokens.required } *validate(e) { yield* this.idlType.validate(e) } } class We extends Re { static parse(e, { partial: t } = {}) { const n = { partial: t }; if (n.base = e.consume("dictionary"), n.base) return Re.parse(e, new We({ source: e.source, tokens: n }), { type: "dictionary", inheritable: !t, allowedMembers: [[qe.parse]] }) } get type() { return "dictionary" } } class Me extends Re { static parse(e, { partial: t } = {}) { const n = { partial: t }; if (n.base = e.consume("namespace"), n.base) return Re.parse(e, new Me({ source: e.source, tokens: n }), { type: "namespace", allowedMembers: [[ne.parse, { noInherit: !0, readonly: !0 }], [te.parse, { regular: !0 }]] }) } get type() { return "namespace" } *validate(e) { if (!this.partial && this.extAttrs.every(e => "Exposed" !== e.name)) { const e = "Namespaces must have [Exposed] extended attribute. To fix, add, for example, [Exposed=Window]. Please also consider carefully if your namespace should also be exposed in a Worker scope. Refer to the [WebIDL spec section on Exposed](https://heycam.github.io/webidl/#Exposed) for more information."; yield O(this.tokens.name, this, "require-exposed", e, { autofix: fe(this) }) } yield* super.validate(e) } } class ze extends Re { static parse(e, t, { partial: n = null } = {}) { const r = { callback: t }; if (r.base = e.consume("interface"), r.base) return Re.parse(e, new ze({ source: e.source, tokens: r }), { type: "callback interface", inheritable: !n, allowedMembers: [[Le.parse], [te.parse, { regular: !0 }]] }) } get type() { return "callback interface" } } function Fe(e, t) { const n = e.source; function r(t) { e.error(t) } function o(...t) { return e.consume(...t) } function i(t) { const n = o("interface"); if (!n) return; return Oe.parse(e, n, t) || je.parse(e, n, t) || r("Interface has no proper body") } function s() { return function () { const t = o("callback"); if (t) return e.probe("interface") ? ze.parse(e, t) : Ae.parse(e, t) }() || i() || function () { const t = o("partial"); if (t) return We.parse(e, { partial: t }) || i({ partial: t }) || Me.parse(e, { partial: t }) || r("Partial doesn't apply to anything") }() || We.parse(e) || _e.parse(e) || Te.parse(e) || Ee.parse(e) || Me.parse(e) } const a = function () { if (!n.length) return []; const i = []; for (; ;) { const t = Z.parse(e), n = s(); if (!n) { t.length && r("Stray extended attributes"); break } me(n).extAttrs = t, i.push(n) } const a = o("eof"); return t.concrete && i.push(a), i }(); return e.position < n.length && r("Unrecognised tokens"), a } function Ue(e) { return e } const Be = { wrap: e => e.join(""), trivia: Ue, name: Ue, reference: Ue, type: Ue, generic: Ue, nameless: Ue, inheritance: Ue, definition: Ue, extendedAttribute: Ue, extendedAttributeReference: Ue }; function He(e, t) { const n = new Map, r = e.filter(e => "includes" === e.type); for (const e of r) { const r = t.get(e.includes); if (!r) continue; const o = n.get(e.target); o ? o.push(r) : n.set(e.target, [r]) } return n } function* Ge(e) { const t = function (e) { const t = new Map, n = new Set, r = new Map; for (const o of e) if (o.partial) { const e = r.get(o.name); e ? e.push(o) : r.set(o.name, [o]) } else o.name && (t.has(o.name) ? n.add(o) : t.set(o.name, o)); return { all: e, unique: t, partials: r, duplicates: n, mixinMap: He(e, t), cache: { typedefIncludesDictionary: new WeakMap, dictionaryIncludesRequiredField: new WeakMap } } }(e); for (const e of t.all) e.validate && (yield* e.validate(t)); yield* function* ({ unique: e, duplicates: t }) { for (const n of t) { const { name: t } = n, r = `The name "${t}" of type "${e.get(t).type}" was already seen`; yield O(n.tokens.name, n, "no-duplicate", r) } }(t) } var Ve = Object.freeze({ __proto__: null, parse: function (e, t = {}) { const n = new $e(e); return void 0 !== t.sourceName && (n.source.name = t.sourceName), Fe(n, t) }, write: function (e, { templates: t = Be } = {}) { function n(e, { unescaped: n, context: r }) { return n || (n = e.startsWith("_") ? e.slice(1) : e), t.reference(e, n, r) } function r(e, n = Ue, ...r) { if (!e) return ""; const o = n(e.value, ...r); return t.wrap([t.trivia(e.trivia), o]) } function o(e, t) { return r(e, n, { context: t }) } function i(e, n) { return r(e, t.name, n) } function s(e) { if (e.union || e.generic) return t.wrap([r(e.tokens.base, t.generic), r(e.tokens.open), ...e.subtype.map(a), r(e.tokens.close)]); const o = e.tokens.prefix || e.tokens.base, i = e.tokens.prefix ? [e.tokens.prefix.value, t.trivia(e.tokens.base.trivia)] : [], s = n(t.wrap([...i, e.tokens.base.value, r(e.tokens.postfix)]), { unescaped: e.idlType, context: e }); return t.wrap([t.trivia(o.trivia), s]) } function a(e) { return t.wrap([p(e.extAttrs), s(e), r(e.tokens.nullable), r(e.tokens.separator)]) } function c(e) { return e ? t.wrap([r(e.tokens.assign), ...e.expression.map(e => r(e))]) : "" } function l(e) { return t.wrap([p(e.extAttrs), r(e.tokens.optional), t.type(a(e.idlType)), r(e.tokens.variadic), i(e.tokens.name, { data: e }), c(e.default), r(e.tokens.separator)]) } function u(e) { return t.wrap([r(e.tokens.value), r(e.tokens.separator)]) } function d(e) { const { rhsType: n } = e.params; return t.wrap([t.trivia(e.tokens.name.trivia), t.extendedAttribute(t.wrap([t.extendedAttributeReference(e.name), r(e.params.tokens.assign), o(e.params.tokens.secondaryName, e), r(e.params.tokens.open), ...e.params.list ? e.params.list.map("identifier-list" === n ? n => function (e, n) { return t.wrap([o(e.tokens.value, n), r(e.tokens.separator)]) }(n, e) : n && n.endsWith("-list") ? u : l) : [], r(e.params.tokens.close)])), r(e.tokens.separator)]) } function p(e) { return e.length ? t.wrap([r(e.tokens.open), ...e.map(d), r(e.tokens.close)]) : "" } function f(e) { return t.definition(t.wrap([p(e.extAttrs), r(e.tokens.callback), r(e.tokens.partial), r(e.tokens.base), r(e.tokens.mixin), i(e.tokens.name, { data: e }), (o = e, o.tokens.inheritance ? t.wrap([r(o.tokens.colon), t.trivia(o.tokens.inheritance.trivia), t.inheritance(n(o.tokens.inheritance.value, { context: o }))]) : ""), r(e.tokens.open), g(e.members, e), r(e.tokens.close), r(e.tokens.termination)]), { data: e }); var o } function h(e, n) { return t.definition(t.wrap([p(e.extAttrs), r(e.tokens.readonly), r(e.tokens.async), r(e.tokens.base, t.generic), r(e.tokens.open), t.wrap(e.idlType.map(a)), r(e.tokens.close), r(e.tokens.argsOpen), t.wrap(e.arguments.map(l)), r(e.tokens.argsClose), r(e.tokens.termination)]), { data: e, parent: n }) } t = Object.assign({}, Be, t); const m = { interface: f, "interface mixin": f, namespace: f, operation: function (e, n) { const o = e.idlType ? [t.type(a(e.idlType)), i(e.tokens.name, { data: e, parent: n }), r(e.tokens.open), t.wrap(e.arguments.map(l)), r(e.tokens.close)] : []; return t.definition(t.wrap([p(e.extAttrs), e.tokens.name ? r(e.tokens.special) : r(e.tokens.special, t.nameless, { data: e, parent: n }), ...o, r(e.tokens.termination)]), { data: e, parent: n }) }, attribute: function (e, n) { return t.definition(t.wrap([p(e.extAttrs), r(e.tokens.special), r(e.tokens.readonly), r(e.tokens.base), t.type(a(e.idlType)), i(e.tokens.name, { data: e, parent: n }), r(e.tokens.termination)]), { data: e, parent: n }) }, constructor: function (e, n) { return t.definition(t.wrap([p(e.extAttrs), r(e.tokens.base, t.nameless, { data: e, parent: n }), r(e.tokens.open), t.wrap(e.arguments.map(l)), r(e.tokens.close), r(e.tokens.termination)]), { data: e, parent: n }) }, dictionary: f, field: function (e, n) { return t.definition(t.wrap([p(e.extAttrs), r(e.tokens.required), t.type(a(e.idlType)), i(e.tokens.name, { data: e, parent: n }), c(e.default), r(e.tokens.termination)]), { data: e, parent: n }) }, const: function (e, n) { return t.definition(t.wrap([p(e.extAttrs), r(e.tokens.base), t.type(a(e.idlType)), i(e.tokens.name, { data: e, parent: n }), r(e.tokens.assign), r(e.tokens.value), r(e.tokens.termination)]), { data: e, parent: n }) }, typedef: function (e) { return t.definition(t.wrap([p(e.extAttrs), r(e.tokens.base), t.type(a(e.idlType)), i(e.tokens.name, { data: e }), r(e.tokens.termination)]), { data: e }) }, includes: function (e) { return t.definition(t.wrap([p(e.extAttrs), o(e.tokens.target, e), r(e.tokens.includes), o(e.tokens.mixin, e), r(e.tokens.termination)]), { data: e }) }, callback: function (e) { return t.definition(t.wrap([p(e.extAttrs), r(e.tokens.base), i(e.tokens.name, { data: e }), r(e.tokens.assign), t.type(a(e.idlType)), r(e.tokens.open), ...e.arguments.map(l), r(e.tokens.close), r(e.tokens.termination)]), { data: e }) }, enum: function (e) { return t.definition(t.wrap([p(e.extAttrs), r(e.tokens.base), i(e.tokens.name, { data: e }), r(e.tokens.open), g(e.values, e), r(e.tokens.close), r(e.tokens.termination)]), { data: e }) }, "enum-value": function (e, n) { return t.wrap([t.trivia(e.tokens.value.trivia), t.definition(t.wrap(['"', t.name(e.value, { data: e, parent: n }), '"']), { data: e, parent: n }), r(e.tokens.separator)]) }, iterable: h, maplike: h, setlike: h, "callback interface": f, eof: function (e) { return t.trivia(e.trivia) } }; function g(e, n) { if (!e) return; const r = e.map(e => function (e, t) { if (!m[e.type]) throw new Error(`Type "${e.type}" is unsupported`); return m[e.type](e, t) }(e, n)); return t.wrap(r) } return g(e) }, validate: function (e) { return [...Ge((t = e, t.flat ? t.flat() : [].concat(...t)))]; var t }, WebIDLParseError: Ce }); var Ze = function (e, t) { return e(t = { exports: {} }, t.exports), t.exports }((function (e) { function t() { return { baseUrl: null, breaks: !1, gfm: !0, headerIds: !0, headerPrefix: "", highlight: null, langPrefix: "language-", mangle: !0, pedantic: !1, renderer: null, sanitize: !1, sanitizer: null, silent: !1, smartLists: !1, smartypants: !1, tokenizer: null, walkTokens: null, xhtml: !1 } } e.exports = { defaults: { baseUrl: null, breaks: !1, gfm: !0, headerIds: !0, headerPrefix: "", highlight: null, langPrefix: "language-", mangle: !0, pedantic: !1, renderer: null, sanitize: !1, sanitizer: null, silent: !1, smartLists: !1, smartypants: !1, tokenizer: null, walkTokens: null, xhtml: !1 }, getDefaults: t, changeDefaults: function (t) { e.exports.defaults = t } } })); Ze.defaults, Ze.getDefaults, Ze.changeDefaults; const Ye = /[&<>"']/, Xe = /[&<>"']/g, Ke = /[<>"']|&(?!#?\w+;)/, Je = /[<>"']|&(?!#?\w+;)/g, Qe = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, et = e => Qe[e]; const tt = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi; function nt(e) { return e.replace(tt, (e, t) => "colon" === (t = t.toLowerCase()) ? ":" : "#" === t.charAt(0) ? "x" === t.charAt(1) ? String.fromCharCode(parseInt(t.substring(2), 16)) : String.fromCharCode(+t.substring(1)) : "") } const rt = /(^|[^\[])\^/g; const ot = /[^\w:]/g, it = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i; const st = {}, at = /^[^:]+:\/*[^/]*$/, ct = /^([^:]+:)[\s\S]*$/, lt = /^([^:]+:\/*[^/]*)[\s\S]*$/; function ut(e, t) { st[" " + e] || (at.test(e) ? st[" " + e] = e + "/" : st[" " + e] = dt(e, "/", !0)); const n = -1 === (e = st[" " + e]).indexOf(":"); return "//" === t.substring(0, 2) ? n ? t : e.replace(ct, "$1") + t : "/" === t.charAt(0) ? n ? t : e.replace(lt, "$1") + t : e + t } function dt(e, t, n) { const r = e.length; if (0 === r) return ""; let o = 0; for (; o < r;) { const i = e.charAt(r - o - 1); if (i !== t || n) { if (i === t || !n) break; o++ } else o++ } return e.substr(0, r - o) } var pt = { escape: function (e, t) { if (t) { if (Ye.test(e)) return e.replace(Xe, et) } else if (Ke.test(e)) return e.replace(Je, et); return e }, unescape: nt, edit: function (e, t) { e = e.source || e, t = t || ""; const n = { replace: (t, r) => (r = (r = r.source || r).replace(rt, "$1"), e = e.replace(t, r), n), getRegex: () => new RegExp(e, t) }; return n }, cleanUrl: function (e, t, n) { if (e) { let e; try { e = decodeURIComponent(nt(n)).replace(ot, "").toLowerCase() } catch (e) { return null } if (0 === e.indexOf("javascript:") || 0 === e.indexOf("vbscript:") || 0 === e.indexOf("data:")) return null } t && !it.test(n) && (n = ut(t, n)); try { n = encodeURI(n).replace(/%25/g, "%") } catch (e) { return null } return n }, resolveUrl: ut, noopTest: { exec: function () { } }, merge: function (e) { let t, n, r = 1; for (; r < arguments.length; r++)for (n in t = arguments[r], t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]); return e }, splitCells: function (e, t) { const n = e.replace(/\|/g, (e, t, n) => { let r = !1, o = t; for (; --o >= 0 && "\\" === n[o];)r = !r; return r ? "|" : " |" }).split(/ \|/); let r = 0; if (n.length > t) n.splice(t); else for (; n.length < t;)n.push(""); for (; r < n.length; r++)n[r] = n[r].trim().replace(/\\\|/g, "|"); return n }, rtrim: dt, findClosingBracket: function (e, t) { if (-1 === e.indexOf(t[1])) return -1; const n = e.length; let r = 0, o = 0; for (; o < n; o++)if ("\\" === e[o]) o++; else if (e[o] === t[0]) r++; else if (e[o] === t[1] && (r--, r < 0)) return o; return -1 }, checkSanitizeDeprecation: function (e) { e && e.sanitize && !e.silent && console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options") } }; const { defaults: ft } = Ze, { rtrim: ht, splitCells: mt, escape: gt, findClosingBracket: bt } = pt; function yt(e, t, n) { const r = t.href, o = t.title ? gt(t.title) : null; return "!" !== e[0].charAt(0) ? { type: "link", raw: n, href: r, title: o, text: e[1] } : { type: "image", raw: n, text: gt(e[1]), href: r, title: o } } var vt = class { constructor(e) { this.options = e || ft } space(e) { const t = this.rules.block.newline.exec(e); if (t) return t[0].length > 1 ? { type: "space", raw: t[0] } : { raw: "\n" } } code(e, t) { const n = this.rules.block.code.exec(e); if (n) { const e = t[t.length - 1]; if (e && "paragraph" === e.type) return { raw: n[0], text: n[0].trimRight() }; const r = n[0].replace(/^ {4}/gm, ""); return { type: "code", raw: n[0], codeBlockStyle: "indented", text: this.options.pedantic ? r : ht(r, "\n") } } } fences(e) { const t = this.rules.block.fences.exec(e); if (t) { const e = t[0], n = function (e, t) { const n = e.match(/^(\s+)(?:```)/); if (null === n) return t; const r = n[1]; return t.split("\n").map(e => { const t = e.match(/^\s+/); if (null === t) return e; const [n] = t; return n.length >= r.length ? e.slice(r.length) : e }).join("\n") }(e, t[3] || ""); return { type: "code", raw: e, lang: t[2] ? t[2].trim() : t[2], text: n } } } heading(e) { const t = this.rules.block.heading.exec(e); if (t) return { type: "heading", raw: t[0], depth: t[1].length, text: t[2] } } nptable(e) { const t = this.rules.block.nptable.exec(e); if (t) { const e = { type: "table", header: mt(t[1].replace(/^ *| *\| *$/g, "")), align: t[2].replace(/^ *|\| *$/g, "").split(/ *\| */), cells: t[3] ? t[3].replace(/\n$/, "").split("\n") : [], raw: t[0] }; if (e.header.length === e.align.length) { let t, n = e.align.length; for (t = 0; t < n; t++)/^ *-+: *$/.test(e.align[t]) ? e.align[t] = "right" : /^ *:-+: *$/.test(e.align[t]) ? e.align[t] = "center" : /^ *:-+ *$/.test(e.align[t]) ? e.align[t] = "left" : e.align[t] = null; for (n = e.cells.length, t = 0; t < n; t++)e.cells[t] = mt(e.cells[t], e.header.length); return e } } } hr(e) { const t = this.rules.block.hr.exec(e); if (t) return { type: "hr", raw: t[0] } } blockquote(e) { const t = this.rules.block.blockquote.exec(e); if (t) { const e = t[0].replace(/^ *> ?/gm, ""); return { type: "blockquote", raw: t[0], text: e } } } list(e) { const t = this.rules.block.list.exec(e); if (t) { let e = t[0]; const n = t[2], r = n.length > 1, o = { type: "list", raw: e, ordered: r, start: r ? +n : "", loose: !1, items: [] }, i = t[0].match(this.rules.block.item); let s, a, c, l, u, d, p, f = !1; const h = i.length; for (let t = 0; t < h; t++)s = i[t], e = s, a = s.length, s = s.replace(/^ *([*+-]|\d+\.) */, ""), ~s.indexOf("\n ") && (a -= s.length, s = this.options.pedantic ? s.replace(/^ {1,4}/gm, "") : s.replace(new RegExp("^ {1," + a + "}", "gm"), "")), t !== h - 1 && (c = this.rules.block.bullet.exec(i[t + 1])[0], (n.length > 1 ? 1 === c.length : c.length > 1 || this.options.smartLists && c !== n) && (l = i.slice(t + 1).join("\n"), o.raw = o.raw.substring(0, o.raw.length - l.length), t = h - 1)), u = f || /\n\n(?!\s*$)/.test(s), t !== h - 1 && (f = "\n" === s.charAt(s.length - 1), u || (u = f)), u && (o.loose = !0), d = /^\[[ xX]\] /.test(s), p = void 0, d && (p = " " !== s[1], s = s.replace(/^\[[ xX]\] +/, "")), o.items.push({ type: "list_item", raw: e, task: d, checked: p, loose: u, text: s }); return o } } html(e) { const t = this.rules.block.html.exec(e); if (t) return { type: this.options.sanitize ? "paragraph" : "html", raw: t[0], pre: !this.options.sanitizer && ("pre" === t[1] || "script" === t[1] || "style" === t[1]), text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(t[0]) : gt(t[0]) : t[0] } } def(e) { const t = this.rules.block.def.exec(e); if (t) { t[3] && (t[3] = t[3].substring(1, t[3].length - 1)); return { tag: t[1].toLowerCase().replace(/\s+/g, " "), raw: t[0], href: t[2], title: t[3] } } } table(e) { const t = this.rules.block.table.exec(e); if (t) { const e = { type: "table", header: mt(t[1].replace(/^ *| *\| *$/g, "")), align: t[2].replace(/^ *|\| *$/g, "").split(/ *\| */), cells: t[3] ? t[3].replace(/\n$/, "").split("\n") : [] }; if (e.header.length === e.align.length) { e.raw = t[0]; let n, r = e.align.length; for (n = 0; n < r; n++)/^ *-+: *$/.test(e.align[n]) ? e.align[n] = "right" : /^ *:-+: *$/.test(e.align[n]) ? e.align[n] = "center" : /^ *:-+ *$/.test(e.align[n]) ? e.align[n] = "left" : e.align[n] = null; for (r = e.cells.length, n = 0; n < r; n++)e.cells[n] = mt(e.cells[n].replace(/^ *\| *| *\| *$/g, ""), e.header.length); return e } } } lheading(e) { const t = this.rules.block.lheading.exec(e); if (t) return { type: "heading", raw: t[0], depth: "=" === t[2].charAt(0) ? 1 : 2, text: t[1] } } paragraph(e) { const t = this.rules.block.paragraph.exec(e); if (t) return { type: "paragraph", raw: t[0], text: "\n" === t[1].charAt(t[1].length - 1) ? t[1].slice(0, -1) : t[1] } } text(e, t) { const n = this.rules.block.text.exec(e); if (n) { const e = t[t.length - 1]; return e && "text" === e.type ? { raw: n[0], text: n[0] } : { type: "text", raw: n[0], text: n[0] } } } escape(e) { const t = this.rules.inline.escape.exec(e); if (t) return { type: "escape", raw: t[0], text: gt(t[1]) } } tag(e, t, n) { const r = this.rules.inline.tag.exec(e); if (r) return !t && /^<a /i.test(r[0]) ? t = !0 : t && /^<\/a>/i.test(r[0]) && (t = !1), !n && /^<(pre|code|kbd|script)(\s|>)/i.test(r[0]) ? n = !0 : n && /^<\/(pre|code|kbd|script)(\s|>)/i.test(r[0]) && (n = !1), { type: this.options.sanitize ? "text" : "html", raw: r[0], inLink: t, inRawBlock: n, text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(r[0]) : gt(r[0]) : r[0] } } link(e) { const t = this.rules.inline.link.exec(e); if (t) { const e = bt(t[2], "()"); if (e > -1) { const n = (0 === t[0].indexOf("!") ? 5 : 4) + t[1].length + e; t[2] = t[2].substring(0, e), t[0] = t[0].substring(0, n).trim(), t[3] = "" } let n = t[2], r = ""; if (this.options.pedantic) { const e = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(n); e ? (n = e[1], r = e[3]) : r = "" } else r = t[3] ? t[3].slice(1, -1) : ""; n = n.trim().replace(/^<([\s\S]*)>$/, "$1"); return yt(t, { href: n ? n.replace(this.rules.inline._escapes, "$1") : n, title: r ? r.replace(this.rules.inline._escapes, "$1") : r }, t[0]) } } reflink(e, t) { let n; if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) { let e = (n[2] || n[1]).replace(/\s+/g, " "); if (e = t[e.toLowerCase()], !e || !e.href) { const e = n[0].charAt(0); return { type: "text", raw: e, text: e } } return yt(n, e, n[0]) } } strong(e) { const t = this.rules.inline.strong.exec(e); if (t) return { type: "strong", raw: t[0], text: t[4] || t[3] || t[2] || t[1] } } em(e) { const t = this.rules.inline.em.exec(e); if (t) return { type: "em", raw: t[0], text: t[6] || t[5] || t[4] || t[3] || t[2] || t[1] } } codespan(e) { const t = this.rules.inline.code.exec(e); if (t) { let e = t[2].replace(/\n/g, " "); const n = /[^ ]/.test(e), r = e.startsWith(" ") && e.endsWith(" "); return n && r && (e = e.substring(1, e.length - 1)), e = gt(e, !0), { type: "codespan", raw: t[0], text: e } } } br(e) { const t = this.rules.inline.br.exec(e); if (t) return { type: "br", raw: t[0] } } del(e) { const t = this.rules.inline.del.exec(e); if (t) return { type: "del", raw: t[0], text: t[1] } } autolink(e, t) { const n = this.rules.inline.autolink.exec(e); if (n) { let e, r; return "@" === n[2] ? (e = gt(this.options.mangle ? t(n[1]) : n[1]), r = "mailto:" + e) : (e = gt(n[1]), r = e), { type: "link", raw: n[0], text: e, href: r, tokens: [{ type: "text", raw: e, text: e }] } } } url(e, t) { let n; if (n = this.rules.inline.url.exec(e)) { let e, r; if ("@" === n[2]) e = gt(this.options.mangle ? t(n[0]) : n[0]), r = "mailto:" + e; else { let t; do { t = n[0], n[0] = this.rules.inline._backpedal.exec(n[0])[0] } while (t !== n[0]); e = gt(n[0]), r = "www." === n[1] ? "http://" + e : e } return { type: "link", raw: n[0], text: e, href: r, tokens: [{ type: "text", raw: e, text: e }] } } } inlineText(e, t, n) { const r = this.rules.inline.text.exec(e); if (r) { let e; return e = t ? this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(r[0]) : gt(r[0]) : r[0] : gt(this.options.smartypants ? n(r[0]) : r[0]), { type: "text", raw: r[0], text: e } } } }; const { noopTest: wt, edit: xt, merge: kt } = pt, $t = { newline: /^\n+/, code: /^( {4}[^\n]+\n*)+/, fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/, hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/, heading: /^ {0,3}(#{1,6}) +([^\n]*?)(?: +#+)? *(?:\n+|$)/, blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/, list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/, html: "^ {0,3}(?:<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?\\?>\\n*|<![A-Z][\\s\\S]*?>\\n*|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n*|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$))", def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/, nptable: wt, table: wt, lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/, _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\n]+)*)/, text: /^[^\n]+/, _label: /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/, _title: /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/ }; $t.def = xt($t.def).replace("label", $t._label).replace("title", $t._title).getRegex(), $t.bullet = /(?:[*+-]|\d{1,9}\.)/, $t.item = /^( *)(bull) ?[^\n]*(?:\n(?!\1bull ?)[^\n]*)*/, $t.item = xt($t.item, "gm").replace(/bull/g, $t.bullet).getRegex(), $t.list = xt($t.list).replace(/bull/g, $t.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + $t.def.source + ")").getRegex(), $t._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", $t._comment = /<!--(?!-?>)[\s\S]*?-->/, $t.html = xt($t.html, "i").replace("comment", $t._comment).replace("tag", $t._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), $t.paragraph = xt($t._paragraph).replace("hr", $t.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)").replace("tag", $t._tag).getRegex(), $t.blockquote = xt($t.blockquote).replace("paragraph", $t.paragraph).getRegex(), $t.normal = kt({}, $t), $t.gfm = kt({}, $t.normal, { nptable: "^ *([^|\\n ].*\\|.*)\\n *([-:]+ *\\|[-| :]*)(?:\\n((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)", table: "^ *\\|(.+)\\n *\\|?( *[-:]+[-| :]*)(?:\\n *((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)" }), $t.gfm.nptable = xt($t.gfm.nptable).replace("hr", $t.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)").replace("tag", $t._tag).getRegex(), $t.gfm.table = xt($t.gfm.table).replace("hr", $t.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)").replace("tag", $t._tag).getRegex(), $t.pedantic = kt({}, $t.normal, { html: xt("^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))").replace("comment", $t._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/, fences: wt, paragraph: xt($t.normal._paragraph).replace("hr", $t.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", $t.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex() }); const Ct = { escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/, url: wt, tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/, reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/, nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/, strong: /^__([^\s_])__(?!_)|^\*\*([^\s*])\*\*(?!\*)|^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)/, em: /^_([^\s_])_(?!_)|^_([^\s_<][\s\S]*?[^\s_])_(?!_|[^\s,punctuation])|^_([^\s_<][\s\S]*?[^\s])_(?!_|[^\s,punctuation])|^\*([^\s*<\[])\*(?!\*)|^\*([^\s<"][\s\S]*?[^\s\[\*])\*(?![\]`punctuation])|^\*([^\s*"<\[][\s\S]*[^\s])\*(?!\*)/, code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, br: /^( {2,}|\\)\n(?!\s*$)/, del: wt, text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n))|(?= {2,}\n))/, _punctuation: "!\"#$%&'()*+\\-./:;<=>?@\\[^_{|}~" }; Ct.em = xt(Ct.em).replace(/punctuation/g, Ct._punctuation).getRegex(), Ct._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g, Ct._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/, Ct._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/, Ct.autolink = xt(Ct.autolink).replace("scheme", Ct._scheme).replace("email", Ct._email).getRegex(), Ct._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/, Ct.tag = xt(Ct.tag).replace("comment", $t._comment).replace("attribute", Ct._attribute).getRegex(), Ct._label = /(?:\[[^\[\]]*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, Ct._href = /<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*/, Ct._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/, Ct.link = xt(Ct.link).replace("label", Ct._label).replace("href", Ct._href).replace("title", Ct._title).getRegex(), Ct.reflink = xt(Ct.reflink).replace("label", Ct._label).getRegex(), Ct.normal = kt({}, Ct), Ct.pedantic = kt({}, Ct.normal, { strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/, em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/, link: xt(/^!?\[(label)\]\((.*?)\)/).replace("label", Ct._label).getRegex(), reflink: xt(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", Ct._label).getRegex() }), Ct.gfm = kt({}, Ct.normal, { escape: xt(Ct.escape).replace("])", "~|])").getRegex(), _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/, url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/, del: /^~+(?=\S)([\s\S]*?\S)~+/, text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?= {2,}\n|[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/ }), Ct.gfm.url = xt(Ct.gfm.url, "i").replace("email", Ct.gfm._extended_email).getRegex(), Ct.breaks = kt({}, Ct.gfm, { br: xt(Ct.br).replace("{2,}", "*").getRegex(), text: xt(Ct.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() }); var St = { block: $t, inline: Ct }; const { defaults: _t } = Ze, { block: Et, inline: Tt } = St; function At(e) { return e.replace(/---/g, "").replace(/--/g, "").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1").replace(/'/g, "").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1").replace(/"/g, "").replace(/\.{3}/g, "") } function Rt(e) { let t, n, r = ""; const o = e.length; for (t = 0; t < o; t++)n = e.charCodeAt(t), Math.random() > .5 && (n = "x" + n.toString(16)), r += "&#" + n + ";"; return r } var Lt = class e { constructor(e) { this.tokens = [], this.tokens.links = Object.create(null), this.options = e || _t, this.options.tokenizer = this.options.tokenizer || new vt, this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options; const t = { block: Et.normal, inline: Tt.normal }; this.options.pedantic ? (t.block = Et.pedantic, t.inline = Tt.pedantic) : this.options.gfm && (t.block = Et.gfm, this.options.breaks ? t.inline = Tt.breaks : t.inline = Tt.gfm), this.tokenizer.rules = t } static get rules() { return { block: Et, inline: Tt } } static lex(t, n) { return new e(n).lex(t) } lex(e) { return e = e.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    "), this.blockTokens(e, this.tokens, !0), this.inline(this.tokens), this.tokens } blockTokens(e, t = [], n = !0) { let r, o, i, s; for (e = e.replace(/^ +$/gm, ""); e;)if (r = this.tokenizer.space(e)) e = e.substring(r.raw.length), r.type && t.push(r); else if (r = this.tokenizer.code(e, t)) e = e.substring(r.raw.length), r.type ? t.push(r) : (s = t[t.length - 1], s.raw += "\n" + r.raw, s.text += "\n" + r.text); else if (r = this.tokenizer.fences(e)) e = e.substring(r.raw.length), t.push(r); else if (r = this.tokenizer.heading(e)) e = e.substring(r.raw.length), t.push(r); else if (r = this.tokenizer.nptable(e)) e = e.substring(r.raw.length), t.push(r); else if (r = this.tokenizer.hr(e)) e = e.substring(r.raw.length), t.push(r); else if (r = this.tokenizer.blockquote(e)) e = e.substring(r.raw.length), r.tokens = this.blockTokens(r.text, [], n), t.push(r); else if (r = this.tokenizer.list(e)) { for (e = e.substring(r.raw.length), i = r.items.length, o = 0; o < i; o++)r.items[o].tokens = this.blockTokens(r.items[o].text, [], !1); t.push(r) } else if (r = this.tokenizer.html(e)) e = e.substring(r.raw.length), t.push(r); else if (n && (r = this.tokenizer.def(e))) e = e.substring(r.raw.length), this.tokens.links[r.tag] || (this.tokens.links[r.tag] = { href: r.href, title: r.title }); else if (r = this.tokenizer.table(e)) e = e.substring(r.raw.length), t.push(r); else if (r = this.tokenizer.lheading(e)) e = e.substring(r.raw.length), t.push(r); else if (n && (r = this.tokenizer.paragraph(e))) e = e.substring(r.raw.length), t.push(r); else if (r = this.tokenizer.text(e, t)) e = e.substring(r.raw.length), r.type ? t.push(r) : (s = t[t.length - 1], s.raw += "\n" + r.raw, s.text += "\n" + r.text); else if (e) { const t = "Infinite loop on byte: " + e.charCodeAt(0); if (this.options.silent) { console.error(t); break } throw new Error(t) } return t } inline(e) { let t, n, r, o, i, s; const a = e.length; for (t = 0; t < a; t++)switch (s = e[t], s.type) { case "paragraph": case "text": case "heading": s.tokens = [], this.inlineTokens(s.text, s.tokens); break; case "table": for (s.tokens = { header: [], cells: [] }, o = s.header.length, n = 0; n < o; n++)s.tokens.header[n] = [], this.inlineTokens(s.header[n], s.tokens.header[n]); for (o = s.cells.length, n = 0; n < o; n++)for (i = s.cells[n], s.tokens.cells[n] = [], r = 0; r < i.length; r++)s.tokens.cells[n][r] = [], this.inlineTokens(i[r], s.tokens.cells[n][r]); break; case "blockquote": this.inline(s.tokens); break; case "list": for (o = s.items.length, n = 0; n < o; n++)this.inline(s.items[n].tokens) }return e } inlineTokens(e, t = [], n = !1, r = !1) { let o; for (; e;)if (o = this.tokenizer.escape(e)) e = e.substring(o.raw.length), t.push(o); else if (o = this.tokenizer.tag(e, n, r)) e = e.substring(o.raw.length), n = o.inLink, r = o.inRawBlock, t.push(o); else if (o = this.tokenizer.link(e)) e = e.substring(o.raw.length), "link" === o.type && (o.tokens = this.inlineTokens(o.text, [], !0, r)), t.push(o); else if (o = this.tokenizer.reflink(e, this.tokens.links)) e = e.substring(o.raw.length), "link" === o.type && (o.tokens = this.inlineTokens(o.text, [], !0, r)), t.push(o); else if (o = this.tokenizer.strong(e)) e = e.substring(o.raw.length), o.tokens = this.inlineTokens(o.text, [], n, r), t.push(o); else if (o = this.tokenizer.em(e)) e = e.substring(o.raw.length), o.tokens = this.inlineTokens(o.text, [], n, r), t.push(o); else if (o = this.tokenizer.codespan(e)) e = e.substring(o.raw.length), t.push(o); else if (o = this.tokenizer.br(e)) e = e.substring(o.raw.length), t.push(o); else if (o = this.tokenizer.del(e)) e = e.substring(o.raw.length), o.tokens = this.inlineTokens(o.text, [], n, r), t.push(o); else if (o = this.tokenizer.autolink(e, Rt)) e = e.substring(o.raw.length), t.push(o); else if (n || !(o = this.tokenizer.url(e, Rt))) { if (o = this.tokenizer.inlineText(e, r, At)) e = e.substring(o.raw.length), t.push(o); else if (e) { const t = "Infinite loop on byte: " + e.charCodeAt(0); if (this.options.silent) { console.error(t); break } throw new Error(t) } } else e = e.substring(o.raw.length), t.push(o); return t } }; const { defaults: Nt } = Ze, { cleanUrl: Dt, escape: Pt } = pt; var jt = class { constructor(e) { this.options = e || Nt } code(e, t, n) { const r = (t || "").match(/\S*/)[0]; if (this.options.highlight) { const t = this.options.highlight(e, r); null != t && t !== e && (n = !0, e = t) } return r ? '<pre><code class="' + this.options.langPrefix + Pt(r, !0) + '">' + (n ? e : Pt(e, !0)) + "</code></pre>\n" : "<pre><code>" + (n ? e : Pt(e, !0)) + "</code></pre>\n" } blockquote(e) { return "<blockquote>\n" + e + "</blockquote>\n" } html(e) { return e } heading(e, t, n, r) { return this.options.headerIds ? "<h" + t + ' id="' + this.options.headerPrefix + r.slug(n) + '">' + e + "</h" + t + ">\n" : "<h" + t + ">" + e + "</h" + t + ">\n" } hr() { return this.options.xhtml ? "<hr/>\n" : "<hr>\n" } list(e, t, n) { const r = t ? "ol" : "ul"; return "<" + r + (t && 1 !== n ? ' start="' + n + '"' : "") + ">\n" + e + "</" + r + ">\n" } listitem(e) { return "<li>" + e + "</li>\n" } checkbox(e) { return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> " } paragraph(e) { return "<p>" + e + "</p>\n" } table(e, t) { return t && (t = "<tbody>" + t + "</tbody>"), "<table>\n<thead>\n" + e + "</thead>\n" + t + "</table>\n" } tablerow(e) { return "<tr>\n" + e + "</tr>\n" } tablecell(e, t) { const n = t.header ? "th" : "td"; return (t.align ? "<" + n + ' align="' + t.align + '">' : "<" + n + ">") + e + "</" + n + ">\n" } strong(e) { return "<strong>" + e + "</strong>" } em(e) { return "<em>" + e + "</em>" } codespan(e) { return "<code>" + e + "</code>" } br() { return this.options.xhtml ? "<br/>" : "<br>" } del(e) { return "<del>" + e + "</del>" } link(e, t, n) { if (null === (e = Dt(this.options.sanitize, this.options.baseUrl, e))) return n; let r = '<a href="' + Pt(e) + '"'; return t && (r += ' title="' + t + '"'), r += ">" + n + "</a>", r } image(e, t, n) { if (null === (e = Dt(this.options.sanitize, this.options.baseUrl, e))) return n; let r = '<img src="' + e + '" alt="' + n + '"'; return t && (r += ' title="' + t + '"'), r += this.options.xhtml ? "/>" : ">", r } text(e) { return e } }, It = class { strong(e) { return e } em(e) { return e } codespan(e) { return e } del(e) { return e } html(e) { return e } text(e) { return e } link(e, t, n) { return "" + n } image(e, t, n) { return "" + n } br() { return "" } }, Ot = class { constructor() { this.seen = {} } slug(e) { let t = e.toLowerCase().trim().replace(/<[!\/a-z].*?>/gi, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-"); if (this.seen.hasOwnProperty(t)) { const e = t; do { this.seen[e]++, t = e + "-" + this.seen[e] } while (this.seen.hasOwnProperty(t)) } return this.seen[t] = 0, t } }; const { defaults: qt } = Ze, { unescape: Wt } = pt; var Mt = class e { constructor(e) { this.options = e || qt, this.options.renderer = this.options.renderer || new jt, this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new It, this.slugger = new Ot } static parse(t, n) { return new e(n).parse(t) } parse(e, t = !0) { let n, r, o, i, s, a, c, l, u, d, p, f, h, m, g, b, y, v, w = ""; const x = e.length; for (n = 0; n < x; n++)switch (d = e[n], d.type) { case "space": continue; case "hr": w += this.renderer.hr(); continue; case "heading": w += this.renderer.heading(this.parseInline(d.tokens), d.depth, Wt(this.parseInline(d.tokens, this.textRenderer)), this.slugger); continue; case "code": w += this.renderer.code(d.text, d.lang, d.escaped); continue; case "table": for (l = "", c = "", i = d.header.length, r = 0; r < i; r++)c += this.renderer.tablecell(this.parseInline(d.tokens.header[r]), { header: !0, align: d.align[r] }); for (l += this.renderer.tablerow(c), u = "", i = d.cells.length, r = 0; r < i; r++) { for (a = d.tokens.cells[r], c = "", s = a.length, o = 0; o < s; o++)c += this.renderer.tablecell(this.parseInline(a[o]), { header: !1, align: d.align[o] }); u += this.renderer.tablerow(c) } w += this.renderer.table(l, u); continue; case "blockquote": u = this.parse(d.tokens), w += this.renderer.blockquote(u); continue; case "list": for (p = d.ordered, f = d.start, h = d.loose, i = d.items.length, u = "", r = 0; r < i; r++)g = d.items[r], b = g.checked, y = g.task, m = "", g.task && (v = this.renderer.checkbox(b), h ? g.tokens.length > 0 && "text" === g.tokens[0].type ? (g.tokens[0].text = v + " " + g.tokens[0].text, g.tokens[0].tokens && g.tokens[0].tokens.length > 0 && "text" === g.tokens[0].tokens[0].type && (g.tokens[0].tokens[0].text = v + " " + g.tokens[0].tokens[0].text)) : g.tokens.unshift({ type: "text", text: v }) : m += v), m += this.parse(g.tokens, h), u += this.renderer.listitem(m, y, b); w += this.renderer.list(u, p, f); continue; case "html": w += this.renderer.html(d.text); continue; case "paragraph": w += this.renderer.paragraph(this.parseInline(d.tokens)); continue; case "text": for (u = d.tokens ? this.parseInline(d.tokens) : d.text; n + 1 < x && "text" === e[n + 1].type;)d = e[++n], u += "\n" + (d.tokens ? this.parseInline(d.tokens) : d.text); w += t ? this.renderer.paragraph(u) : u; continue; default: { const e = 'Token with "' + d.type + '" type was not found.'; if (this.options.silent) return void console.error(e); throw new Error(e) } }return w } parseInline(e, t) { t = t || this.renderer; let n, r, o = ""; const i = e.length; for (n = 0; n < i; n++)switch (r = e[n], r.type) { case "escape": o += t.text(r.text); break; case "html": o += t.html(r.text); break; case "link": o += t.link(r.href, r.title, this.parseInline(r.tokens, t)); break; case "image": o += t.image(r.href, r.title, r.text); break; case "strong": o += t.strong(this.parseInline(r.tokens, t)); break; case "em": o += t.em(this.parseInline(r.tokens, t)); break; case "codespan": o += t.codespan(r.text); break; case "br": o += t.br(); break; case "del": o += t.del(this.parseInline(r.tokens, t)); break; case "text": o += t.text(r.text); break; default: { const e = 'Token with "' + r.type + '" type was not found.'; if (this.options.silent) return void console.error(e); throw new Error(e) } }return o } }; const { merge: zt, checkSanitizeDeprecation: Ft, escape: Ut } = pt, { getDefaults: Bt, changeDefaults: Ht, defaults: Gt } = Ze; function Vt(e, t, n) { if (null == e) throw new Error("marked(): input parameter is undefined or null"); if ("string" != typeof e) throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(e) + ", string expected"); if ("function" == typeof t && (n = t, t = null), t = zt({}, Vt.defaults, t || {}), Ft(t), n) { const r = t.highlight; let o; try { o = Lt.lex(e, t) } catch (e) { return n(e) } const i = function (e) { let i; if (!e) try { i = Mt.parse(o, t) } catch (t) { e = t } return t.highlight = r, e ? n(e) : n(null, i) }; if (!r || r.length < 3) return i(); if (delete t.highlight, !o.length) return i(); let s = 0; return Vt.walkTokens(o, (function (e) { "code" === e.type && (s++, r(e.text, e.lang, (function (t, n) { if (t) return i(t); null != n && n !== e.text && (e.text = n, e.escaped = !0), s--, 0 === s && i() }))) })), void (0 === s && i()) } try { const n = Lt.lex(e, t); return t.walkTokens && Vt.walkTokens(n, t.walkTokens), Mt.parse(n, t) } catch (e) { if (e.message += "\nPlease report this to https://github.com/markedjs/marked.", t.silent) return "<p>An error occurred:</p><pre>" + Ut(e.message + "", !0) + "</pre>"; throw e } } Vt.options = Vt.setOptions = function (e) { return zt(Vt.defaults, e), Ht(Vt.defaults), Vt }, Vt.getDefaults = Bt, Vt.defaults = Gt, Vt.use = function (e) { const t = zt({}, e); if (e.renderer) { const n = Vt.defaults.renderer || new jt; for (const t in e.renderer) { const r = n[t]; n[t] = (...o) => { let i = e.renderer[t].apply(n, o); return !1 === i && (i = r.apply(n, o)), i } } t.renderer = n } if (e.tokenizer) { const n = Vt.defaults.tokenizer || new vt; for (const t in e.tokenizer) { const r = n[t]; n[t] = (...o) => { let i = e.tokenizer[t].apply(n, o); return !1 === i && (i = r.apply(n, o)), i } } t.tokenizer = n } if (e.walkTokens) { const n = Vt.defaults.walkTokens; t.walkTokens = t => { e.walkTokens(t), n && n(t) } } Vt.setOptions(t) }, Vt.walkTokens = function (e, t) { for (const n of e) switch (t(n), n.type) { case "table": for (const e of n.tokens.header) Vt.walkTokens(e, t); for (const e of n.tokens.cells) for (const n of e) Vt.walkTokens(n, t); break; case "list": Vt.walkTokens(n.items, t); break; default: n.tokens && Vt.walkTokens(n.tokens, t) } }, Vt.Parser = Mt, Vt.parser = Mt.parse, Vt.Renderer = jt, Vt.TextRenderer = It, Vt.Lexer = Lt, Vt.lexer = Lt.lex, Vt.Tokenizer = vt, Vt.Slugger = Ot, Vt.parse = Vt; var Zt = Vt; "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self; var Yt = function (e, t) { return e(t = { exports: {} }, t.exports), t.exports }((function (e, t) { !function (t, n) { e.exports = n() }(0, (function () { var e = [], t = [], n = {}, r = {}, o = {}; function i(e) { return "string" == typeof e ? new RegExp("^" + e + "$", "i") : e } function s(e, t) { return e === t ? t : e === e.toLowerCase() ? t.toLowerCase() : e === e.toUpperCase() ? t.toUpperCase() : e[0] === e[0].toUpperCase() ? t.charAt(0).toUpperCase() + t.substr(1).toLowerCase() : t.toLowerCase() } function a(e, t) { return e.replace(/\$(\d{1,2})/g, (function (e, n) { return t[n] || "" })) } function c(e, t) { return e.replace(t[0], (function (n, r) { var o = a(t[1], arguments); return s("" === n ? e[r - 1] : n, o) })) } function l(e, t, r) { if (!e.length || n.hasOwnProperty(e)) return t; for (var o = r.length; o--;) { var i = r[o]; if (i[0].test(t)) return c(t, i) } return t } function u(e, t, n) { return function (r) { var o = r.toLowerCase(); return t.hasOwnProperty(o) ? s(r, o) : e.hasOwnProperty(o) ? s(r, e[o]) : l(o, r, n) } } function d(e, t, n, r) { return function (r) { var o = r.toLowerCase(); return !!t.hasOwnProperty(o) || !e.hasOwnProperty(o) && l(o, o, n) === o } } function p(e, t, n) { return (n ? t + " " : "") + (1 === t ? p.singular(e) : p.plural(e)) } return p.plural = u(o, r, e), p.isPlural = d(o, r, e), p.singular = u(r, o, t), p.isSingular = d(r, o, t), p.addPluralRule = function (t, n) { e.push([i(t), n]) }, p.addSingularRule = function (e, n) { t.push([i(e), n]) }, p.addUncountableRule = function (e) { "string" != typeof e ? (p.addPluralRule(e, "$0"), p.addSingularRule(e, "$0")) : n[e.toLowerCase()] = !0 }, p.addIrregularRule = function (e, t) { t = t.toLowerCase(), e = e.toLowerCase(), o[e] = t, r[t] = e }, [["I", "we"], ["me", "us"], ["he", "they"], ["she", "they"], ["them", "them"], ["myself", "ourselves"], ["yourself", "yourselves"], ["itself", "themselves"], ["herself", "themselves"], ["himself", "themselves"], ["themself", "themselves"], ["is", "are"], ["was", "were"], ["has", "have"], ["this", "these"], ["that", "those"], ["echo", "echoes"], ["dingo", "dingoes"], ["volcano", "volcanoes"], ["tornado", "tornadoes"], ["torpedo", "torpedoes"], ["genus", "genera"], ["viscus", "viscera"], ["stigma", "stigmata"], ["stoma", "stomata"], ["dogma", "dogmata"], ["lemma", "lemmata"], ["schema", "schemata"], ["anathema", "anathemata"], ["ox", "oxen"], ["axe", "axes"], ["die", "dice"], ["yes", "yeses"], ["foot", "feet"], ["eave", "eaves"], ["goose", "geese"], ["tooth", "teeth"], ["quiz", "quizzes"], ["human", "humans"], ["proof", "proofs"], ["carve", "carves"], ["valve", "valves"], ["looey", "looies"], ["thief", "thieves"], ["groove", "grooves"], ["pickaxe", "pickaxes"], ["passerby", "passersby"]].forEach((function (e) { return p.addIrregularRule(e[0], e[1]) })), [[/s?$/i, "s"], [/[^\u0000-\u007F]$/i, "$0"], [/([^aeiou]ese)$/i, "$1"], [/(ax|test)is$/i, "$1es"], [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"], [/(e[mn]u)s?$/i, "$1s"], [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"], [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"], [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"], [/(seraph|cherub)(?:im)?$/i, "$1im"], [/(her|at|gr)o$/i, "$1oes"], [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"], [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"], [/sis$/i, "ses"], [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"], [/([^aeiouy]|qu)y$/i, "$1ies"], [/([^ch][ieo][ln])ey$/i, "$1ies"], [/(x|ch|ss|sh|zz)$/i, "$1es"], [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"], [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"], [/(pe)(?:rson|ople)$/i, "$1ople"], [/(child)(?:ren)?$/i, "$1ren"], [/eaux$/i, "$0"], [/m[ae]n$/i, "men"], ["thou", "you"]].forEach((function (e) { return p.addPluralRule(e[0], e[1]) })), [[/s$/i, ""], [/(ss)$/i, "$1"], [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"], [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"], [/ies$/i, "y"], [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"], [/\b(mon|smil)ies$/i, "$1ey"], [/\b((?:tit)?m|l)ice$/i, "$1ouse"], [/(seraph|cherub)im$/i, "$1"], [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"], [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"], [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"], [/(test)(?:is|es)$/i, "$1is"], [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"], [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"], [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"], [/(alumn|alg|vertebr)ae$/i, "$1a"], [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"], [/(matr|append)ices$/i, "$1ix"], [/(pe)(rson|ople)$/i, "$1rson"], [/(child)ren$/i, "$1"], [/(eau)x?$/i, "$1"], [/men$/i, "man"]].forEach((function (e) { return p.addSingularRule(e[0], e[1]) })), ["adulthood", "advice", "agenda", "aid", "aircraft", "alcohol", "ammo", "analytics", "anime", "athletics", "audio", "bison", "blood", "bream", "buffalo", "butter", "carp", "cash", "chassis", "chess", "clothing", "cod", "commerce", "cooperation", "corps", "debris", "diabetes", "digestion", "elk", "energy", "equipment", "excretion", "expertise", "firmware", "flounder", "fun", "gallows", "garbage", "graffiti", "hardware", "headquarters", "health", "herpes", "highjinks", "homework", "housework", "information", "jeans", "justice", "kudos", "labour", "literature", "machinery", "mackerel", "mail", "media", "mews", "moose", "music", "mud", "manga", "news", "only", "personnel", "pike", "plankton", "pliers", "police", "pollution", "premises", "rain", "research", "rice", "salmon", "scissors", "series", "sewage", "shambles", "shrimp", "software", "species", "staff", "swine", "tennis", "traffic", "transportation", "trout", "tuna", "wealth", "welfare", "whiting", "wildebeest", "wildlife", "you", /pok[e]mon$/i, /[^aeiou]ese$/i, /deer$/i, /fish$/i, /measles$/i, /o[iu]s$/i, /pox$/i, /sheep$/i].forEach(p.addUncountableRule), p })) })), Xt = function (e) { var t = {}; try { t.WeakMap = WeakMap } catch (u) { t.WeakMap = function (e, t) { var n = t.defineProperty, r = t.hasOwnProperty, o = i.prototype; return o.delete = function (e) { return this.has(e) && delete e[this._] }, o.get = function (e) { return this.has(e) ? e[this._] : void 0 }, o.has = function (e) { return r.call(e, this._) }, o.set = function (e, t) { return n(e, this._, { configurable: !0, value: t }), this }, i; function i(t) { n(this, "_", { value: "_@ungap/weakmap" + e++ }), t && t.forEach(s, this) } function s(e) { this.set(e[0], e[1]) } }(Math.random(), Object) } var n = t.WeakMap, r = {}; try { r.WeakSet = WeakSet } catch (u) { !function (e, t) { var n = o.prototype; function o() { t(this, "_", { value: "_@ungap/weakmap" + e++ }) } n.add = function (e) { return this.has(e) || t(e, this._, { value: !0, configurable: !0 }), this }, n.has = function (e) { return this.hasOwnProperty.call(e, this._) }, n.delete = function (e) { return this.has(e) && delete e[this._] }, r.WeakSet = o }(Math.random(), Object.defineProperty) } function o(e, t, n, r, o, i) { for (var s = ("selectedIndex" in t), a = s; r < o;) { var c, l = e(n[r], 1); t.insertBefore(l, i), s && a && l.selected && (a = !a, c = t.selectedIndex, t.selectedIndex = c < 0 ? r : d.call(t.querySelectorAll("option"), l)), r++ } } function i(e, t) { return e == t } function s(e) { return e } function a(e, t, n, r, o, i, s) { var a = i - o; if (a < 1) return -1; for (; a <= n - t;) { for (var c = t, l = o; c < n && l < i && s(e[c], r[l]);)c++, l++; if (l === i) return t; t = c + 1 } return -1 } function c(e, t, n, r, o) { return n < r ? e(t[n], 0) : 0 < n ? e(t[n - 1], -0).nextSibling : o } function l(e, t, n, r) { for (; n < r;)f(e(t[n++], -1)) } var u = r.WeakSet, d = [].indexOf, p = function (e, t, n) { for (var r = 1, o = t; r < o;) { var i = (r + o) / 2 >>> 0; n < e[i] ? o = i : r = 1 + i } return r }, f = function (e) { return (e.remove || function () { var e = this.parentNode; e && e.removeChild(this) }).call(e) }; function h(e, t, n, r) { for (var u = (r = r || {}).compare || i, d = r.node || s, f = null == r.before ? null : d(r.before, 0), h = t.length, m = h, g = 0, b = n.length, y = 0; g < m && y < b && u(t[g], n[y]);)g++, y++; for (; g < m && y < b && u(t[m - 1], n[b - 1]);)m--, b--; var v = g === m, w = y === b; if (v && w) return n; if (v && y < b) return o(d, e, n, y, b, c(d, t, g, h, f)), n; if (w && g < m) return l(d, t, g, m), n; var x = m - g, k = b - y, $ = -1; if (x < k) { if (-1 < ($ = a(n, y, b, t, g, m, u))) return o(d, e, n, y, $, d(t[g], 0)), o(d, e, n, $ + x, b, c(d, t, m, h, f)), n } else if (k < x && -1 < ($ = a(t, g, m, n, y, b, u))) return l(d, t, g, $), l(d, t, $ + k, m), n; return x < 2 || k < 2 ? (o(d, e, n, y, b, d(t[g], 0)), l(d, t, g, m)) : x == k && function (e, t, n, r, o, i) { for (; r < o && i(n[r], e[t - 1]);)r++, t--; return 0 === t }(n, b, t, g, m, u) ? o(d, e, n, y, b, c(d, t, m, h, f)) : function (e, t, n, r, i, s, a, c, u, d, f, h, m) { !function (e, t, n, r, i, s, a, c, u) { for (var d = [], p = e.length, f = a, h = 0; h < p;)switch (e[h++]) { case 0: i++, f++; break; case 1: d.push(r[i]), o(t, n, r, i++, i, f < c ? t(s[f], 0) : u); break; case -1: f++ }for (h = 0; h < p;)switch (e[h++]) { case 0: a++; break; case -1: -1 < d.indexOf(s[a]) ? a++ : l(t, s, a++, a) } }(function (e, t, n, r, o, i, s) { var a, c, l, u, d, p, f = n + i, h = []; e: for (b = 0; b <= f; b++) { if (50 < b) return null; for (p = b - 1, u = b ? h[b - 1] : [0, 0], d = h[b] = [], a = -b; a <= b; a += 2) { for (c = (l = a === -b || a !== b && u[p + a - 1] < u[p + a + 1] ? u[p + a + 1] : u[p + a - 1] + 1) - a; l < i && c < n && s(r[o + l], e[t + c]);)l++, c++; if (l === i && c === n) break e; d[b + a] = l } } for (var m = Array(b / 2 + f / 2), g = m.length - 1, b = h.length - 1; 0 <= b; b--) { for (; 0 < l && 0 < c && s(r[o + l - 1], e[t + c - 1]);)m[g--] = 0, l--, c--; if (!b) break; p = b - 1, u = b ? h[b - 1] : [0, 0], (a = l - c) == -b || a !== b && u[p + a - 1] < u[p + a + 1] ? (c--, m[g--] = 1) : (l--, m[g--] = -1) } return m }(n, r, s, a, c, d, h) || function (e, t, n, r, o, i, s, a) { var c = 0, l = r < a ? r : a, u = Array(l++), d = Array(l); d[0] = -1; for (var f = 1; f < l; f++)d[f] = s; for (var h = o.slice(i, s), m = t; m < n; m++) { var g, b = h.indexOf(e[m]); -1 < b && -1 < (c = p(d, l, g = b + i)) && (d[c] = g, u[c] = { newi: m, oldi: g, prev: u[c - 1] }) } for (c = --l, --s; d[c] > s;)--c; l = a + r - c; var y = Array(l), v = u[c]; for (--n; v;) { for (var w = v.newi, x = v.oldi; w < n;)y[--l] = 1, --n; for (; x < s;)y[--l] = -1, --s; y[--l] = 0, --n, --s, v = v.prev } for (; t <= n;)y[--l] = 1, --n; for (; i <= s;)y[--l] = -1, --s; return y }(n, r, i, s, a, c, u, d), e, t, n, r, a, c, f, m) }(d, e, n, y, b, k, t, g, m, x, h, u, f), n } var m = {}; function g(t, n) { n = n || {}; var r = e.createEvent("CustomEvent"); return r.initCustomEvent(t, !!n.bubbles, !!n.cancelable, n.detail), r } m.CustomEvent = "function" == typeof CustomEvent ? CustomEvent : (g["prototype"] = new g("").constructor.prototype, g); var b = m.CustomEvent, y = {}; try { y.Map = Map } catch (u) { y.Map = function () { var e = 0, t = [], n = []; return { delete: function (o) { var i = r(o); return i && (t.splice(e, 1), n.splice(e, 1)), i }, forEach: function (e, r) { t.forEach((function (t, o) { e.call(r, n[o], t, this) }), this) }, get: function (t) { return r(t) ? n[e] : void 0 }, has: r, set: function (o, i) { return n[r(o) ? e : t.push(o) - 1] = i, this } }; function r(n) { return -1 < (e = t.indexOf(n)) } } } var v = y.Map; function w() { return this } function x(e, t) { var n = "_" + e + "$"; return { get: function () { return this[n] || k(this, n, t.call(this, e)) }, set: function (e) { k(this, n, e) } } } var k = function (e, t, n) { return Object.defineProperty(e, t, { configurable: !0, value: "function" == typeof n ? function () { return e._wire$ = n.apply(this, arguments) } : n })[t] }; Object.defineProperties(w.prototype, { ELEMENT_NODE: { value: 1 }, nodeType: { value: -1 } }); var $, C, S, _, E, T, A = {}, R = {}, L = [], N = R.hasOwnProperty, D = 0, P = { attributes: A, define: function (e, t) { e.indexOf("-") < 0 ? (e in R || (D = L.push(e)), R[e] = t) : A[e] = t }, invoke: function (e, t) { for (var n = 0; n < D; n++) { var r = L[n]; if (N.call(e, r)) return R[r](e[r], t) } } }, j = Array.isArray || (C = ($ = {}.toString).call([]), function (e) { return $.call(e) === C }), I = (S = e, _ = "fragment", T = "content" in q(E = "template") ? function (e) { var t = q(E); return t.innerHTML = e, t.content } : function (e) { var t, n = q(_), r = q(E); return O(n, /^[^\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(e) ? (t = RegExp.$1, r.innerHTML = "<table>" + e + "</table>", r.querySelectorAll(t)) : (r.innerHTML = e, r.childNodes)), n }, function (e, t) { return ("svg" === t ? function (e) { var t = q(_), n = q("div"); return n.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg">' + e + "</svg>", O(t, n.firstChild.childNodes), t } : T)(e) }); function O(e, t) { for (var n = t.length; n--;)e.appendChild(t[0]) } function q(e) { return e === _ ? S.createDocumentFragment() : S.createElementNS("http://www.w3.org/1999/xhtml", e) } var W, M, z, F, U, B, H, G, V, Z = (M = "appendChild", z = "cloneNode", F = "createTextNode", B = (U = "importNode") in (W = e), (H = W.createDocumentFragment())[M](W[F]("g")), H[M](W[F]("")), (B ? W[U](H, !0) : H[z](!0)).childNodes.length < 2 ? function e(t, n) { for (var r = t[z](), o = t.childNodes || [], i = o.length, s = 0; n && s < i; s++)r[M](e(o[s], n)); return r } : B ? W[U] : function (e, t) { return e[z](!!t) }), Y = "".trim || function () { return String(this).replace(/^\s+|\s+/g, "") }, X = "-" + Math.random().toFixed(6) + "%", K = !1; try { G = e.createElement("template"), V = "tabindex", "content" in G && (G.innerHTML = "<p " + V + '="' + X + '"></p>', G.content.childNodes[0].getAttribute(V) == X) || (X = "_dt: " + X.slice(1, -1) + ";", K = !0) } catch (u) { } var J = "\x3c!--" + X + "--\x3e", Q = /^(?:style|textarea)$/i, ee = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i, te = " \\f\\n\\r\\t", ne = "[^" + te + "\\/>\"'=]+", re = "[" + te + "]+" + ne, oe = "<([A-Za-z]+[A-Za-z0-9:._-]*)((?:", ie = "(?:\\s*=\\s*(?:'[^']*?'|\"[^\"]*?\"|<[^>]*?>|" + ne.replace("\\/", "") + "))?)", se = new RegExp(oe + re + ie + "+)([" + te + "]*/?>)", "g"), ae = new RegExp(oe + re + ie + "*)([" + te + "]*/>)", "g"), ce = new RegExp("(" + re + "\\s*=\\s*)(['\"]?)" + J + "\\2", "gi"); function le(e, t, n, r) { return "<" + t + n.replace(ce, ue) + r } function ue(e, t, n) { return t + (n || '"') + X + (n || '"') } function de(e, t, n) { return ee.test(t) ? e : "<" + t + n + "></" + t + ">" } var pe = K ? function (e, t) { var n = t.join(" "); return t.slice.call(e, 0).sort((function (e, t) { return n.indexOf(e.name) <= n.indexOf(t.name) ? -1 : 1 })) } : function (e, t) { return t.slice.call(e, 0) }; function fe(e, t, n, r) { return { type: "attr", node: e, path: t, name: n, sparse: r } } function he(e, t) { return { type: "text", node: e, path: t } } var me, ge = (me = new n, { get: function (e) { return me.get(e) }, set: function (e, t) { return me.set(e, t), t } }); function be(t, n) { var r = (t.convert || function (e) { return e.join(J).replace(ae, de).replace(se, le) })(n), o = t.transform; o && (r = o(r)); var i = I(r, t.type); ve(i); var s = []; return function t(n, r, o, i) { for (var s = n.childNodes, a = s.length, c = 0; c < a;) { var l = s[c]; switch (l.nodeType) { case 1: var u = i.concat(c); !function (t, n, r, o) { for (var i, s = t.attributes, a = [], c = [], l = pe(s, r), u = l.length, d = 0; d < u;) { var p = l[d++], f = p.value === X; if (f || 1 < (i = p.value.split(J)).length) { var h = p.name; if (a.indexOf(h) < 0) { a.push(h); var m = r.shift().replace(f ? /^(?:|[\S\s]*?\s)(\S+?)\s*=\s*('|")?$/ : new RegExp("^(?:|[\\S\\s]*?\\s)(" + h + ")\\s*=\\s*('|\")[\\S\\s]*", "i"), "$1"), g = s[m] || s[m.toLowerCase()]; if (f) n.push(fe(g, o, m, null)); else { for (var b = i.length - 2; b--;)r.shift(); n.push(fe(g, o, m, i)) } } c.push(p) } } for (var y = ((d = 0) < (u = c.length) && K && !("ownerSVGElement" in t)); d < u;) { var v = c[d++]; y && (v.value = ""), t.removeAttribute(v.name) } var w = t.nodeName; if (/^script$/i.test(w)) { var x = e.createElement(w); for (u = s.length, d = 0; d < u;)x.setAttributeNode(s[d++].cloneNode(!0)); x.textContent = t.textContent, t.parentNode.replaceChild(x, t) } }(l, r, o, u), t(l, r, o, u); break; case 8: var d = l.textContent; if (d === X) o.shift(), r.push(Q.test(n.nodeName) ? he(n, i) : { type: "any", node: l, path: i.concat(c) }); else switch (d.slice(0, 2)) { case "/*": if ("*/" !== d.slice(-2)) break; case "": n.removeChild(l), c--, a-- }break; case 3: Q.test(n.nodeName) && Y.call(l.textContent) === J && (o.shift(), r.push(he(n, i))) }c++ } }(i, s, n.slice(0), []), { content: i, updates: function (e) { for (var r = [], o = s.length, i = 0, a = 0; i < o;) { var c = s[i++], l = function (e, t) { for (var n = t.length, r = 0; r < n;)e = e.childNodes[t[r++]]; return e }(e, c.path); switch (c.type) { case "any": r.push({ fn: t.any(l, []), sparse: !1 }); break; case "attr": var u = c.sparse, d = t.attribute(l, c.name, c.node); null === u ? r.push({ fn: d, sparse: !1 }) : (a += u.length - 2, r.push({ fn: d, sparse: !0, values: u })); break; case "text": r.push({ fn: t.text(l), sparse: !1 }), l.textContent = "" } } return o += a, function () { var t = arguments.length; if (o !== t - 1) throw new Error(t - 1 + " values instead of " + o + "\n" + n.join("${value}")); for (var i = 1, s = 1; i < t;) { var a = r[i - s]; if (a.sparse) { var c = a.values, l = c[0], u = 1, d = c.length; for (s += d - 2; u < d;)l += arguments[i++] + c[u++]; a.fn(l) } else a.fn(arguments[i++]) } return e } } } } var ye = []; function ve(e) { for (var t = e.childNodes, n = t.length; n--;) { var r = t[n]; 1 !== r.nodeType && 0 === Y.call(r.textContent).length && e.removeChild(r) } } var we, xe, ke = (we = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i, xe = /([^A-Z])([A-Z]+)/g, function (e, t) { return "ownerSVGElement" in e ? function (e, t) { var n; return (n = t ? t.cloneNode(!0) : (e.setAttribute("style", "--hyper:style;"), e.getAttributeNode("style"))).value = "", e.setAttributeNode(n), Ce(n, !0) }(e, t) : Ce(e.style, !1) }); function $e(e, t, n) { return t + "-" + n.toLowerCase() } function Ce(e, t) { var n, r; return function (o) { var i, s, a, c; switch (typeof o) { case "object": if (o) { if ("object" === n) { if (!t && r !== o) for (s in r) s in o || (e[s] = "") } else t ? e.value = "" : e.cssText = ""; for (s in i = t ? {} : e, o) a = "number" != typeof (c = o[s]) || we.test(s) ? c : c + "px", !t && /^--/.test(s) ? i.setProperty(s, a) : i[s] = a; n = "object", t ? e.value = function (e) { var t, n = []; for (t in e) n.push(t.replace(xe, $e), ":", e[t], ";"); return n.join("") }(r = i) : r = o; break } default: r != o && (n = "string", r = o, t ? e.value = o || "" : e.cssText = o || "") } } } var Se, _e, Ee = (Se = [].slice, (_e = Te.prototype).ELEMENT_NODE = 1, _e.nodeType = 111, _e.remove = function (e) { var t, n = this.childNodes, r = this.firstChild, o = this.lastChild; return this._ = null, e && 2 === n.length ? o.parentNode.removeChild(o) : ((t = this.ownerDocument.createRange()).setStartBefore(e ? n[1] : r), t.setEndAfter(o), t.deleteContents()), r }, _e.valueOf = function (e) { var t = this._, n = null == t; if (n && (t = this._ = this.ownerDocument.createDocumentFragment()), n || e) for (var r = this.childNodes, o = 0, i = r.length; o < i; o++)t.appendChild(r[o]); return t }, Te); function Te(e) { var t = this.childNodes = Se.call(e, 0); this.firstChild = t[0], this.lastChild = t[t.length - 1], this.ownerDocument = t[0].ownerDocument, this._ = null } function Ae(e) { return { html: e } } function Re(e, t) { switch (e.nodeType) { case Me: return 1 / t < 0 ? t ? e.remove(!0) : e.lastChild : t ? e.valueOf(!0) : e.firstChild; case We: return Re(e.render(), t); default: return e } } function Le(e, t) { t(e.placeholder), "text" in e ? Promise.resolve(e.text).then(String).then(t) : "any" in e ? Promise.resolve(e.any).then(t) : "html" in e ? Promise.resolve(e.html).then(Ae).then(t) : Promise.resolve(P.invoke(e, t)).then(t) } function Ne(e) { return null != e && "then" in e } var De, Pe, je, Ie, Oe, qe = "ownerSVGElement", We = w.prototype.nodeType, Me = Ee.prototype.nodeType, ze = (Pe = (De = { Event: b, WeakSet: u }).Event, je = De.WeakSet, Ie = !0, Oe = null, function (e) { return Ie && (Ie = !Ie, Oe = new je, function (e) { var t = new je, n = new je; try { new MutationObserver(s).observe(e, { subtree: !0, childList: !0 }) } catch (t) { var r = 0, o = [], i = function (e) { o.push(e), clearTimeout(r), r = setTimeout((function () { s(o.splice(r = 0, o.length)) }), 0) }; e.addEventListener("DOMNodeRemoved", (function (e) { i({ addedNodes: [], removedNodes: [e.target] }) }), !0), e.addEventListener("DOMNodeInserted", (function (e) { i({ addedNodes: [e.target], removedNodes: [] }) }), !0) } function s(e) { for (var r, o = e.length, i = 0; i < o; i++)a((r = e[i]).removedNodes, "disconnected", n, t), a(r.addedNodes, "connected", t, n) } function a(e, t, n, r) { for (var o, i = new Pe(t), s = e.length, a = 0; a < s; 1 === (o = e[a++]).nodeType && function e(t, n, r, o, i) { Oe.has(t) && !o.has(t) && (i.delete(t), o.add(t), t.dispatchEvent(n)); for (var s = t.children || [], a = s.length, c = 0; c < a; e(s[c++], n, r, o, i)); }(o, i, t, n, r)); } }(e.ownerDocument)), Oe.add(e), e }), Fe = /^(?:form|list)$/i, Ue = [].slice; function Be(t) { return this.type = t, function (t) { var n = ye, r = ve; return function (o) { var i, s, a; return n !== o && (i = t, s = n = o, a = ge.get(s) || ge.set(s, be(i, s)), r = a.updates(Z.call(e, a.content, !0))), r.apply(null, arguments) } }(this) } var He = !(Be.prototype = { attribute: function (e, t, n) { var r, o = qe in e; if ("style" === t) return ke(e, n, o); if ("." === t.slice(0, 1)) return s = e, a = t.slice(1), o ? function (e) { try { s[a] = e } catch (t) { s.setAttribute(a, e) } } : function (e) { s[a] = e }; if (/^on/.test(t)) { var i = t.slice(2); return "connected" === i || "disconnected" === i ? ze(e) : t.toLowerCase() in e && (i = i.toLowerCase()), function (t) { r !== t && (r && e.removeEventListener(i, r, !1), (r = t) && e.addEventListener(i, t, !1)) } } if ("data" === t || !o && t in e && !Fe.test(t)) return function (n) { r !== n && (r = n, e[t] !== n && null == n ? (e[t] = "", e.removeAttribute(t)) : e[t] = n) }; if (t in P.attributes) return function (n) { var o = P.attributes[t](e, n); r !== o && (null == (r = o) ? e.removeAttribute(t) : e.setAttribute(t, o)) }; var s, a, c = !1, l = n.cloneNode(!0); return function (t) { r !== t && (r = t, l.value !== t && (null == t ? (c && (c = !1, e.removeAttributeNode(l)), l.value = t) : (l.value = t, c || (c = !0, e.setAttributeNode(l))))) } }, any: function (e, t) { var n, r = { node: Re, before: e }, o = qe in e ? "svg" : "html", i = !1; return function s(a) { switch (typeof a) { case "string": case "number": case "boolean": i ? n !== a && (n = a, t[0].textContent = a) : (i = !0, n = a, t = h(e.parentNode, t, [(c = a, e.ownerDocument.createTextNode(c))], r)); break; case "function": s(a(e)); break; case "object": case "undefined": if (null == a) { i = !1, t = h(e.parentNode, t, [], r); break } default: if (i = !1, j(n = a)) if (0 === a.length) t.length && (t = h(e.parentNode, t, [], r)); else switch (typeof a[0]) { case "string": case "number": case "boolean": s({ html: a }); break; case "object": if (j(a[0]) && (a = a.concat.apply([], a)), Ne(a[0])) { Promise.all(a).then(s); break } default: t = h(e.parentNode, t, a, r) } else "ELEMENT_NODE" in a ? t = h(e.parentNode, t, 11 === a.nodeType ? Ue.call(a.childNodes) : [a], r) : Ne(a) ? a.then(s) : "placeholder" in a ? Le(a, s) : "text" in a ? s(String(a.text)) : "any" in a ? s(a.any) : "html" in a ? t = h(e.parentNode, t, Ue.call(I([].concat(a.html).join(""), o).childNodes), r) : s("length" in a ? Ue.call(a) : P.invoke(a, s)) }var c } }, text: function (e) { var t; return function n(r) { var o; t !== r && ("object" == (o = typeof (t = r)) && r ? Ne(r) ? r.then(n) : "placeholder" in r ? Le(r, n) : n("text" in r ? String(r.text) : "any" in r ? r.any : "html" in r ? [].concat(r.html).join("") : "length" in r ? Ue.call(r).join("") : P.invoke(r, n)) : "function" == o ? n(r(e)) : e.textContent = null == r ? "" : r) } } }), Ge = function (t) { var r, o, i, s, a = (r = (e.defaultView.navigator || {}).userAgent, /(Firefox|Safari)\/(\d+)/.test(r) && !/(Chrom[eium]+|Android)\/(\d+)/.test(r)), c = !("raw" in t) || t.propertyIsEnumerable("raw") || !Object.isFrozen(t.raw); return a || c ? (o = {}, i = function (e) { for (var t = ".", n = 0; n < e.length; n++)t += e[n].length + "." + e[n]; return o[t] || (o[t] = e) }, Ge = c ? i : (s = new n, function (e) { return s.get(e) || (n = i(t = e), s.set(t, n), n); var t, n })) : He = !0, Ve(t) }; function Ve(e) { return He ? e : Ge(e) } function Ze(e) { for (var t = arguments.length, n = [Ve(e)], r = 1; r < t;)n.push(arguments[r++]); return n } var Ye = new n, Xe = function (e) { var t, n, r; return function () { var o = Ze.apply(null, arguments); return r !== o[0] ? (r = o[0], n = new Be(e), t = Je(n.apply(n, o))) : n.apply(n, o), t } }, Ke = function (e, t) { var n = t.indexOf(":"), r = Ye.get(e), o = t; return -1 < n && (o = t.slice(n + 1), t = t.slice(0, n) || "html"), r || Ye.set(e, r = {}), r[o] || (r[o] = Xe(t)) }, Je = function (e) { var t = e.childNodes, n = t.length; return 1 === n ? t[0] : n ? new Ee(t) : e }, Qe = new n; function et() { var e = Qe.get(this), t = Ze.apply(null, arguments); return e && e.template === t[0] ? e.tagger.apply(null, t) : function (e) { var t = new Be(qe in this ? "svg" : "html"); Qe.set(this, { tagger: t, template: e }), this.textContent = "", this.appendChild(t.apply(null, arguments)) }.apply(this, t), this } var tt, nt, rt, ot, it = P.define, st = Be.prototype; function at(e) { return arguments.length < 2 ? null == e ? Xe("html") : "string" == typeof e ? at.wire(null, e) : "raw" in e ? Xe("html")(e) : "nodeType" in e ? at.bind(e) : Ke(e, "html") : ("raw" in e ? Xe("html") : at.wire).apply(null, arguments) } return at.Component = w, at.bind = function (e) { return et.bind(e) }, at.define = it, at.diff = h, (at.hyper = at).observe = ze, at.tagger = st, at.wire = function (e, t) { return null == e ? Xe(t || "html") : Ke(e, t || "html") }, at._ = { WeakMap: n, WeakSet: u }, tt = Xe, nt = new n, rt = Object.create, ot = function (e, t) { var n = { w: null, p: null }; return t.set(e, n), n }, Object.defineProperties(w, { for: { configurable: !0, value: function (e, t) { return function (e, t, r, o) { var i, s, a, c = t.get(e) || ot(e, t); switch (typeof o) { case "object": case "function": var l = c.w || (c.w = new n); return l.get(o) || (i = l, s = o, a = new e(r), i.set(s, a), a); default: var u = c.p || (c.p = rt(null)); return u[o] || (u[o] = new e(r)) } }(this, nt.get(e) || (r = e, o = new v, nt.set(r, o), o), e, null == t ? "default" : t); var r, o } } }), Object.defineProperties(w.prototype, { handleEvent: { value: function (e) { var t = e.currentTarget; this["getAttribute" in t && t.getAttribute("data-call") || "on" + e.type](e) } }, html: x("html", tt), svg: x("svg", tt), state: x("state", (function () { return this.defaultState })), defaultState: { get: function () { return {} } }, dispatch: { value: function (e, t) { var n = this._wire$; if (n) { var r = new b(e, { bubbles: !0, cancelable: !0, detail: t }); return r.component = this, (n.dispatchEvent ? n : n.firstChild).dispatchEvent(r) } return !1 } }, setState: { value: function (e, t) { var n = this.state, r = "function" == typeof e ? e.call(this, n) : e; for (var o in r) n[o] = r[o]; return !1 !== t && this.render(), this } } }), at }(document);
/*! (c) Andrea Giammarchi (ISC) */const Kt = P, Jt = Ve, Qt = Xt, en = Zt, tn = Yt, nn = /-/g; const rn = yn({ en: { x_and_y: " and ", x_y_and_z: ", and " }, de: { x_and_y: " und ", x_y_and_z: " und " } }), on = new Intl.DateTimeFormat(["en-ca-iso8601"], { timeZone: "UTC", year: "numeric", month: "2-digit", day: "2-digit" }), sn = new Set(["dns-prefetch", "preconnect", "preload", "prerender"]), an = new Set(["document", "embed", "font", "image", "manifest", "media", "object", "report", "script", "serviceworker", "sharedworker", "style", "worker", "xslt", ""]), cn = ".informative, .note, .issue, .example, .ednote, .practice, .introductory"; function ln(e) { if (!e || "object" != typeof e) throw new TypeError("Missing options"); if (!sn.has(e.hint)) throw new TypeError("Invalid resources hint"); const t = new URL(e.href, location.href), n = document.createElement("link"); let { href: r } = t; switch (n.rel = e.hint, n.rel) { case "dns-prefetch": case "preconnect": r = t.origin, (e.corsMode || t.origin !== document.location.origin) && (n.crossOrigin = e.corsMode || "anonymous"); break; case "preload": "as" in e && "string" == typeof e.as && (an.has(e.as) || console.warn("Unknown request destination: " + e.as), n.setAttribute("as", e.as)) }return n.href = r, e.dontRemove || n.classList.add("removeOnSave"), n } function un(e) { e.querySelectorAll(".remove, script[data-requiremodule]").forEach(e => { e.remove() }) } function dn(e, t, n, { details: o } = {}) { Array.isArray(e) || (e = [e]); const i = e.map((e, r) => (fn(e, t, n), hn(e, r))).join(", "); let s = `${t} at: ${i}.`; o && (s += `\n\n<details>${o}</details>`), r("warn", s), console.warn(t, e) } function pn(e, t, n, { details: o } = {}) { Array.isArray(e) || (e = [e]); const i = e.map((e, r) => (fn(e, t, n), hn(e, r))).join(", "); let s = `${t} at: ${i}.`; o && (s += `\n\n<details>${o}</details>`), r("error", s), console.error(t, e) } function fn(e, t, n) { e.classList.add("respec-offending-element"), e.hasAttribute("title") || e.setAttribute("title", n || t), e.id || _n(e, "respec-offender") } function hn(e, t) { return `[${t + 1}](#${e.id})` } class mn { constructor(e, t) { this.idb = e, this.storeName = t } async get(e) { return await this.idb.transaction(this.storeName).objectStore(this.storeName).get(e) } async getMany(e) { const t = new Set(e), n = new Map; let r = await this.idb.transaction(this.storeName).store.openCursor(); for (; r;)t.has(r.key) && n.set(r.key, r.value), r = await r.continue(); return n } async set(e, t) { const n = this.idb.transaction(this.storeName, "readwrite"); return n.objectStore(this.storeName).put(t, e), await n.done } async addMany(e) { const t = this.idb.transaction(this.storeName, "readwrite"); for (const [n, r] of e) t.objectStore(this.storeName).put(r, n); return await t.done } async clear() { const e = this.idb.transaction(this.storeName, "readwrite"); return e.objectStore(this.storeName).clear(), await e.done } async keys() { const e = this.idb.transaction(this.storeName), t = e.objectStore(this.storeName).getAllKeys(); return await e.done, t } } function gn(e = [], t = (e => e), n = g) { const r = e.map(t); if (Intl.ListFormat && "function" == typeof Intl.ListFormat) { return new Intl.ListFormat(n, { style: "long", type: "conjunction" }).format(r) } switch (r.length) { case 0: case 1: return r.toString(); case 2: return r.join(rn.x_and_y); default: { const e = r.join(", "), t = e.lastIndexOf(","), n = rn.x_y_and_z; return `${e.substr(0, t)}${n}${e.slice(t + 2)}` } } } function bn(e) { return e.trim().replace(/\s+/g, " ") } function yn(e, t = g) { return t = function (e) { return { "zh-hans": "zh", "zh-cn": "zh" }[e] || e }(t), new Proxy(e, { get(e, n) { const r = e[t] && e[t][n] || e.en[n]; if (!r) throw new Error(`No l10n data for key: "${n}"`); return r } }) } function vn(e, t = "") { return on.format(e).replace(nn, t) } function wn(e = new Date, t = document.documentElement.lang || "en") { e instanceof Date || (e = new Date(e)); const n = [t, "en"]; return `${e.toLocaleString(n, { day: "2-digit", timeZone: "UTC" })} ${e.toLocaleString(n, { month: "long", timeZone: "UTC" })} ${e.toLocaleString(n, { year: "numeric", timeZone: "UTC" })}` } function xn(e, t, ...n) { const o = [this, e, ...n]; if (t) { const n = t.split(/\s+/); for (const t of n) { const n = window[t]; if (n) try { e = n.apply(this, o) } catch (e) { r("warn", `call to \`${t}()\` failed with: ${e}. See error console for stack trace.`), console.error(e) } } } return e } async function kn(e, t = 864e5) { const n = new Request(e), r = new URL(n.url); let o, i; if ("caches" in window) try { if (o = await caches.open(r.origin), i = await o.match(n), i && new Date(i.headers.get("Expires")) > new Date) return i } catch (e) { console.error("Failed to use Cache API.", e) } const s = await fetch(n); if (!s.ok && i) return console.warn("Returning a stale cached response for " + r), i; if (o && s.ok) { const e = s.clone(), r = new Headers(s.headers), i = new Date(Date.now() + t); r.set("Expires", i.toString()); const a = new Response(await e.blob(), { headers: r }); await o.put(n, a).catch(console.error) } return s } function $n(e, t = (e => e)) { const n = e.map(t), r = n.slice(0, -1).map(e => Qt`${e}, `); return Qt`${r}${n[n.length - 1]}` } function Cn(e, t = (e => e)) { const n = e.map(t); switch (n.length) { case 0: case 1: return n[0]; case 2: return Qt`${n[0]}${rn.x_and_y}${n[1]}`; default: { const e = $n(n.slice(0, -1)); return Qt`${e}${rn.x_y_and_z}${n[n.length - 1]}` } } } function Sn(e, t = "") { return _n(e, t, function (e) { let t = 0; for (const n of e) t = Math.imul(31, t) + n.charCodeAt(0) | 0; return String(t) }(bn(e.textContent))) } function _n(e, t = "", n = "", r = !1) { if (e.id) return e.id; n || (n = (e.title ? e.title : e.textContent).trim()); let o = r ? n : n.toLowerCase(); if (o = o.trim().normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/\W+/gim, "-").replace(/^-+/, "").replace(/-+$/, ""), o ? !/\.$/.test(o) && /^[a-z]/i.test(t || o) || (o = "x" + o) : o = "generatedID", t && (o = `${t}-${o}`), e.ownerDocument.getElementById(o)) { let t = 0, n = `${o}-${t}`; for (; e.ownerDocument.getElementById(n);)t += 1, n = `${o}-${t}`; o = n } return e.id = o, o } function En(e, t = [], n = { wsNodes: !0 }) { const r = t.join(", "), o = document.createNodeIterator(e, NodeFilter.SHOW_TEXT, e => n.wsNodes || e.data.trim() ? r && e.parentElement.closest(r) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT), i = []; let s; for (; s = o.nextNode();)i.push(s); return i } function Tn(e) { const t = new Set, n = "ltNodefault" in e.dataset ? "" : bn(e.textContent), r = e.children[0]; if (e.dataset.lt ? e.dataset.lt.split("|").map(e => bn(e)).forEach(e => t.add(e)) : 1 === e.childNodes.length && 1 === e.getElementsByTagName("abbr").length && r.title ? t.add(r.title) : '""' === e.textContent && t.add("the-empty-string"), t.add(n), t.delete(""), e.dataset.localLt) { e.dataset.localLt.split("|").forEach(e => t.add(bn(e))) } return [...t] } function An(e) { const t = e.closest("[data-link-for]"), n = t ? t.dataset.linkFor : ""; return Tn(e).reduce((e, t) => { const r = t.split("."); return 2 === r.length && e.push({ for: r[0], title: r[1] }), e.push({ for: n, title: t }), "" !== n && e.push({ for: "", title: t }), e }, []) } function Rn(e, t) { if (e.localName === t) return e; const n = e.ownerDocument.createElement(t); for (const { name: t, value: r } of e.attributes) n.setAttribute(t, r); return n.append(...e.childNodes), e.replaceWith(n), n } function Ln(e, t) { const n = t.closest(cn); let r = !1; if (n && (r = !t.closest(".normative") || !n.querySelector(".normative")), e.startsWith("!")) { if (r) return { type: "informative", illegal: !0 }; r = !1 } else e.startsWith("?") && (r = !0); return { type: r ? "informative" : "normative", illegal: !1 } } function Nn(e, t) { return t.append(...e.childNodes), e.appendChild(t), e } function Dn(e, t) { const n = []; let r = e.parentElement; for (; r;) { const e = r.closest(t); if (!e) break; n.push(e), r = e.parentElement } return n } function Pn(e) { const { previousSibling: t } = e; if (!t || t.nodeType !== Node.TEXT_NODE) return ""; const n = t.textContent.lastIndexOf("\n"); if (-1 === n) return ""; const r = t.textContent.slice(n + 1); return /\S/.test(r) ? "" : r } class jn extends Set { constructor(e = []) { super(); for (const t of e) this.add(t) } add(e) { return this.has(e) || this.getCanonicalKey(e) ? this : super.add(e) } has(e) { return super.has(e) || [...this.keys()].some(t => t.toLowerCase() === e.toLowerCase()) } delete(e) { return super.has(e) ? super.delete(e) : super.delete(this.getCanonicalKey(e)) } getCanonicalKey(e) { return super.has(e) ? e : [...this.keys()].find(t => t.toLowerCase() === e.toLowerCase()) } } function In(e) { const t = e.cloneNode(!0); return t.querySelectorAll("[id]").forEach(e => e.removeAttribute("id")), t.querySelectorAll("dfn").forEach(e => Rn(e, "span")), t.hasAttribute("id") && t.removeAttribute("id"), On(t), t } function On(e) { const t = document.createTreeWalker(e, NodeFilter.SHOW_COMMENT); for (const e of [...qn(t)]) e.remove() } function* qn(e) { for (; e.nextNode();)yield e.currentNode } class Wn extends Map { constructor(e = []) { return super(), e.forEach(([e, t]) => { this.set(e, t) }), this } set(e, t) { return super.set(e.toLowerCase(), t), this } get(e) { return super.get(e.toLowerCase()) } has(e) { return super.has(e.toLowerCase()) } delete(e) { return super.delete(e.toLowerCase()) } } const Mn = "core/base-runner", zn = performance.mark && performance.measure; function Fn(e) { const t = e.name || ""; return t || console.warn("Plugin lacks name:", e), n => new Promise(async (r, o) => { const i = setTimeout(() => { const n = `Plugin ${t} took too long.`; console.error(n, e), o(new Error(n)) }, 15e3); zn && performance.mark(t + "-start"); try { e.Plugin ? (await new e.Plugin(n).run(), r()) : e.run.length <= 1 ? (await e.run(n), r()) : (console.warn(`Plugin ${t} uses a deprecated callback signature. Return a Promise instead. Read more at: https://github.com/w3c/respec/wiki/Developers-Guide#plugins`), e.run(n, document, r)) } catch (e) { o(e) } finally { clearTimeout(i) } zn && (performance.mark(t + "-end"), performance.measure(t, t + "-start", t + "-end")) }) } function Un(e) { return e && (e.run || e.Plugin) } var Bn = Object.freeze({ __proto__: null, name: Mn, runAll: async function (e) { r("start-all", respecConfig), zn && performance.mark(Mn + "-start"), await f; const t = e.filter(Un).map(Fn); for (const e of t) try { await e(respecConfig) } catch (e) { console.error(e) } r("plugins-done", respecConfig), await d, r("end-all", respecConfig), un(document), zn && (performance.mark(Mn + "-end"), performance.measure(Mn, Mn + "-start", Mn + "-end")) } }); async function Hn(e) { const t = await fetch(new URL("../../" + e, document.currentScript && document.currentScript.src || new URL("respec-w3c-common.js", document.baseURI).href)); return await t.text() } async function Gn(e) { return Hn("assets/" + e) } function Vn(e) { if (!e) return e; const t = e.trimEnd().split("\n"); for (; t.length && !t[0].trim();)t.shift(); const n = t.filter(e => e.trim()).map(e => e.search(/[^\s]/)), r = Math.min(...n); return t.map(e => e.slice(r)).join("\n") } var Zn = Object.freeze({ __proto__: null, name: "core/reindent", reindent: Vn, run: function () { for (const e of document.getElementsByTagName("pre")) e.innerHTML = Vn(e.innerHTML) } }); const Yn = /&gt;/gm, Xn = /&amp;/gm; class Kn extends en.Renderer { code(e, t, n) { return /(^webidl$)/i.test(t) ? `<pre class="idl">${e}</pre>` : super.code(e, t, n) } heading(e, t, n, r) { const o = /(.+)\s+{#([\w-]+)}$/; if (o.test(e)) { const [, n, r] = e.match(o); return `<h${t} id="${r}">${n}</h${t}>` } return super.heading(e, t, n, r) } } function Jn(e) { const t = Vn(e).replace(Yn, ">").replace(Xn, "&"); return en(t, { sanitize: !1, gfm: !0, headerIds: !1, langPrefix: "", renderer: new Kn }) } function Qn(e) { for (const t of e.getElementsByTagName("pre")) t.prepend("\n"); e.innerHTML = Jn(e.innerHTML) } class er { constructor(e) { this.doc = e, this.root = e.createDocumentFragment(), this.stack = [this.root], this.current = this.root } findPosition(e) { return parseInt(e.tagName.charAt(1), 10) } findParent(e) { let t; for (; e > 0;)if (e--, t = this.stack[e], t) return t } findHeader({ firstChild: e }) { for (; e;) { if (/H[1-6]/.test(e.tagName)) return e; e = e.nextSibling } return null } addHeader(e) { const t = this.doc.createElement("section"), n = this.findPosition(e); t.appendChild(e), this.findParent(n).appendChild(t), this.stack[n] = t, this.stack.length = n + 1, this.current = t } addSection(e, t) { const n = this.findHeader(e), r = n ? this.findPosition(n) : 1, o = this.findParent(r); n && e.removeChild(n), e.appendChild(t(e)), n && e.prepend(n), o.appendChild(e), this.current = o } addElement(e) { this.current.appendChild(e) } } function tr(e, t) { return function e(n) { const r = new er(t); for (; n.firstChild;) { const t = n.firstChild; if (t.nodeType === Node.ELEMENT_NODE) switch (t.localName) { case "h1": case "h2": case "h3": case "h4": case "h5": case "h6": r.addHeader(t); break; case "section": r.addSection(t, e); break; default: r.addElement(t) } else n.removeChild(t) } return r.root }(e) } const nr = (rr = "[data-format='markdown']:not(body)", e => { const t = e.querySelectorAll(rr); return t.forEach(Qn), Array.from(t) }); var rr; var or = Object.freeze({ __proto__: null, name: "core/markdown", markdownToHtml: Jn, run: function (e) { const t = !!document.querySelector("[data-format=markdown]:not(body)"), n = "markdown" === e.format; if (!n && !t) return; if (!n) return void nr(document.body).map(e => ({ structuredInternals: tr(e, e.ownerDocument), elem: e })).forEach(({ elem: e, structuredInternals: t }) => { if (e.setAttribute("aria-busy", "true"), "section" === t.firstElementChild.localName && "section" === e.localName) { const n = t.firstElementChild; n.remove(), e.append(...n.childNodes) } else e.textContent = ""; e.appendChild(t), e.setAttribute("aria-busy", "false") }); const r = document.getElementById("respec-ui"); r.remove(); const o = document.body.cloneNode(!0); !function (e, t) { const n = e.querySelectorAll(t); for (const e of n) { const { innerHTML: t } = e; if (/^<\w/.test(t.trimStart())) continue; const n = t.split("\n"), r = n.slice(0, 2).join("\n"), o = n.slice(-2).join("\n"); if (r.trim() && e.prepend("\n\n"), o.trim()) { const t = Pn(e); e.append("\n\n" + t) } } }(o, "[data-format=markdown], section, div, address, article, aside, figure, header, main"), Qn(o), function (e) { Array.from(e).forEach(e => { e.replaceWith(e.textContent) }) }(o.querySelectorAll(".nolinks a[href]")); const i = tr(o, document); o.append(r, i), document.body.replaceWith(o) } }), ir = { all_shortcuts: {}, add: function (e, t, n) { var r = { type: "keydown", propagate: !1, disable_in_input: !1, target: document, keycode: !1 }; if (n) for (var o in r) void 0 === n[o] && (n[o] = r[o]); else n = r; var i = n.target; "string" == typeof n.target && (i = document.getElementById(n.target)), e = e.toLowerCase(); var s = function (r) { var o, i; if ((r = r || window.event, n.disable_in_input) && (r.target ? i = r.target : r.srcElement && (i = r.srcElement), 3 == i.nodeType && (i = i.parentNode), "INPUT" == i.tagName || "TEXTAREA" == i.tagName)) return; r.keyCode ? o = r.keyCode : r.which && (o = r.which); var s = String.fromCharCode(o).toLowerCase(); 188 == o && (s = ","), 190 == o && (s = "."); var a = e.split("+"), c = 0, l = { "`": "~", 1: "!", 2: "@", 3: "#", 4: "$", 5: "%", 6: "^", 7: "&", 8: "*", 9: "(", 0: ")", "-": "_", "=": "+", ";": ":", "'": '"', ",": "<", ".": ">", "/": "?", "\\": "|" }, u = { esc: 27, escape: 27, tab: 9, space: 32, return: 13, enter: 13, backspace: 8, scrolllock: 145, scroll_lock: 145, scroll: 145, capslock: 20, caps_lock: 20, caps: 20, numlock: 144, num_lock: 144, num: 144, pause: 19, break: 19, insert: 45, home: 36, delete: 46, end: 35, pageup: 33, page_up: 33, pu: 33, pagedown: 34, page_down: 34, pd: 34, left: 37, up: 38, right: 39, down: 40, f1: 112, f2: 113, f3: 114, f4: 115, f5: 116, f6: 117, f7: 118, f8: 119, f9: 120, f10: 121, f11: 122, f12: 123 }, d = { shift: { wanted: !1, pressed: !1 }, ctrl: { wanted: !1, pressed: !1 }, alt: { wanted: !1, pressed: !1 }, meta: { wanted: !1, pressed: !1 } }; r.ctrlKey && (d.ctrl.pressed = !0), r.shiftKey && (d.shift.pressed = !0), r.altKey && (d.alt.pressed = !0), r.metaKey && (d.meta.pressed = !0); for (var p, f = 0; p = a[f], f < a.length; f++)"ctrl" == p || "control" == p ? (c++, d.ctrl.wanted = !0) : "shift" == p ? (c++, d.shift.wanted = !0) : "alt" == p ? (c++, d.alt.wanted = !0) : "meta" == p ? (c++, d.meta.wanted = !0) : p.length > 1 ? u[p] == o && c++ : n.keycode ? n.keycode == o && c++ : (s == p || l[s] && r.shiftKey && (s = l[s]) == p) && c++; if (c == a.length && d.ctrl.pressed == d.ctrl.wanted && d.shift.pressed == d.shift.wanted && d.alt.pressed == d.alt.wanted && d.meta.pressed == d.meta.wanted && (t(r), !n.propagate)) return r.cancelBubble = !0, r.returnValue = !1, r.stopPropagation && (r.stopPropagation(), r.preventDefault()), !1 }; this.all_shortcuts[e] = { callback: s, target: i, event: n.type }, i.addEventListener ? i.addEventListener(n.type, s, !1) : i.attachEvent ? i.attachEvent("on" + n.type, s) : i["on" + n.type] = s } }; function sr(e, t) { e && Array.from(t).forEach(([t, n]) => { e.setAttribute("aria-" + t, n) }) } !async function () { const e = document.createElement("style"); e.id = "respec-ui-styles", e.textContent = await async function () { try { return (await Promise.resolve().then((function () { return bl }))).default } catch { return Gn("ui.css") } }(), e.classList.add("removeOnSave"), document.head.appendChild(e) }(); const ar = Qt`<div id="respec-ui" class="removeOnSave" hidden></div>`, cr = Qt`<ul
  id="respec-menu"
  role="menu"
  aria-labelledby="respec-pill"
  hidden
></ul>`, lr = Qt`<button
  class="close-button"
  onclick=${() => wr.closeModal()}
  title="Close"
>
  
</button>`; let ur, dr; window.addEventListener("load", () => br(cr)); const pr = [], fr = [], hr = {}; o("start-all", () => document.body.prepend(ar), { once: !0 }), o("end-all", () => document.body.prepend(ar), { once: !0 }); const mr = Qt`<button id="respec-pill" disabled>ReSpec</button>`; function gr() { cr.classList.toggle("respec-hidden"), cr.classList.toggle("respec-visible"), cr.hidden = !cr.hidden } function br(e) { const t = e.querySelectorAll("a[href]:not([disabled]), button:not([disabled]), textarea:not([disabled]), input:not([disabled]), select:not([disabled])"), n = t[0], r = t[t.length - 1]; n && n.focus(), e.addEventListener("keydown", e => { "Tab" === e.key && (e.shiftKey ? document.activeElement === n && (r.focus(), e.preventDefault()) : document.activeElement === r && (n.focus(), e.preventDefault())) }) } ar.appendChild(mr), mr.addEventListener("click", e => { e.stopPropagation(), mr.setAttribute("aria-expanded", String(cr.hidden)), gr(), cr.querySelector("li:first-child button").focus() }), document.documentElement.addEventListener("click", () => { cr.hidden || gr() }), ar.appendChild(cr), cr.addEventListener("keydown", e => { "Escape" !== e.key || cr.hidden || (mr.setAttribute("aria-expanded", String(cr.hidden)), gr(), mr.focus()) }); const yr = new Map([["controls", "respec-menu"], ["expanded", "false"], ["haspopup", "true"], ["label", "ReSpec Menu"]]); function vr(e, t, n, r) {
    t.push(e), hr.hasOwnProperty(n) || (hr[n] = function (e, t, n) {
      const r = Qt`<button
    id="${"respec-pill-" + e}"
    class="respec-info-button"
  ></button>`; r.addEventListener("click", () => { r.setAttribute("aria-expanded", "true"); const o = Qt`<ol class="${`respec-${e}-list`}"></ol>`; for (const e of t) { const t = document.createRange().createContextualFragment(Jn(e)), n = document.createElement("li"); t.firstElementChild === t.lastElementChild ? n.append(...t.firstElementChild.childNodes) : n.appendChild(t), o.appendChild(n) } wr.freshModal(n, o, r) }); const o = new Map([["expanded", "false"], ["haspopup", "true"], ["controls", `respec-pill-${e}-modal`]]); return sr(r, o), r
    }(n, t, r), ar.appendChild(hr[n])); const o = hr[n]; o.textContent = t.length; const i = 1 === t.length ? tn.singular(r) : r; sr(o, new Map([["label", `${t.length} ${i}`]]))
  } sr(mr, yr); const wr = {
    show() { try { ar.hidden = !1 } catch (e) { console.error(e) } }, hide() { ar.hidden = !0 }, enable() { mr.removeAttribute("disabled") }, addCommand(e, t, n, r) {
      r = r || ""; const o = "respec-button-" + e.toLowerCase().replace(/\s+/, "-"), i = Qt`<button
      id="${o}"
      class="respec-option"
      title="${n}"
    >
      <span class="respec-cmd-icon" aria-hidden="true">${r}</span> ${e}
    </button>`, s = Qt`<li role="menuitem">${i}</li>`; return s.addEventListener("click", t), cr.appendChild(s), n && ir.add(n, t), i
    }, error(e) { vr(e, pr, "error", "ReSpec Errors") }, warning(e) { vr(e, fr, "warning", "ReSpec Warnings") }, closeModal(e) { dr && (dr.classList.remove("respec-show-overlay"), dr.classList.add("respec-hide-overlay"), dr.addEventListener("transitionend", () => { dr.remove(), dr = null })), e && e.setAttribute("aria-expanded", "false"), ur && (ur.remove(), ur = null, mr.focus()) }, freshModal(e, t, n) {
      ur && ur.remove(), dr && dr.remove(), dr = Qt`<div id="respec-overlay" class="removeOnSave"></div>`; const r = n.id + "-modal", o = r + "-heading"; ur = Qt`<div
      id="${r}"
      class="respec-modal removeOnSave"
      role="dialog"
      aria-labelledby="${o}"
    >
      ${lr}
      <h3 id="${o}">${e}</h3>
      <div class="inside">${t}</div>
    </div>`; const i = new Map([["labelledby", o]]); sr(ur, i), document.body.append(dr, ur), dr.addEventListener("click", () => this.closeModal(n)), dr.classList.toggle("respec-show-overlay"), ur.hidden = !1, br(ur)
    }
  }; ir.add("Esc", () => wr.closeModal()), ir.add("Ctrl+Alt+Shift+E", () => { hr.error && hr.error.click() }), ir.add("Ctrl+Alt+Shift+W", () => { hr.warning && hr.warning.click() }), window.respecUI = wr, o("error", e => wr.error(e)), o("warn", e => wr.warning(e)); var xr = Object.freeze({ __proto__: null, name: "core/ui", ui: wr }), kr = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; var $r = function (e, t) { return e(t = { exports: {} }, t.exports), t.exports }((function (e) {
    /*!
       * jQuery JavaScript Library v3.5.1
       * https://jquery.com/
       *
       * Includes Sizzle.js
       * https://sizzlejs.com/
       *
       * Copyright JS Foundation and other contributors
       * Released under the MIT license
       * https://jquery.org/license
       *
       * Date: 2020-05-04T22:49Z
       */
    !function (t, n) { e.exports = t.document ? n(t, !0) : function (e) { if (!e.document) throw new Error("jQuery requires a window with a document"); return n(e) } }("undefined" != typeof window ? window : kr, (function (e, t) {
      var n = [], r = Object.getPrototypeOf, o = n.slice, i = n.flat ? function (e) { return n.flat.call(e) } : function (e) { return n.concat.apply([], e) }, s = n.push, a = n.indexOf, c = {}, l = c.toString, u = c.hasOwnProperty, d = u.toString, p = d.call(Object), f = {}, h = function (e) { return "function" == typeof e && "number" != typeof e.nodeType }, m = function (e) { return null != e && e === e.window }, g = e.document, b = { type: !0, src: !0, nonce: !0, noModule: !0 }; function y(e, t, n) { var r, o, i = (n = n || g).createElement("script"); if (i.text = e, t) for (r in b) (o = t[r] || t.getAttribute && t.getAttribute(r)) && i.setAttribute(r, o); n.head.appendChild(i).parentNode.removeChild(i) } function v(e) { return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? c[l.call(e)] || "object" : typeof e } var w = function (e, t) { return new w.fn.init(e, t) }; function x(e) { var t = !!e && "length" in e && e.length, n = v(e); return !h(e) && !m(e) && ("array" === n || 0 === t || "number" == typeof t && t > 0 && t - 1 in e) } w.fn = w.prototype = { jquery: "3.5.1", constructor: w, length: 0, toArray: function () { return o.call(this) }, get: function (e) { return null == e ? o.call(this) : e < 0 ? this[e + this.length] : this[e] }, pushStack: function (e) { var t = w.merge(this.constructor(), e); return t.prevObject = this, t }, each: function (e) { return w.each(this, e) }, map: function (e) { return this.pushStack(w.map(this, (function (t, n) { return e.call(t, n, t) }))) }, slice: function () { return this.pushStack(o.apply(this, arguments)) }, first: function () { return this.eq(0) }, last: function () { return this.eq(-1) }, even: function () { return this.pushStack(w.grep(this, (function (e, t) { return (t + 1) % 2 }))) }, odd: function () { return this.pushStack(w.grep(this, (function (e, t) { return t % 2 }))) }, eq: function (e) { var t = this.length, n = +e + (e < 0 ? t : 0); return this.pushStack(n >= 0 && n < t ? [this[n]] : []) }, end: function () { return this.prevObject || this.constructor() }, push: s, sort: n.sort, splice: n.splice }, w.extend = w.fn.extend = function () { var e, t, n, r, o, i, s = arguments[0] || {}, a = 1, c = arguments.length, l = !1; for ("boolean" == typeof s && (l = s, s = arguments[a] || {}, a++), "object" == typeof s || h(s) || (s = {}), a === c && (s = this, a--); a < c; a++)if (null != (e = arguments[a])) for (t in e) r = e[t], "__proto__" !== t && s !== r && (l && r && (w.isPlainObject(r) || (o = Array.isArray(r))) ? (n = s[t], i = o && !Array.isArray(n) ? [] : o || w.isPlainObject(n) ? n : {}, o = !1, s[t] = w.extend(l, i, r)) : void 0 !== r && (s[t] = r)); return s }, w.extend({ expando: "jQuery" + ("3.5.1" + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (e) { throw new Error(e) }, noop: function () { }, isPlainObject: function (e) { var t, n; return !(!e || "[object Object]" !== l.call(e)) && (!(t = r(e)) || "function" == typeof (n = u.call(t, "constructor") && t.constructor) && d.call(n) === p) }, isEmptyObject: function (e) { var t; for (t in e) return !1; return !0 }, globalEval: function (e, t, n) { y(e, { nonce: t && t.nonce }, n) }, each: function (e, t) { var n, r = 0; if (x(e)) for (n = e.length; r < n && !1 !== t.call(e[r], r, e[r]); r++); else for (r in e) if (!1 === t.call(e[r], r, e[r])) break; return e }, makeArray: function (e, t) { var n = t || []; return null != e && (x(Object(e)) ? w.merge(n, "string" == typeof e ? [e] : e) : s.call(n, e)), n }, inArray: function (e, t, n) { return null == t ? -1 : a.call(t, e, n) }, merge: function (e, t) { for (var n = +t.length, r = 0, o = e.length; r < n; r++)e[o++] = t[r]; return e.length = o, e }, grep: function (e, t, n) { for (var r = [], o = 0, i = e.length, s = !n; o < i; o++)!t(e[o], o) !== s && r.push(e[o]); return r }, map: function (e, t, n) { var r, o, s = 0, a = []; if (x(e)) for (r = e.length; s < r; s++)null != (o = t(e[s], s, n)) && a.push(o); else for (s in e) null != (o = t(e[s], s, n)) && a.push(o); return i(a) }, guid: 1, support: f }), "function" == typeof Symbol && (w.fn[Symbol.iterator] = n[Symbol.iterator]), w.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), (function (e, t) { c["[object " + t + "]"] = t.toLowerCase() })); var k =
        /*!
           * Sizzle CSS Selector Engine v2.3.5
           * https://sizzlejs.com/
           *
           * Copyright JS Foundation and other contributors
           * Released under the MIT license
           * https://js.foundation/
           *
           * Date: 2020-03-14
           */
        function (e) { var t, n, r, o, i, s, a, c, l, u, d, p, f, h, m, g, b, y, v, w = "sizzle" + 1 * new Date, x = e.document, k = 0, $ = 0, C = ce(), S = ce(), _ = ce(), E = ce(), T = function (e, t) { return e === t && (d = !0), 0 }, A = {}.hasOwnProperty, R = [], L = R.pop, N = R.push, D = R.push, P = R.slice, j = function (e, t) { for (var n = 0, r = e.length; n < r; n++)if (e[n] === t) return n; return -1 }, I = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", O = "[\\x20\\t\\r\\n\\f]", q = "(?:\\\\[\\da-fA-F]{1,6}" + O + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", W = "\\[" + O + "*(" + q + ")(?:" + O + "*([*^$|!~]?=)" + O + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + q + "))|)" + O + "*\\]", M = ":(" + q + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + W + ")*)|.*)\\)|)", z = new RegExp(O + "+", "g"), F = new RegExp("^" + O + "+|((?:^|[^\\\\])(?:\\\\.)*)" + O + "+$", "g"), U = new RegExp("^" + O + "*," + O + "*"), B = new RegExp("^" + O + "*([>+~]|" + O + ")" + O + "*"), H = new RegExp(O + "|>"), G = new RegExp(M), V = new RegExp("^" + q + "$"), Z = { ID: new RegExp("^#(" + q + ")"), CLASS: new RegExp("^\\.(" + q + ")"), TAG: new RegExp("^(" + q + "|[*])"), ATTR: new RegExp("^" + W), PSEUDO: new RegExp("^" + M), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + O + "*(even|odd|(([+-]|)(\\d*)n|)" + O + "*(?:([+-]|)" + O + "*(\\d+)|))" + O + "*\\)|)", "i"), bool: new RegExp("^(?:" + I + ")$", "i"), needsContext: new RegExp("^" + O + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + O + "*((?:-\\d)?\\d*)" + O + "*\\)|)(?=[^-]|$)", "i") }, Y = /HTML$/i, X = /^(?:input|select|textarea|button)$/i, K = /^h\d$/i, J = /^[^{]+\{\s*\[native \w/, Q = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, ee = /[+~]/, te = new RegExp("\\\\[\\da-fA-F]{1,6}" + O + "?|\\\\([^\\r\\n\\f])", "g"), ne = function (e, t) { var n = "0x" + e.slice(1) - 65536; return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320)) }, re = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, oe = function (e, t) { return t ? "\0" === e ? "" : e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " " : "\\" + e }, ie = function () { p() }, se = we((function (e) { return !0 === e.disabled && "fieldset" === e.nodeName.toLowerCase() }), { dir: "parentNode", next: "legend" }); try { D.apply(R = P.call(x.childNodes), x.childNodes), R[x.childNodes.length].nodeType } catch (e) { D = { apply: R.length ? function (e, t) { N.apply(e, P.call(t)) } : function (e, t) { for (var n = e.length, r = 0; e[n++] = t[r++];); e.length = n - 1 } } } function ae(e, t, r, o) { var i, a, l, u, d, h, b, y = t && t.ownerDocument, x = t ? t.nodeType : 9; if (r = r || [], "string" != typeof e || !e || 1 !== x && 9 !== x && 11 !== x) return r; if (!o && (p(t), t = t || f, m)) { if (11 !== x && (d = Q.exec(e))) if (i = d[1]) { if (9 === x) { if (!(l = t.getElementById(i))) return r; if (l.id === i) return r.push(l), r } else if (y && (l = y.getElementById(i)) && v(t, l) && l.id === i) return r.push(l), r } else { if (d[2]) return D.apply(r, t.getElementsByTagName(e)), r; if ((i = d[3]) && n.getElementsByClassName && t.getElementsByClassName) return D.apply(r, t.getElementsByClassName(i)), r } if (n.qsa && !E[e + " "] && (!g || !g.test(e)) && (1 !== x || "object" !== t.nodeName.toLowerCase())) { if (b = e, y = t, 1 === x && (H.test(e) || B.test(e))) { for ((y = ee.test(e) && be(t.parentNode) || t) === t && n.scope || ((u = t.getAttribute("id")) ? u = u.replace(re, oe) : t.setAttribute("id", u = w)), a = (h = s(e)).length; a--;)h[a] = (u ? "#" + u : ":scope") + " " + ve(h[a]); b = h.join(",") } try { return D.apply(r, y.querySelectorAll(b)), r } catch (t) { E(e, !0) } finally { u === w && t.removeAttribute("id") } } } return c(e.replace(F, "$1"), t, r, o) } function ce() { var e = []; return function t(n, o) { return e.push(n + " ") > r.cacheLength && delete t[e.shift()], t[n + " "] = o } } function le(e) { return e[w] = !0, e } function ue(e) { var t = f.createElement("fieldset"); try { return !!e(t) } catch (e) { return !1 } finally { t.parentNode && t.parentNode.removeChild(t), t = null } } function de(e, t) { for (var n = e.split("|"), o = n.length; o--;)r.attrHandle[n[o]] = t } function pe(e, t) { var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex; if (r) return r; if (n) for (; n = n.nextSibling;)if (n === t) return -1; return e ? 1 : -1 } function fe(e) { return function (t) { return "input" === t.nodeName.toLowerCase() && t.type === e } } function he(e) { return function (t) { var n = t.nodeName.toLowerCase(); return ("input" === n || "button" === n) && t.type === e } } function me(e) { return function (t) { return "form" in t ? t.parentNode && !1 === t.disabled ? "label" in t ? "label" in t.parentNode ? t.parentNode.disabled === e : t.disabled === e : t.isDisabled === e || t.isDisabled !== !e && se(t) === e : t.disabled === e : "label" in t && t.disabled === e } } function ge(e) { return le((function (t) { return t = +t, le((function (n, r) { for (var o, i = e([], n.length, t), s = i.length; s--;)n[o = i[s]] && (n[o] = !(r[o] = n[o])) })) })) } function be(e) { return e && void 0 !== e.getElementsByTagName && e } for (t in n = ae.support = {}, i = ae.isXML = function (e) { var t = e.namespaceURI, n = (e.ownerDocument || e).documentElement; return !Y.test(t || n && n.nodeName || "HTML") }, p = ae.setDocument = function (e) { var t, o, s = e ? e.ownerDocument || e : x; return s != f && 9 === s.nodeType && s.documentElement ? (h = (f = s).documentElement, m = !i(f), x != f && (o = f.defaultView) && o.top !== o && (o.addEventListener ? o.addEventListener("unload", ie, !1) : o.attachEvent && o.attachEvent("onunload", ie)), n.scope = ue((function (e) { return h.appendChild(e).appendChild(f.createElement("div")), void 0 !== e.querySelectorAll && !e.querySelectorAll(":scope fieldset div").length })), n.attributes = ue((function (e) { return e.className = "i", !e.getAttribute("className") })), n.getElementsByTagName = ue((function (e) { return e.appendChild(f.createComment("")), !e.getElementsByTagName("*").length })), n.getElementsByClassName = J.test(f.getElementsByClassName), n.getById = ue((function (e) { return h.appendChild(e).id = w, !f.getElementsByName || !f.getElementsByName(w).length })), n.getById ? (r.filter.ID = function (e) { var t = e.replace(te, ne); return function (e) { return e.getAttribute("id") === t } }, r.find.ID = function (e, t) { if (void 0 !== t.getElementById && m) { var n = t.getElementById(e); return n ? [n] : [] } }) : (r.filter.ID = function (e) { var t = e.replace(te, ne); return function (e) { var n = void 0 !== e.getAttributeNode && e.getAttributeNode("id"); return n && n.value === t } }, r.find.ID = function (e, t) { if (void 0 !== t.getElementById && m) { var n, r, o, i = t.getElementById(e); if (i) { if ((n = i.getAttributeNode("id")) && n.value === e) return [i]; for (o = t.getElementsByName(e), r = 0; i = o[r++];)if ((n = i.getAttributeNode("id")) && n.value === e) return [i] } return [] } }), r.find.TAG = n.getElementsByTagName ? function (e, t) { return void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e) : n.qsa ? t.querySelectorAll(e) : void 0 } : function (e, t) { var n, r = [], o = 0, i = t.getElementsByTagName(e); if ("*" === e) { for (; n = i[o++];)1 === n.nodeType && r.push(n); return r } return i }, r.find.CLASS = n.getElementsByClassName && function (e, t) { if (void 0 !== t.getElementsByClassName && m) return t.getElementsByClassName(e) }, b = [], g = [], (n.qsa = J.test(f.querySelectorAll)) && (ue((function (e) { var t; h.appendChild(e).innerHTML = "<a id='" + w + "'></a><select id='" + w + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && g.push("[*^$]=" + O + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || g.push("\\[" + O + "*(?:value|" + I + ")"), e.querySelectorAll("[id~=" + w + "-]").length || g.push("~="), (t = f.createElement("input")).setAttribute("name", ""), e.appendChild(t), e.querySelectorAll("[name='']").length || g.push("\\[" + O + "*name" + O + "*=" + O + "*(?:''|\"\")"), e.querySelectorAll(":checked").length || g.push(":checked"), e.querySelectorAll("a#" + w + "+*").length || g.push(".#.+[+~]"), e.querySelectorAll("\\\f"), g.push("[\\r\\n\\f]") })), ue((function (e) { e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>"; var t = f.createElement("input"); t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && g.push("name" + O + "*[*^$|!~]?="), 2 !== e.querySelectorAll(":enabled").length && g.push(":enabled", ":disabled"), h.appendChild(e).disabled = !0, 2 !== e.querySelectorAll(":disabled").length && g.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), g.push(",.*:") }))), (n.matchesSelector = J.test(y = h.matches || h.webkitMatchesSelector || h.mozMatchesSelector || h.oMatchesSelector || h.msMatchesSelector)) && ue((function (e) { n.disconnectedMatch = y.call(e, "*"), y.call(e, "[s!='']:x"), b.push("!=", M) })), g = g.length && new RegExp(g.join("|")), b = b.length && new RegExp(b.join("|")), t = J.test(h.compareDocumentPosition), v = t || J.test(h.contains) ? function (e, t) { var n = 9 === e.nodeType ? e.documentElement : e, r = t && t.parentNode; return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r))) } : function (e, t) { if (t) for (; t = t.parentNode;)if (t === e) return !0; return !1 }, T = t ? function (e, t) { if (e === t) return d = !0, 0; var r = !e.compareDocumentPosition - !t.compareDocumentPosition; return r || (1 & (r = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || !n.sortDetached && t.compareDocumentPosition(e) === r ? e == f || e.ownerDocument == x && v(x, e) ? -1 : t == f || t.ownerDocument == x && v(x, t) ? 1 : u ? j(u, e) - j(u, t) : 0 : 4 & r ? -1 : 1) } : function (e, t) { if (e === t) return d = !0, 0; var n, r = 0, o = e.parentNode, i = t.parentNode, s = [e], a = [t]; if (!o || !i) return e == f ? -1 : t == f ? 1 : o ? -1 : i ? 1 : u ? j(u, e) - j(u, t) : 0; if (o === i) return pe(e, t); for (n = e; n = n.parentNode;)s.unshift(n); for (n = t; n = n.parentNode;)a.unshift(n); for (; s[r] === a[r];)r++; return r ? pe(s[r], a[r]) : s[r] == x ? -1 : a[r] == x ? 1 : 0 }, f) : f }, ae.matches = function (e, t) { return ae(e, null, null, t) }, ae.matchesSelector = function (e, t) { if (p(e), n.matchesSelector && m && !E[t + " "] && (!b || !b.test(t)) && (!g || !g.test(t))) try { var r = y.call(e, t); if (r || n.disconnectedMatch || e.document && 11 !== e.document.nodeType) return r } catch (e) { E(t, !0) } return ae(t, f, null, [e]).length > 0 }, ae.contains = function (e, t) { return (e.ownerDocument || e) != f && p(e), v(e, t) }, ae.attr = function (e, t) { (e.ownerDocument || e) != f && p(e); var o = r.attrHandle[t.toLowerCase()], i = o && A.call(r.attrHandle, t.toLowerCase()) ? o(e, t, !m) : void 0; return void 0 !== i ? i : n.attributes || !m ? e.getAttribute(t) : (i = e.getAttributeNode(t)) && i.specified ? i.value : null }, ae.escape = function (e) { return (e + "").replace(re, oe) }, ae.error = function (e) { throw new Error("Syntax error, unrecognized expression: " + e) }, ae.uniqueSort = function (e) { var t, r = [], o = 0, i = 0; if (d = !n.detectDuplicates, u = !n.sortStable && e.slice(0), e.sort(T), d) { for (; t = e[i++];)t === e[i] && (o = r.push(i)); for (; o--;)e.splice(r[o], 1) } return u = null, e }, o = ae.getText = function (e) { var t, n = "", r = 0, i = e.nodeType; if (i) { if (1 === i || 9 === i || 11 === i) { if ("string" == typeof e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling)n += o(e) } else if (3 === i || 4 === i) return e.nodeValue } else for (; t = e[r++];)n += o(t); return n }, (r = ae.selectors = { cacheLength: 50, createPseudo: le, match: Z, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function (e) { return e[1] = e[1].replace(te, ne), e[3] = (e[3] || e[4] || e[5] || "").replace(te, ne), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4) }, CHILD: function (e) { return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || ae.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && ae.error(e[0]), e }, PSEUDO: function (e) { var t, n = !e[6] && e[2]; return Z.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : n && G.test(n) && (t = s(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3)) } }, filter: { TAG: function (e) { var t = e.replace(te, ne).toLowerCase(); return "*" === e ? function () { return !0 } : function (e) { return e.nodeName && e.nodeName.toLowerCase() === t } }, CLASS: function (e) { var t = C[e + " "]; return t || (t = new RegExp("(^|" + O + ")" + e + "(" + O + "|$)")) && C(e, (function (e) { return t.test("string" == typeof e.className && e.className || void 0 !== e.getAttribute && e.getAttribute("class") || "") })) }, ATTR: function (e, t, n) { return function (r) { var o = ae.attr(r, e); return null == o ? "!=" === t : !t || (o += "", "=" === t ? o === n : "!=" === t ? o !== n : "^=" === t ? n && 0 === o.indexOf(n) : "*=" === t ? n && o.indexOf(n) > -1 : "$=" === t ? n && o.slice(-n.length) === n : "~=" === t ? (" " + o.replace(z, " ") + " ").indexOf(n) > -1 : "|=" === t && (o === n || o.slice(0, n.length + 1) === n + "-")) } }, CHILD: function (e, t, n, r, o) { var i = "nth" !== e.slice(0, 3), s = "last" !== e.slice(-4), a = "of-type" === t; return 1 === r && 0 === o ? function (e) { return !!e.parentNode } : function (t, n, c) { var l, u, d, p, f, h, m = i !== s ? "nextSibling" : "previousSibling", g = t.parentNode, b = a && t.nodeName.toLowerCase(), y = !c && !a, v = !1; if (g) { if (i) { for (; m;) { for (p = t; p = p[m];)if (a ? p.nodeName.toLowerCase() === b : 1 === p.nodeType) return !1; h = m = "only" === e && !h && "nextSibling" } return !0 } if (h = [s ? g.firstChild : g.lastChild], s && y) { for (v = (f = (l = (u = (d = (p = g)[w] || (p[w] = {}))[p.uniqueID] || (d[p.uniqueID] = {}))[e] || [])[0] === k && l[1]) && l[2], p = f && g.childNodes[f]; p = ++f && p && p[m] || (v = f = 0) || h.pop();)if (1 === p.nodeType && ++v && p === t) { u[e] = [k, f, v]; break } } else if (y && (v = f = (l = (u = (d = (p = t)[w] || (p[w] = {}))[p.uniqueID] || (d[p.uniqueID] = {}))[e] || [])[0] === k && l[1]), !1 === v) for (; (p = ++f && p && p[m] || (v = f = 0) || h.pop()) && ((a ? p.nodeName.toLowerCase() !== b : 1 !== p.nodeType) || !++v || (y && ((u = (d = p[w] || (p[w] = {}))[p.uniqueID] || (d[p.uniqueID] = {}))[e] = [k, v]), p !== t));); return (v -= o) === r || v % r == 0 && v / r >= 0 } } }, PSEUDO: function (e, t) { var n, o = r.pseudos[e] || r.setFilters[e.toLowerCase()] || ae.error("unsupported pseudo: " + e); return o[w] ? o(t) : o.length > 1 ? (n = [e, e, "", t], r.setFilters.hasOwnProperty(e.toLowerCase()) ? le((function (e, n) { for (var r, i = o(e, t), s = i.length; s--;)e[r = j(e, i[s])] = !(n[r] = i[s]) })) : function (e) { return o(e, 0, n) }) : o } }, pseudos: { not: le((function (e) { var t = [], n = [], r = a(e.replace(F, "$1")); return r[w] ? le((function (e, t, n, o) { for (var i, s = r(e, null, o, []), a = e.length; a--;)(i = s[a]) && (e[a] = !(t[a] = i)) })) : function (e, o, i) { return t[0] = e, r(t, null, i, n), t[0] = null, !n.pop() } })), has: le((function (e) { return function (t) { return ae(e, t).length > 0 } })), contains: le((function (e) { return e = e.replace(te, ne), function (t) { return (t.textContent || o(t)).indexOf(e) > -1 } })), lang: le((function (e) { return V.test(e || "") || ae.error("unsupported lang: " + e), e = e.replace(te, ne).toLowerCase(), function (t) { var n; do { if (n = m ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return (n = n.toLowerCase()) === e || 0 === n.indexOf(e + "-") } while ((t = t.parentNode) && 1 === t.nodeType); return !1 } })), target: function (t) { var n = e.location && e.location.hash; return n && n.slice(1) === t.id }, root: function (e) { return e === h }, focus: function (e) { return e === f.activeElement && (!f.hasFocus || f.hasFocus()) && !!(e.type || e.href || ~e.tabIndex) }, enabled: me(!1), disabled: me(!0), checked: function (e) { var t = e.nodeName.toLowerCase(); return "input" === t && !!e.checked || "option" === t && !!e.selected }, selected: function (e) { return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected }, empty: function (e) { for (e = e.firstChild; e; e = e.nextSibling)if (e.nodeType < 6) return !1; return !0 }, parent: function (e) { return !r.pseudos.empty(e) }, header: function (e) { return K.test(e.nodeName) }, input: function (e) { return X.test(e.nodeName) }, button: function (e) { var t = e.nodeName.toLowerCase(); return "input" === t && "button" === e.type || "button" === t }, text: function (e) { var t; return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase()) }, first: ge((function () { return [0] })), last: ge((function (e, t) { return [t - 1] })), eq: ge((function (e, t, n) { return [n < 0 ? n + t : n] })), even: ge((function (e, t) { for (var n = 0; n < t; n += 2)e.push(n); return e })), odd: ge((function (e, t) { for (var n = 1; n < t; n += 2)e.push(n); return e })), lt: ge((function (e, t, n) { for (var r = n < 0 ? n + t : n > t ? t : n; --r >= 0;)e.push(r); return e })), gt: ge((function (e, t, n) { for (var r = n < 0 ? n + t : n; ++r < t;)e.push(r); return e })) } }).pseudos.nth = r.pseudos.eq, { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) r.pseudos[t] = fe(t); for (t in { submit: !0, reset: !0 }) r.pseudos[t] = he(t); function ye() { } function ve(e) { for (var t = 0, n = e.length, r = ""; t < n; t++)r += e[t].value; return r } function we(e, t, n) { var r = t.dir, o = t.next, i = o || r, s = n && "parentNode" === i, a = $++; return t.first ? function (t, n, o) { for (; t = t[r];)if (1 === t.nodeType || s) return e(t, n, o); return !1 } : function (t, n, c) { var l, u, d, p = [k, a]; if (c) { for (; t = t[r];)if ((1 === t.nodeType || s) && e(t, n, c)) return !0 } else for (; t = t[r];)if (1 === t.nodeType || s) if (u = (d = t[w] || (t[w] = {}))[t.uniqueID] || (d[t.uniqueID] = {}), o && o === t.nodeName.toLowerCase()) t = t[r] || t; else { if ((l = u[i]) && l[0] === k && l[1] === a) return p[2] = l[2]; if (u[i] = p, p[2] = e(t, n, c)) return !0 } return !1 } } function xe(e) { return e.length > 1 ? function (t, n, r) { for (var o = e.length; o--;)if (!e[o](t, n, r)) return !1; return !0 } : e[0] } function ke(e, t, n, r, o) { for (var i, s = [], a = 0, c = e.length, l = null != t; a < c; a++)(i = e[a]) && (n && !n(i, r, o) || (s.push(i), l && t.push(a))); return s } function $e(e, t, n, r, o, i) { return r && !r[w] && (r = $e(r)), o && !o[w] && (o = $e(o, i)), le((function (i, s, a, c) { var l, u, d, p = [], f = [], h = s.length, m = i || function (e, t, n) { for (var r = 0, o = t.length; r < o; r++)ae(e, t[r], n); return n }(t || "*", a.nodeType ? [a] : a, []), g = !e || !i && t ? m : ke(m, p, e, a, c), b = n ? o || (i ? e : h || r) ? [] : s : g; if (n && n(g, b, a, c), r) for (l = ke(b, f), r(l, [], a, c), u = l.length; u--;)(d = l[u]) && (b[f[u]] = !(g[f[u]] = d)); if (i) { if (o || e) { if (o) { for (l = [], u = b.length; u--;)(d = b[u]) && l.push(g[u] = d); o(null, b = [], l, c) } for (u = b.length; u--;)(d = b[u]) && (l = o ? j(i, d) : p[u]) > -1 && (i[l] = !(s[l] = d)) } } else b = ke(b === s ? b.splice(h, b.length) : b), o ? o(null, s, b, c) : D.apply(s, b) })) } function Ce(e) { for (var t, n, o, i = e.length, s = r.relative[e[0].type], a = s || r.relative[" "], c = s ? 1 : 0, u = we((function (e) { return e === t }), a, !0), d = we((function (e) { return j(t, e) > -1 }), a, !0), p = [function (e, n, r) { var o = !s && (r || n !== l) || ((t = n).nodeType ? u(e, n, r) : d(e, n, r)); return t = null, o }]; c < i; c++)if (n = r.relative[e[c].type]) p = [we(xe(p), n)]; else { if ((n = r.filter[e[c].type].apply(null, e[c].matches))[w]) { for (o = ++c; o < i && !r.relative[e[o].type]; o++); return $e(c > 1 && xe(p), c > 1 && ve(e.slice(0, c - 1).concat({ value: " " === e[c - 2].type ? "*" : "" })).replace(F, "$1"), n, c < o && Ce(e.slice(c, o)), o < i && Ce(e = e.slice(o)), o < i && ve(e)) } p.push(n) } return xe(p) } return ye.prototype = r.filters = r.pseudos, r.setFilters = new ye, s = ae.tokenize = function (e, t) { var n, o, i, s, a, c, l, u = S[e + " "]; if (u) return t ? 0 : u.slice(0); for (a = e, c = [], l = r.preFilter; a;) { for (s in n && !(o = U.exec(a)) || (o && (a = a.slice(o[0].length) || a), c.push(i = [])), n = !1, (o = B.exec(a)) && (n = o.shift(), i.push({ value: n, type: o[0].replace(F, " ") }), a = a.slice(n.length)), r.filter) !(o = Z[s].exec(a)) || l[s] && !(o = l[s](o)) || (n = o.shift(), i.push({ value: n, type: s, matches: o }), a = a.slice(n.length)); if (!n) break } return t ? a.length : a ? ae.error(e) : S(e, c).slice(0) }, a = ae.compile = function (e, t) { var n, o = [], i = [], a = _[e + " "]; if (!a) { for (t || (t = s(e)), n = t.length; n--;)(a = Ce(t[n]))[w] ? o.push(a) : i.push(a); (a = _(e, function (e, t) { var n = t.length > 0, o = e.length > 0, i = function (i, s, a, c, u) { var d, h, g, b = 0, y = "0", v = i && [], w = [], x = l, $ = i || o && r.find.TAG("*", u), C = k += null == x ? 1 : Math.random() || .1, S = $.length; for (u && (l = s == f || s || u); y !== S && null != (d = $[y]); y++) { if (o && d) { for (h = 0, s || d.ownerDocument == f || (p(d), a = !m); g = e[h++];)if (g(d, s || f, a)) { c.push(d); break } u && (k = C) } n && ((d = !g && d) && b--, i && v.push(d)) } if (b += y, n && y !== b) { for (h = 0; g = t[h++];)g(v, w, s, a); if (i) { if (b > 0) for (; y--;)v[y] || w[y] || (w[y] = L.call(c)); w = ke(w) } D.apply(c, w), u && !i && w.length > 0 && b + t.length > 1 && ae.uniqueSort(c) } return u && (k = C, l = x), v }; return n ? le(i) : i }(i, o))).selector = e } return a }, c = ae.select = function (e, t, n, o) { var i, c, l, u, d, p = "function" == typeof e && e, f = !o && s(e = p.selector || e); if (n = n || [], 1 === f.length) { if ((c = f[0] = f[0].slice(0)).length > 2 && "ID" === (l = c[0]).type && 9 === t.nodeType && m && r.relative[c[1].type]) { if (!(t = (r.find.ID(l.matches[0].replace(te, ne), t) || [])[0])) return n; p && (t = t.parentNode), e = e.slice(c.shift().value.length) } for (i = Z.needsContext.test(e) ? 0 : c.length; i-- && (l = c[i], !r.relative[u = l.type]);)if ((d = r.find[u]) && (o = d(l.matches[0].replace(te, ne), ee.test(c[0].type) && be(t.parentNode) || t))) { if (c.splice(i, 1), !(e = o.length && ve(c))) return D.apply(n, o), n; break } } return (p || a(e, f))(o, t, !m, n, !t || ee.test(e) && be(t.parentNode) || t), n }, n.sortStable = w.split("").sort(T).join("") === w, n.detectDuplicates = !!d, p(), n.sortDetached = ue((function (e) { return 1 & e.compareDocumentPosition(f.createElement("fieldset")) })), ue((function (e) { return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href") })) || de("type|href|height|width", (function (e, t, n) { if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2) })), n.attributes && ue((function (e) { return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value") })) || de("value", (function (e, t, n) { if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue })), ue((function (e) { return null == e.getAttribute("disabled") })) || de(I, (function (e, t, n) { var r; if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null })), ae }(e); w.find = k, w.expr = k.selectors, w.expr[":"] = w.expr.pseudos, w.uniqueSort = w.unique = k.uniqueSort, w.text = k.getText, w.isXMLDoc = k.isXML, w.contains = k.contains, w.escapeSelector = k.escape; var $ = function (e, t, n) { for (var r = [], o = void 0 !== n; (e = e[t]) && 9 !== e.nodeType;)if (1 === e.nodeType) { if (o && w(e).is(n)) break; r.push(e) } return r }, C = function (e, t) { for (var n = []; e; e = e.nextSibling)1 === e.nodeType && e !== t && n.push(e); return n }, S = w.expr.match.needsContext; function _(e, t) { return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase() } var E = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; function T(e, t, n) { return h(t) ? w.grep(e, (function (e, r) { return !!t.call(e, r, e) !== n })) : t.nodeType ? w.grep(e, (function (e) { return e === t !== n })) : "string" != typeof t ? w.grep(e, (function (e) { return a.call(t, e) > -1 !== n })) : w.filter(t, e, n) } w.filter = function (e, t, n) { var r = t[0]; return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? w.find.matchesSelector(r, e) ? [r] : [] : w.find.matches(e, w.grep(t, (function (e) { return 1 === e.nodeType }))) }, w.fn.extend({ find: function (e) { var t, n, r = this.length, o = this; if ("string" != typeof e) return this.pushStack(w(e).filter((function () { for (t = 0; t < r; t++)if (w.contains(o[t], this)) return !0 }))); for (n = this.pushStack([]), t = 0; t < r; t++)w.find(e, o[t], n); return r > 1 ? w.uniqueSort(n) : n }, filter: function (e) { return this.pushStack(T(this, e || [], !1)) }, not: function (e) { return this.pushStack(T(this, e || [], !0)) }, is: function (e) { return !!T(this, "string" == typeof e && S.test(e) ? w(e) : e || [], !1).length } }); var A, R = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/; (w.fn.init = function (e, t, n) { var r, o; if (!e) return this; if (n = n || A, "string" == typeof e) { if (!(r = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : R.exec(e)) || !r[1] && t) return !t || t.jquery ? (t || n).find(e) : this.constructor(t).find(e); if (r[1]) { if (t = t instanceof w ? t[0] : t, w.merge(this, w.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : g, !0)), E.test(r[1]) && w.isPlainObject(t)) for (r in t) h(this[r]) ? this[r](t[r]) : this.attr(r, t[r]); return this } return (o = g.getElementById(r[2])) && (this[0] = o, this.length = 1), this } return e.nodeType ? (this[0] = e, this.length = 1, this) : h(e) ? void 0 !== n.ready ? n.ready(e) : e(w) : w.makeArray(e, this) }).prototype = w.fn, A = w(g); var L = /^(?:parents|prev(?:Until|All))/, N = { children: !0, contents: !0, next: !0, prev: !0 }; function D(e, t) { for (; (e = e[t]) && 1 !== e.nodeType;); return e } w.fn.extend({ has: function (e) { var t = w(e, this), n = t.length; return this.filter((function () { for (var e = 0; e < n; e++)if (w.contains(this, t[e])) return !0 })) }, closest: function (e, t) { var n, r = 0, o = this.length, i = [], s = "string" != typeof e && w(e); if (!S.test(e)) for (; r < o; r++)for (n = this[r]; n && n !== t; n = n.parentNode)if (n.nodeType < 11 && (s ? s.index(n) > -1 : 1 === n.nodeType && w.find.matchesSelector(n, e))) { i.push(n); break } return this.pushStack(i.length > 1 ? w.uniqueSort(i) : i) }, index: function (e) { return e ? "string" == typeof e ? a.call(w(e), this[0]) : a.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1 }, add: function (e, t) { return this.pushStack(w.uniqueSort(w.merge(this.get(), w(e, t)))) }, addBack: function (e) { return this.add(null == e ? this.prevObject : this.prevObject.filter(e)) } }), w.each({ parent: function (e) { var t = e.parentNode; return t && 11 !== t.nodeType ? t : null }, parents: function (e) { return $(e, "parentNode") }, parentsUntil: function (e, t, n) { return $(e, "parentNode", n) }, next: function (e) { return D(e, "nextSibling") }, prev: function (e) { return D(e, "previousSibling") }, nextAll: function (e) { return $(e, "nextSibling") }, prevAll: function (e) { return $(e, "previousSibling") }, nextUntil: function (e, t, n) { return $(e, "nextSibling", n) }, prevUntil: function (e, t, n) { return $(e, "previousSibling", n) }, siblings: function (e) { return C((e.parentNode || {}).firstChild, e) }, children: function (e) { return C(e.firstChild) }, contents: function (e) { return null != e.contentDocument && r(e.contentDocument) ? e.contentDocument : (_(e, "template") && (e = e.content || e), w.merge([], e.childNodes)) } }, (function (e, t) { w.fn[e] = function (n, r) { var o = w.map(this, t, n); return "Until" !== e.slice(-5) && (r = n), r && "string" == typeof r && (o = w.filter(r, o)), this.length > 1 && (N[e] || w.uniqueSort(o), L.test(e) && o.reverse()), this.pushStack(o) } })); var P = /[^\x20\t\r\n\f]+/g; function j(e) { return e } function I(e) { throw e } function O(e, t, n, r) { var o; try { e && h(o = e.promise) ? o.call(e).done(t).fail(n) : e && h(o = e.then) ? o.call(e, t, n) : t.apply(void 0, [e].slice(r)) } catch (e) { n.apply(void 0, [e]) } } w.Callbacks = function (e) { e = "string" == typeof e ? function (e) { var t = {}; return w.each(e.match(P) || [], (function (e, n) { t[n] = !0 })), t }(e) : w.extend({}, e); var t, n, r, o, i = [], s = [], a = -1, c = function () { for (o = o || e.once, r = t = !0; s.length; a = -1)for (n = s.shift(); ++a < i.length;)!1 === i[a].apply(n[0], n[1]) && e.stopOnFalse && (a = i.length, n = !1); e.memory || (n = !1), t = !1, o && (i = n ? [] : "") }, l = { add: function () { return i && (n && !t && (a = i.length - 1, s.push(n)), function t(n) { w.each(n, (function (n, r) { h(r) ? e.unique && l.has(r) || i.push(r) : r && r.length && "string" !== v(r) && t(r) })) }(arguments), n && !t && c()), this }, remove: function () { return w.each(arguments, (function (e, t) { for (var n; (n = w.inArray(t, i, n)) > -1;)i.splice(n, 1), n <= a && a-- })), this }, has: function (e) { return e ? w.inArray(e, i) > -1 : i.length > 0 }, empty: function () { return i && (i = []), this }, disable: function () { return o = s = [], i = n = "", this }, disabled: function () { return !i }, lock: function () { return o = s = [], n || t || (i = n = ""), this }, locked: function () { return !!o }, fireWith: function (e, n) { return o || (n = [e, (n = n || []).slice ? n.slice() : n], s.push(n), t || c()), this }, fire: function () { return l.fireWith(this, arguments), this }, fired: function () { return !!r } }; return l }, w.extend({ Deferred: function (t) { var n = [["notify", "progress", w.Callbacks("memory"), w.Callbacks("memory"), 2], ["resolve", "done", w.Callbacks("once memory"), w.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", w.Callbacks("once memory"), w.Callbacks("once memory"), 1, "rejected"]], r = "pending", o = { state: function () { return r }, always: function () { return i.done(arguments).fail(arguments), this }, catch: function (e) { return o.then(null, e) }, pipe: function () { var e = arguments; return w.Deferred((function (t) { w.each(n, (function (n, r) { var o = h(e[r[4]]) && e[r[4]]; i[r[1]]((function () { var e = o && o.apply(this, arguments); e && h(e.promise) ? e.promise().progress(t.notify).done(t.resolve).fail(t.reject) : t[r[0] + "With"](this, o ? [e] : arguments) })) })), e = null })).promise() }, then: function (t, r, o) { var i = 0; function s(t, n, r, o) { return function () { var a = this, c = arguments, l = function () { var e, l; if (!(t < i)) { if ((e = r.apply(a, c)) === n.promise()) throw new TypeError("Thenable self-resolution"); l = e && ("object" == typeof e || "function" == typeof e) && e.then, h(l) ? o ? l.call(e, s(i, n, j, o), s(i, n, I, o)) : (i++, l.call(e, s(i, n, j, o), s(i, n, I, o), s(i, n, j, n.notifyWith))) : (r !== j && (a = void 0, c = [e]), (o || n.resolveWith)(a, c)) } }, u = o ? l : function () { try { l() } catch (e) { w.Deferred.exceptionHook && w.Deferred.exceptionHook(e, u.stackTrace), t + 1 >= i && (r !== I && (a = void 0, c = [e]), n.rejectWith(a, c)) } }; t ? u() : (w.Deferred.getStackHook && (u.stackTrace = w.Deferred.getStackHook()), e.setTimeout(u)) } } return w.Deferred((function (e) { n[0][3].add(s(0, e, h(o) ? o : j, e.notifyWith)), n[1][3].add(s(0, e, h(t) ? t : j)), n[2][3].add(s(0, e, h(r) ? r : I)) })).promise() }, promise: function (e) { return null != e ? w.extend(e, o) : o } }, i = {}; return w.each(n, (function (e, t) { var s = t[2], a = t[5]; o[t[1]] = s.add, a && s.add((function () { r = a }), n[3 - e][2].disable, n[3 - e][3].disable, n[0][2].lock, n[0][3].lock), s.add(t[3].fire), i[t[0]] = function () { return i[t[0] + "With"](this === i ? void 0 : this, arguments), this }, i[t[0] + "With"] = s.fireWith })), o.promise(i), t && t.call(i, i), i }, when: function (e) { var t = arguments.length, n = t, r = Array(n), i = o.call(arguments), s = w.Deferred(), a = function (e) { return function (n) { r[e] = this, i[e] = arguments.length > 1 ? o.call(arguments) : n, --t || s.resolveWith(r, i) } }; if (t <= 1 && (O(e, s.done(a(n)).resolve, s.reject, !t), "pending" === s.state() || h(i[n] && i[n].then))) return s.then(); for (; n--;)O(i[n], a(n), s.reject); return s.promise() } }); var q = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/; w.Deferred.exceptionHook = function (t, n) { e.console && e.console.warn && t && q.test(t.name) && e.console.warn("jQuery.Deferred exception: " + t.message, t.stack, n) }, w.readyException = function (t) { e.setTimeout((function () { throw t })) }; var W = w.Deferred(); function M() { g.removeEventListener("DOMContentLoaded", M), e.removeEventListener("load", M), w.ready() } w.fn.ready = function (e) { return W.then(e).catch((function (e) { w.readyException(e) })), this }, w.extend({ isReady: !1, readyWait: 1, ready: function (e) { (!0 === e ? --w.readyWait : w.isReady) || (w.isReady = !0, !0 !== e && --w.readyWait > 0 || W.resolveWith(g, [w])) } }), w.ready.then = W.then, "complete" === g.readyState || "loading" !== g.readyState && !g.documentElement.doScroll ? e.setTimeout(w.ready) : (g.addEventListener("DOMContentLoaded", M), e.addEventListener("load", M)); var z = function (e, t, n, r, o, i, s) { var a = 0, c = e.length, l = null == n; if ("object" === v(n)) for (a in o = !0, n) z(e, t, a, n[a], !0, i, s); else if (void 0 !== r && (o = !0, h(r) || (s = !0), l && (s ? (t.call(e, r), t = null) : (l = t, t = function (e, t, n) { return l.call(w(e), n) })), t)) for (; a < c; a++)t(e[a], n, s ? r : r.call(e[a], a, t(e[a], n))); return o ? e : l ? t.call(e) : c ? t(e[0], n) : i }, F = /^-ms-/, U = /-([a-z])/g; function B(e, t) { return t.toUpperCase() } function H(e) { return e.replace(F, "ms-").replace(U, B) } var G = function (e) { return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType }; function V() { this.expando = w.expando + V.uid++ } V.uid = 1, V.prototype = { cache: function (e) { var t = e[this.expando]; return t || (t = {}, G(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, { value: t, configurable: !0 }))), t }, set: function (e, t, n) { var r, o = this.cache(e); if ("string" == typeof t) o[H(t)] = n; else for (r in t) o[H(r)] = t[r]; return o }, get: function (e, t) { return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][H(t)] }, access: function (e, t, n) { return void 0 === t || t && "string" == typeof t && void 0 === n ? this.get(e, t) : (this.set(e, t, n), void 0 !== n ? n : t) }, remove: function (e, t) { var n, r = e[this.expando]; if (void 0 !== r) { if (void 0 !== t) { n = (t = Array.isArray(t) ? t.map(H) : (t = H(t)) in r ? [t] : t.match(P) || []).length; for (; n--;)delete r[t[n]] } (void 0 === t || w.isEmptyObject(r)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando]) } }, hasData: function (e) { var t = e[this.expando]; return void 0 !== t && !w.isEmptyObject(t) } }; var Z = new V, Y = new V, X = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, K = /[A-Z]/g; function J(e, t, n) { var r; if (void 0 === n && 1 === e.nodeType) if (r = "data-" + t.replace(K, "-$&").toLowerCase(), "string" == typeof (n = e.getAttribute(r))) { try { n = function (e) { return "true" === e || "false" !== e && ("null" === e ? null : e === +e + "" ? +e : X.test(e) ? JSON.parse(e) : e) }(n) } catch (e) { } Y.set(e, t, n) } else n = void 0; return n } w.extend({ hasData: function (e) { return Y.hasData(e) || Z.hasData(e) }, data: function (e, t, n) { return Y.access(e, t, n) }, removeData: function (e, t) { Y.remove(e, t) }, _data: function (e, t, n) { return Z.access(e, t, n) }, _removeData: function (e, t) { Z.remove(e, t) } }), w.fn.extend({ data: function (e, t) { var n, r, o, i = this[0], s = i && i.attributes; if (void 0 === e) { if (this.length && (o = Y.get(i), 1 === i.nodeType && !Z.get(i, "hasDataAttrs"))) { for (n = s.length; n--;)s[n] && 0 === (r = s[n].name).indexOf("data-") && (r = H(r.slice(5)), J(i, r, o[r])); Z.set(i, "hasDataAttrs", !0) } return o } return "object" == typeof e ? this.each((function () { Y.set(this, e) })) : z(this, (function (t) { var n; if (i && void 0 === t) return void 0 !== (n = Y.get(i, e)) || void 0 !== (n = J(i, e)) ? n : void 0; this.each((function () { Y.set(this, e, t) })) }), null, t, arguments.length > 1, null, !0) }, removeData: function (e) { return this.each((function () { Y.remove(this, e) })) } }), w.extend({ queue: function (e, t, n) { var r; if (e) return t = (t || "fx") + "queue", r = Z.get(e, t), n && (!r || Array.isArray(n) ? r = Z.access(e, t, w.makeArray(n)) : r.push(n)), r || [] }, dequeue: function (e, t) { t = t || "fx"; var n = w.queue(e, t), r = n.length, o = n.shift(), i = w._queueHooks(e, t); "inprogress" === o && (o = n.shift(), r--), o && ("fx" === t && n.unshift("inprogress"), delete i.stop, o.call(e, (function () { w.dequeue(e, t) }), i)), !r && i && i.empty.fire() }, _queueHooks: function (e, t) { var n = t + "queueHooks"; return Z.get(e, n) || Z.access(e, n, { empty: w.Callbacks("once memory").add((function () { Z.remove(e, [t + "queue", n]) })) }) } }), w.fn.extend({ queue: function (e, t) { var n = 2; return "string" != typeof e && (t = e, e = "fx", n--), arguments.length < n ? w.queue(this[0], e) : void 0 === t ? this : this.each((function () { var n = w.queue(this, e, t); w._queueHooks(this, e), "fx" === e && "inprogress" !== n[0] && w.dequeue(this, e) })) }, dequeue: function (e) { return this.each((function () { w.dequeue(this, e) })) }, clearQueue: function (e) { return this.queue(e || "fx", []) }, promise: function (e, t) { var n, r = 1, o = w.Deferred(), i = this, s = this.length, a = function () { --r || o.resolveWith(i, [i]) }; for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; s--;)(n = Z.get(i[s], e + "queueHooks")) && n.empty && (r++, n.empty.add(a)); return a(), o.promise(t) } }); var Q = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, ee = new RegExp("^(?:([+-])=|)(" + Q + ")([a-z%]*)$", "i"), te = ["Top", "Right", "Bottom", "Left"], ne = g.documentElement, re = function (e) { return w.contains(e.ownerDocument, e) }, oe = { composed: !0 }; ne.getRootNode && (re = function (e) { return w.contains(e.ownerDocument, e) || e.getRootNode(oe) === e.ownerDocument }); var ie = function (e, t) { return "none" === (e = t || e).style.display || "" === e.style.display && re(e) && "none" === w.css(e, "display") }; function se(e, t, n, r) { var o, i, s = 20, a = r ? function () { return r.cur() } : function () { return w.css(e, t, "") }, c = a(), l = n && n[3] || (w.cssNumber[t] ? "" : "px"), u = e.nodeType && (w.cssNumber[t] || "px" !== l && +c) && ee.exec(w.css(e, t)); if (u && u[3] !== l) { for (c /= 2, l = l || u[3], u = +c || 1; s--;)w.style(e, t, u + l), (1 - i) * (1 - (i = a() / c || .5)) <= 0 && (s = 0), u /= i; u *= 2, w.style(e, t, u + l), n = n || [] } return n && (u = +u || +c || 0, o = n[1] ? u + (n[1] + 1) * n[2] : +n[2], r && (r.unit = l, r.start = u, r.end = o)), o } var ae = {}; function ce(e) { var t, n = e.ownerDocument, r = e.nodeName, o = ae[r]; return o || (t = n.body.appendChild(n.createElement(r)), o = w.css(t, "display"), t.parentNode.removeChild(t), "none" === o && (o = "block"), ae[r] = o, o) } function le(e, t) { for (var n, r, o = [], i = 0, s = e.length; i < s; i++)(r = e[i]).style && (n = r.style.display, t ? ("none" === n && (o[i] = Z.get(r, "display") || null, o[i] || (r.style.display = "")), "" === r.style.display && ie(r) && (o[i] = ce(r))) : "none" !== n && (o[i] = "none", Z.set(r, "display", n))); for (i = 0; i < s; i++)null != o[i] && (e[i].style.display = o[i]); return e } w.fn.extend({ show: function () { return le(this, !0) }, hide: function () { return le(this) }, toggle: function (e) { return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each((function () { ie(this) ? w(this).show() : w(this).hide() })) } }); var ue = /^(?:checkbox|radio)$/i, de = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, pe = /^$|^module$|\/(?:java|ecma)script/i; !function () { var e = g.createDocumentFragment().appendChild(g.createElement("div")), t = g.createElement("input"); t.setAttribute("type", "radio"), t.setAttribute("checked", "checked"), t.setAttribute("name", "t"), e.appendChild(t), f.checkClone = e.cloneNode(!0).cloneNode(!0).lastChild.checked, e.innerHTML = "<textarea>x</textarea>", f.noCloneChecked = !!e.cloneNode(!0).lastChild.defaultValue, e.innerHTML = "<option></option>", f.option = !!e.lastChild }(); var fe = { thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] }; function he(e, t) { var n; return n = void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t || "*") : void 0 !== e.querySelectorAll ? e.querySelectorAll(t || "*") : [], void 0 === t || t && _(e, t) ? w.merge([e], n) : n } function me(e, t) { for (var n = 0, r = e.length; n < r; n++)Z.set(e[n], "globalEval", !t || Z.get(t[n], "globalEval")) } fe.tbody = fe.tfoot = fe.colgroup = fe.caption = fe.thead, fe.th = fe.td, f.option || (fe.optgroup = fe.option = [1, "<select multiple='multiple'>", "</select>"]); var ge = /<|&#?\w+;/; function be(e, t, n, r, o) { for (var i, s, a, c, l, u, d = t.createDocumentFragment(), p = [], f = 0, h = e.length; f < h; f++)if ((i = e[f]) || 0 === i) if ("object" === v(i)) w.merge(p, i.nodeType ? [i] : i); else if (ge.test(i)) { for (s = s || d.appendChild(t.createElement("div")), a = (de.exec(i) || ["", ""])[1].toLowerCase(), c = fe[a] || fe._default, s.innerHTML = c[1] + w.htmlPrefilter(i) + c[2], u = c[0]; u--;)s = s.lastChild; w.merge(p, s.childNodes), (s = d.firstChild).textContent = "" } else p.push(t.createTextNode(i)); for (d.textContent = "", f = 0; i = p[f++];)if (r && w.inArray(i, r) > -1) o && o.push(i); else if (l = re(i), s = he(d.appendChild(i), "script"), l && me(s), n) for (u = 0; i = s[u++];)pe.test(i.type || "") && n.push(i); return d } var ye = /^key/, ve = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, we = /^([^.]*)(?:\.(.+)|)/; function xe() { return !0 } function ke() { return !1 } function $e(e, t) { return e === function () { try { return g.activeElement } catch (e) { } }() == ("focus" === t) } function Ce(e, t, n, r, o, i) { var s, a; if ("object" == typeof t) { for (a in "string" != typeof n && (r = r || n, n = void 0), t) Ce(e, a, n, r, t[a], i); return e } if (null == r && null == o ? (o = n, r = n = void 0) : null == o && ("string" == typeof n ? (o = r, r = void 0) : (o = r, r = n, n = void 0)), !1 === o) o = ke; else if (!o) return e; return 1 === i && (s = o, (o = function (e) { return w().off(e), s.apply(this, arguments) }).guid = s.guid || (s.guid = w.guid++)), e.each((function () { w.event.add(this, t, o, r, n) })) } function Se(e, t, n) { n ? (Z.set(e, t, !1), w.event.add(e, t, { namespace: !1, handler: function (e) { var r, i, s = Z.get(this, t); if (1 & e.isTrigger && this[t]) { if (s.length) (w.event.special[t] || {}).delegateType && e.stopPropagation(); else if (s = o.call(arguments), Z.set(this, t, s), r = n(this, t), this[t](), s !== (i = Z.get(this, t)) || r ? Z.set(this, t, !1) : i = {}, s !== i) return e.stopImmediatePropagation(), e.preventDefault(), i.value } else s.length && (Z.set(this, t, { value: w.event.trigger(w.extend(s[0], w.Event.prototype), s.slice(1), this) }), e.stopImmediatePropagation()) } })) : void 0 === Z.get(e, t) && w.event.add(e, t, xe) } w.event = { global: {}, add: function (e, t, n, r, o) { var i, s, a, c, l, u, d, p, f, h, m, g = Z.get(e); if (G(e)) for (n.handler && (n = (i = n).handler, o = i.selector), o && w.find.matchesSelector(ne, o), n.guid || (n.guid = w.guid++), (c = g.events) || (c = g.events = Object.create(null)), (s = g.handle) || (s = g.handle = function (t) { return void 0 !== w && w.event.triggered !== t.type ? w.event.dispatch.apply(e, arguments) : void 0 }), l = (t = (t || "").match(P) || [""]).length; l--;)f = m = (a = we.exec(t[l]) || [])[1], h = (a[2] || "").split(".").sort(), f && (d = w.event.special[f] || {}, f = (o ? d.delegateType : d.bindType) || f, d = w.event.special[f] || {}, u = w.extend({ type: f, origType: m, data: r, handler: n, guid: n.guid, selector: o, needsContext: o && w.expr.match.needsContext.test(o), namespace: h.join(".") }, i), (p = c[f]) || ((p = c[f] = []).delegateCount = 0, d.setup && !1 !== d.setup.call(e, r, h, s) || e.addEventListener && e.addEventListener(f, s)), d.add && (d.add.call(e, u), u.handler.guid || (u.handler.guid = n.guid)), o ? p.splice(p.delegateCount++, 0, u) : p.push(u), w.event.global[f] = !0) }, remove: function (e, t, n, r, o) { var i, s, a, c, l, u, d, p, f, h, m, g = Z.hasData(e) && Z.get(e); if (g && (c = g.events)) { for (l = (t = (t || "").match(P) || [""]).length; l--;)if (f = m = (a = we.exec(t[l]) || [])[1], h = (a[2] || "").split(".").sort(), f) { for (d = w.event.special[f] || {}, p = c[f = (r ? d.delegateType : d.bindType) || f] || [], a = a[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), s = i = p.length; i--;)u = p[i], !o && m !== u.origType || n && n.guid !== u.guid || a && !a.test(u.namespace) || r && r !== u.selector && ("**" !== r || !u.selector) || (p.splice(i, 1), u.selector && p.delegateCount--, d.remove && d.remove.call(e, u)); s && !p.length && (d.teardown && !1 !== d.teardown.call(e, h, g.handle) || w.removeEvent(e, f, g.handle), delete c[f]) } else for (f in c) w.event.remove(e, f + t[l], n, r, !0); w.isEmptyObject(c) && Z.remove(e, "handle events") } }, dispatch: function (e) { var t, n, r, o, i, s, a = new Array(arguments.length), c = w.event.fix(e), l = (Z.get(this, "events") || Object.create(null))[c.type] || [], u = w.event.special[c.type] || {}; for (a[0] = c, t = 1; t < arguments.length; t++)a[t] = arguments[t]; if (c.delegateTarget = this, !u.preDispatch || !1 !== u.preDispatch.call(this, c)) { for (s = w.event.handlers.call(this, c, l), t = 0; (o = s[t++]) && !c.isPropagationStopped();)for (c.currentTarget = o.elem, n = 0; (i = o.handlers[n++]) && !c.isImmediatePropagationStopped();)c.rnamespace && !1 !== i.namespace && !c.rnamespace.test(i.namespace) || (c.handleObj = i, c.data = i.data, void 0 !== (r = ((w.event.special[i.origType] || {}).handle || i.handler).apply(o.elem, a)) && !1 === (c.result = r) && (c.preventDefault(), c.stopPropagation())); return u.postDispatch && u.postDispatch.call(this, c), c.result } }, handlers: function (e, t) { var n, r, o, i, s, a = [], c = t.delegateCount, l = e.target; if (c && l.nodeType && !("click" === e.type && e.button >= 1)) for (; l !== this; l = l.parentNode || this)if (1 === l.nodeType && ("click" !== e.type || !0 !== l.disabled)) { for (i = [], s = {}, n = 0; n < c; n++)void 0 === s[o = (r = t[n]).selector + " "] && (s[o] = r.needsContext ? w(o, this).index(l) > -1 : w.find(o, this, null, [l]).length), s[o] && i.push(r); i.length && a.push({ elem: l, handlers: i }) } return l = this, c < t.length && a.push({ elem: l, handlers: t.slice(c) }), a }, addProp: function (e, t) { Object.defineProperty(w.Event.prototype, e, { enumerable: !0, configurable: !0, get: h(t) ? function () { if (this.originalEvent) return t(this.originalEvent) } : function () { if (this.originalEvent) return this.originalEvent[e] }, set: function (t) { Object.defineProperty(this, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) } }) }, fix: function (e) { return e[w.expando] ? e : new w.Event(e) }, special: { load: { noBubble: !0 }, click: { setup: function (e) { var t = this || e; return ue.test(t.type) && t.click && _(t, "input") && Se(t, "click", xe), !1 }, trigger: function (e) { var t = this || e; return ue.test(t.type) && t.click && _(t, "input") && Se(t, "click"), !0 }, _default: function (e) { var t = e.target; return ue.test(t.type) && t.click && _(t, "input") && Z.get(t, "click") || _(t, "a") } }, beforeunload: { postDispatch: function (e) { void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result) } } } }, w.removeEvent = function (e, t, n) { e.removeEventListener && e.removeEventListener(t, n) }, w.Event = function (e, t) { if (!(this instanceof w.Event)) return new w.Event(e, t); e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && !1 === e.returnValue ? xe : ke, this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget) : this.type = e, t && w.extend(this, t), this.timeStamp = e && e.timeStamp || Date.now(), this[w.expando] = !0 }, w.Event.prototype = { constructor: w.Event, isDefaultPrevented: ke, isPropagationStopped: ke, isImmediatePropagationStopped: ke, isSimulated: !1, preventDefault: function () { var e = this.originalEvent; this.isDefaultPrevented = xe, e && !this.isSimulated && e.preventDefault() }, stopPropagation: function () { var e = this.originalEvent; this.isPropagationStopped = xe, e && !this.isSimulated && e.stopPropagation() }, stopImmediatePropagation: function () { var e = this.originalEvent; this.isImmediatePropagationStopped = xe, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation() } }, w.each({ altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, char: !0, code: !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which: function (e) { var t = e.button; return null == e.which && ye.test(e.type) ? null != e.charCode ? e.charCode : e.keyCode : !e.which && void 0 !== t && ve.test(e.type) ? 1 & t ? 1 : 2 & t ? 3 : 4 & t ? 2 : 0 : e.which } }, w.event.addProp), w.each({ focus: "focusin", blur: "focusout" }, (function (e, t) { w.event.special[e] = { setup: function () { return Se(this, e, $e), !1 }, trigger: function () { return Se(this, e), !0 }, delegateType: t } })), w.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, (function (e, t) { w.event.special[e] = { delegateType: t, bindType: t, handle: function (e) { var n, r = this, o = e.relatedTarget, i = e.handleObj; return o && (o === r || w.contains(r, o)) || (e.type = i.origType, n = i.handler.apply(this, arguments), e.type = t), n } } })), w.fn.extend({ on: function (e, t, n, r) { return Ce(this, e, t, n, r) }, one: function (e, t, n, r) { return Ce(this, e, t, n, r, 1) }, off: function (e, t, n) { var r, o; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, w(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this; if ("object" == typeof e) { for (o in e) this.off(o, t, e[o]); return this } return !1 !== t && "function" != typeof t || (n = t, t = void 0), !1 === n && (n = ke), this.each((function () { w.event.remove(this, e, n, t) })) } }); var _e = /<script|<style|<link/i, Ee = /checked\s*(?:[^=]|=\s*.checked.)/i, Te = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; function Ae(e, t) { return _(e, "table") && _(11 !== t.nodeType ? t : t.firstChild, "tr") && w(e).children("tbody")[0] || e } function Re(e) { return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e } function Le(e) { return "true/" === (e.type || "").slice(0, 5) ? e.type = e.type.slice(5) : e.removeAttribute("type"), e } function Ne(e, t) { var n, r, o, i, s, a; if (1 === t.nodeType) { if (Z.hasData(e) && (a = Z.get(e).events)) for (o in Z.remove(t, "handle events"), a) for (n = 0, r = a[o].length; n < r; n++)w.event.add(t, o, a[o][n]); Y.hasData(e) && (i = Y.access(e), s = w.extend({}, i), Y.set(t, s)) } } function De(e, t) { var n = t.nodeName.toLowerCase(); "input" === n && ue.test(e.type) ? t.checked = e.checked : "input" !== n && "textarea" !== n || (t.defaultValue = e.defaultValue) } function Pe(e, t, n, r) { t = i(t); var o, s, a, c, l, u, d = 0, p = e.length, m = p - 1, g = t[0], b = h(g); if (b || p > 1 && "string" == typeof g && !f.checkClone && Ee.test(g)) return e.each((function (o) { var i = e.eq(o); b && (t[0] = g.call(this, o, i.html())), Pe(i, t, n, r) })); if (p && (s = (o = be(t, e[0].ownerDocument, !1, e, r)).firstChild, 1 === o.childNodes.length && (o = s), s || r)) { for (c = (a = w.map(he(o, "script"), Re)).length; d < p; d++)l = o, d !== m && (l = w.clone(l, !0, !0), c && w.merge(a, he(l, "script"))), n.call(e[d], l, d); if (c) for (u = a[a.length - 1].ownerDocument, w.map(a, Le), d = 0; d < c; d++)l = a[d], pe.test(l.type || "") && !Z.access(l, "globalEval") && w.contains(u, l) && (l.src && "module" !== (l.type || "").toLowerCase() ? w._evalUrl && !l.noModule && w._evalUrl(l.src, { nonce: l.nonce || l.getAttribute("nonce") }, u) : y(l.textContent.replace(Te, ""), l, u)) } return e } function je(e, t, n) { for (var r, o = t ? w.filter(t, e) : e, i = 0; null != (r = o[i]); i++)n || 1 !== r.nodeType || w.cleanData(he(r)), r.parentNode && (n && re(r) && me(he(r, "script")), r.parentNode.removeChild(r)); return e } w.extend({ htmlPrefilter: function (e) { return e }, clone: function (e, t, n) { var r, o, i, s, a = e.cloneNode(!0), c = re(e); if (!(f.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || w.isXMLDoc(e))) for (s = he(a), r = 0, o = (i = he(e)).length; r < o; r++)De(i[r], s[r]); if (t) if (n) for (i = i || he(e), s = s || he(a), r = 0, o = i.length; r < o; r++)Ne(i[r], s[r]); else Ne(e, a); return (s = he(a, "script")).length > 0 && me(s, !c && he(e, "script")), a }, cleanData: function (e) { for (var t, n, r, o = w.event.special, i = 0; void 0 !== (n = e[i]); i++)if (G(n)) { if (t = n[Z.expando]) { if (t.events) for (r in t.events) o[r] ? w.event.remove(n, r) : w.removeEvent(n, r, t.handle); n[Z.expando] = void 0 } n[Y.expando] && (n[Y.expando] = void 0) } } }), w.fn.extend({ detach: function (e) { return je(this, e, !0) }, remove: function (e) { return je(this, e) }, text: function (e) { return z(this, (function (e) { return void 0 === e ? w.text(this) : this.empty().each((function () { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e) })) }), null, e, arguments.length) }, append: function () { return Pe(this, arguments, (function (e) { 1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || Ae(this, e).appendChild(e) })) }, prepend: function () { return Pe(this, arguments, (function (e) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) { var t = Ae(this, e); t.insertBefore(e, t.firstChild) } })) }, before: function () { return Pe(this, arguments, (function (e) { this.parentNode && this.parentNode.insertBefore(e, this) })) }, after: function () { return Pe(this, arguments, (function (e) { this.parentNode && this.parentNode.insertBefore(e, this.nextSibling) })) }, empty: function () { for (var e, t = 0; null != (e = this[t]); t++)1 === e.nodeType && (w.cleanData(he(e, !1)), e.textContent = ""); return this }, clone: function (e, t) { return e = null != e && e, t = null == t ? e : t, this.map((function () { return w.clone(this, e, t) })) }, html: function (e) { return z(this, (function (e) { var t = this[0] || {}, n = 0, r = this.length; if (void 0 === e && 1 === t.nodeType) return t.innerHTML; if ("string" == typeof e && !_e.test(e) && !fe[(de.exec(e) || ["", ""])[1].toLowerCase()]) { e = w.htmlPrefilter(e); try { for (; n < r; n++)1 === (t = this[n] || {}).nodeType && (w.cleanData(he(t, !1)), t.innerHTML = e); t = 0 } catch (e) { } } t && this.empty().append(e) }), null, e, arguments.length) }, replaceWith: function () { var e = []; return Pe(this, arguments, (function (t) { var n = this.parentNode; w.inArray(this, e) < 0 && (w.cleanData(he(this)), n && n.replaceChild(t, this)) }), e) } }), w.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, (function (e, t) { w.fn[e] = function (e) { for (var n, r = [], o = w(e), i = o.length - 1, a = 0; a <= i; a++)n = a === i ? this : this.clone(!0), w(o[a])[t](n), s.apply(r, n.get()); return this.pushStack(r) } })); var Ie = new RegExp("^(" + Q + ")(?!px)[a-z%]+$", "i"), Oe = function (t) { var n = t.ownerDocument.defaultView; return n && n.opener || (n = e), n.getComputedStyle(t) }, qe = function (e, t, n) { var r, o, i = {}; for (o in t) i[o] = e.style[o], e.style[o] = t[o]; for (o in r = n.call(e), t) e.style[o] = i[o]; return r }, We = new RegExp(te.join("|"), "i"); function Me(e, t, n) { var r, o, i, s, a = e.style; return (n = n || Oe(e)) && ("" !== (s = n.getPropertyValue(t) || n[t]) || re(e) || (s = w.style(e, t)), !f.pixelBoxStyles() && Ie.test(s) && We.test(t) && (r = a.width, o = a.minWidth, i = a.maxWidth, a.minWidth = a.maxWidth = a.width = s, s = n.width, a.width = r, a.minWidth = o, a.maxWidth = i)), void 0 !== s ? s + "" : s } function ze(e, t) { return { get: function () { if (!e()) return (this.get = t).apply(this, arguments); delete this.get } } } !function () { function t() { if (u) { l.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", u.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", ne.appendChild(l).appendChild(u); var t = e.getComputedStyle(u); r = "1%" !== t.top, c = 12 === n(t.marginLeft), u.style.right = "60%", s = 36 === n(t.right), o = 36 === n(t.width), u.style.position = "absolute", i = 12 === n(u.offsetWidth / 3), ne.removeChild(l), u = null } } function n(e) { return Math.round(parseFloat(e)) } var r, o, i, s, a, c, l = g.createElement("div"), u = g.createElement("div"); u.style && (u.style.backgroundClip = "content-box", u.cloneNode(!0).style.backgroundClip = "", f.clearCloneStyle = "content-box" === u.style.backgroundClip, w.extend(f, { boxSizingReliable: function () { return t(), o }, pixelBoxStyles: function () { return t(), s }, pixelPosition: function () { return t(), r }, reliableMarginLeft: function () { return t(), c }, scrollboxSize: function () { return t(), i }, reliableTrDimensions: function () { var t, n, r, o; return null == a && (t = g.createElement("table"), n = g.createElement("tr"), r = g.createElement("div"), t.style.cssText = "position:absolute;left:-11111px", n.style.height = "1px", r.style.height = "9px", ne.appendChild(t).appendChild(n).appendChild(r), o = e.getComputedStyle(n), a = parseInt(o.height) > 3, ne.removeChild(t)), a } })) }(); var Fe = ["Webkit", "Moz", "ms"], Ue = g.createElement("div").style, Be = {}; function He(e) { var t = w.cssProps[e] || Be[e]; return t || (e in Ue ? e : Be[e] = function (e) { for (var t = e[0].toUpperCase() + e.slice(1), n = Fe.length; n--;)if ((e = Fe[n] + t) in Ue) return e }(e) || e) } var Ge = /^(none|table(?!-c[ea]).+)/, Ve = /^--/, Ze = { position: "absolute", visibility: "hidden", display: "block" }, Ye = { letterSpacing: "0", fontWeight: "400" }; function Xe(e, t, n) { var r = ee.exec(t); return r ? Math.max(0, r[2] - (n || 0)) + (r[3] || "px") : t } function Ke(e, t, n, r, o, i) { var s = "width" === t ? 1 : 0, a = 0, c = 0; if (n === (r ? "border" : "content")) return 0; for (; s < 4; s += 2)"margin" === n && (c += w.css(e, n + te[s], !0, o)), r ? ("content" === n && (c -= w.css(e, "padding" + te[s], !0, o)), "margin" !== n && (c -= w.css(e, "border" + te[s] + "Width", !0, o))) : (c += w.css(e, "padding" + te[s], !0, o), "padding" !== n ? c += w.css(e, "border" + te[s] + "Width", !0, o) : a += w.css(e, "border" + te[s] + "Width", !0, o)); return !r && i >= 0 && (c += Math.max(0, Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - i - c - a - .5)) || 0), c } function Je(e, t, n) { var r = Oe(e), o = (!f.boxSizingReliable() || n) && "border-box" === w.css(e, "boxSizing", !1, r), i = o, s = Me(e, t, r), a = "offset" + t[0].toUpperCase() + t.slice(1); if (Ie.test(s)) { if (!n) return s; s = "auto" } return (!f.boxSizingReliable() && o || !f.reliableTrDimensions() && _(e, "tr") || "auto" === s || !parseFloat(s) && "inline" === w.css(e, "display", !1, r)) && e.getClientRects().length && (o = "border-box" === w.css(e, "boxSizing", !1, r), (i = a in e) && (s = e[a])), (s = parseFloat(s) || 0) + Ke(e, t, n || (o ? "border" : "content"), i, r, s) + "px" } function Qe(e, t, n, r, o) { return new Qe.prototype.init(e, t, n, r, o) } w.extend({ cssHooks: { opacity: { get: function (e, t) { if (t) { var n = Me(e, "opacity"); return "" === n ? "1" : n } } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, gridArea: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnStart: !0, gridRow: !0, gridRowEnd: !0, gridRowStart: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: {}, style: function (e, t, n, r) { if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) { var o, i, s, a = H(t), c = Ve.test(t), l = e.style; if (c || (t = He(a)), s = w.cssHooks[t] || w.cssHooks[a], void 0 === n) return s && "get" in s && void 0 !== (o = s.get(e, !1, r)) ? o : l[t]; "string" === (i = typeof n) && (o = ee.exec(n)) && o[1] && (n = se(e, t, o), i = "number"), null != n && n == n && ("number" !== i || c || (n += o && o[3] || (w.cssNumber[a] ? "" : "px")), f.clearCloneStyle || "" !== n || 0 !== t.indexOf("background") || (l[t] = "inherit"), s && "set" in s && void 0 === (n = s.set(e, n, r)) || (c ? l.setProperty(t, n) : l[t] = n)) } }, css: function (e, t, n, r) { var o, i, s, a = H(t); return Ve.test(t) || (t = He(a)), (s = w.cssHooks[t] || w.cssHooks[a]) && "get" in s && (o = s.get(e, !0, n)), void 0 === o && (o = Me(e, t, r)), "normal" === o && t in Ye && (o = Ye[t]), "" === n || n ? (i = parseFloat(o), !0 === n || isFinite(i) ? i || 0 : o) : o } }), w.each(["height", "width"], (function (e, t) { w.cssHooks[t] = { get: function (e, n, r) { if (n) return !Ge.test(w.css(e, "display")) || e.getClientRects().length && e.getBoundingClientRect().width ? Je(e, t, r) : qe(e, Ze, (function () { return Je(e, t, r) })) }, set: function (e, n, r) { var o, i = Oe(e), s = !f.scrollboxSize() && "absolute" === i.position, a = (s || r) && "border-box" === w.css(e, "boxSizing", !1, i), c = r ? Ke(e, t, r, a, i) : 0; return a && s && (c -= Math.ceil(e["offset" + t[0].toUpperCase() + t.slice(1)] - parseFloat(i[t]) - Ke(e, t, "border", !1, i) - .5)), c && (o = ee.exec(n)) && "px" !== (o[3] || "px") && (e.style[t] = n, n = w.css(e, t)), Xe(0, n, c) } } })), w.cssHooks.marginLeft = ze(f.reliableMarginLeft, (function (e, t) { if (t) return (parseFloat(Me(e, "marginLeft")) || e.getBoundingClientRect().left - qe(e, { marginLeft: 0 }, (function () { return e.getBoundingClientRect().left }))) + "px" })), w.each({ margin: "", padding: "", border: "Width" }, (function (e, t) { w.cssHooks[e + t] = { expand: function (n) { for (var r = 0, o = {}, i = "string" == typeof n ? n.split(" ") : [n]; r < 4; r++)o[e + te[r] + t] = i[r] || i[r - 2] || i[0]; return o } }, "margin" !== e && (w.cssHooks[e + t].set = Xe) })), w.fn.extend({ css: function (e, t) { return z(this, (function (e, t, n) { var r, o, i = {}, s = 0; if (Array.isArray(t)) { for (r = Oe(e), o = t.length; s < o; s++)i[t[s]] = w.css(e, t[s], !1, r); return i } return void 0 !== n ? w.style(e, t, n) : w.css(e, t) }), e, t, arguments.length > 1) } }), w.Tween = Qe, Qe.prototype = { constructor: Qe, init: function (e, t, n, r, o, i) { this.elem = e, this.prop = n, this.easing = o || w.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = i || (w.cssNumber[n] ? "" : "px") }, cur: function () { var e = Qe.propHooks[this.prop]; return e && e.get ? e.get(this) : Qe.propHooks._default.get(this) }, run: function (e) { var t, n = Qe.propHooks[this.prop]; return this.options.duration ? this.pos = t = w.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : Qe.propHooks._default.set(this), this } }, Qe.prototype.init.prototype = Qe.prototype, Qe.propHooks = { _default: { get: function (e) { var t; return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = w.css(e.elem, e.prop, "")) && "auto" !== t ? t : 0 }, set: function (e) { w.fx.step[e.prop] ? w.fx.step[e.prop](e) : 1 !== e.elem.nodeType || !w.cssHooks[e.prop] && null == e.elem.style[He(e.prop)] ? e.elem[e.prop] = e.now : w.style(e.elem, e.prop, e.now + e.unit) } } }, Qe.propHooks.scrollTop = Qe.propHooks.scrollLeft = { set: function (e) { e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now) } }, w.easing = { linear: function (e) { return e }, swing: function (e) { return .5 - Math.cos(e * Math.PI) / 2 }, _default: "swing" }, w.fx = Qe.prototype.init, w.fx.step = {}; var et, tt, nt, rt, ot = /^(?:toggle|show|hide)$/, it = /queueHooks$/; function st() { tt && (!1 === g.hidden && e.requestAnimationFrame ? e.requestAnimationFrame(st) : e.setTimeout(st, w.fx.interval), w.fx.tick()) } function at() { return e.setTimeout((function () { et = void 0 })), et = Date.now() } function ct(e, t) { var n, r = 0, o = { height: e }; for (t = t ? 1 : 0; r < 4; r += 2 - t)o["margin" + (n = te[r])] = o["padding" + n] = e; return t && (o.opacity = o.width = e), o } function lt(e, t, n) { for (var r, o = (ut.tweeners[t] || []).concat(ut.tweeners["*"]), i = 0, s = o.length; i < s; i++)if (r = o[i].call(n, t, e)) return r } function ut(e, t, n) { var r, o, i = 0, s = ut.prefilters.length, a = w.Deferred().always((function () { delete c.elem })), c = function () { if (o) return !1; for (var t = et || at(), n = Math.max(0, l.startTime + l.duration - t), r = 1 - (n / l.duration || 0), i = 0, s = l.tweens.length; i < s; i++)l.tweens[i].run(r); return a.notifyWith(e, [l, r, n]), r < 1 && s ? n : (s || a.notifyWith(e, [l, 1, 0]), a.resolveWith(e, [l]), !1) }, l = a.promise({ elem: e, props: w.extend({}, t), opts: w.extend(!0, { specialEasing: {}, easing: w.easing._default }, n), originalProperties: t, originalOptions: n, startTime: et || at(), duration: n.duration, tweens: [], createTween: function (t, n) { var r = w.Tween(e, l.opts, t, n, l.opts.specialEasing[t] || l.opts.easing); return l.tweens.push(r), r }, stop: function (t) { var n = 0, r = t ? l.tweens.length : 0; if (o) return this; for (o = !0; n < r; n++)l.tweens[n].run(1); return t ? (a.notifyWith(e, [l, 1, 0]), a.resolveWith(e, [l, t])) : a.rejectWith(e, [l, t]), this } }), u = l.props; for (!function (e, t) { var n, r, o, i, s; for (n in e) if (o = t[r = H(n)], i = e[n], Array.isArray(i) && (o = i[1], i = e[n] = i[0]), n !== r && (e[r] = i, delete e[n]), (s = w.cssHooks[r]) && "expand" in s) for (n in i = s.expand(i), delete e[r], i) n in e || (e[n] = i[n], t[n] = o); else t[r] = o }(u, l.opts.specialEasing); i < s; i++)if (r = ut.prefilters[i].call(l, e, u, l.opts)) return h(r.stop) && (w._queueHooks(l.elem, l.opts.queue).stop = r.stop.bind(r)), r; return w.map(u, lt, l), h(l.opts.start) && l.opts.start.call(e, l), l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always), w.fx.timer(w.extend(c, { elem: e, anim: l, queue: l.opts.queue })), l } w.Animation = w.extend(ut, { tweeners: { "*": [function (e, t) { var n = this.createTween(e, t); return se(n.elem, e, ee.exec(t), n), n }] }, tweener: function (e, t) { h(e) ? (t = e, e = ["*"]) : e = e.match(P); for (var n, r = 0, o = e.length; r < o; r++)n = e[r], ut.tweeners[n] = ut.tweeners[n] || [], ut.tweeners[n].unshift(t) }, prefilters: [function (e, t, n) { var r, o, i, s, a, c, l, u, d = "width" in t || "height" in t, p = this, f = {}, h = e.style, m = e.nodeType && ie(e), g = Z.get(e, "fxshow"); for (r in n.queue || (null == (s = w._queueHooks(e, "fx")).unqueued && (s.unqueued = 0, a = s.empty.fire, s.empty.fire = function () { s.unqueued || a() }), s.unqueued++, p.always((function () { p.always((function () { s.unqueued--, w.queue(e, "fx").length || s.empty.fire() })) }))), t) if (o = t[r], ot.test(o)) { if (delete t[r], i = i || "toggle" === o, o === (m ? "hide" : "show")) { if ("show" !== o || !g || void 0 === g[r]) continue; m = !0 } f[r] = g && g[r] || w.style(e, r) } if ((c = !w.isEmptyObject(t)) || !w.isEmptyObject(f)) for (r in d && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = g && g.display) && (l = Z.get(e, "display")), "none" === (u = w.css(e, "display")) && (l ? u = l : (le([e], !0), l = e.style.display || l, u = w.css(e, "display"), le([e]))), ("inline" === u || "inline-block" === u && null != l) && "none" === w.css(e, "float") && (c || (p.done((function () { h.display = l })), null == l && (u = h.display, l = "none" === u ? "" : u)), h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p.always((function () { h.overflow = n.overflow[0], h.overflowX = n.overflow[1], h.overflowY = n.overflow[2] }))), c = !1, f) c || (g ? "hidden" in g && (m = g.hidden) : g = Z.access(e, "fxshow", { display: l }), i && (g.hidden = !m), m && le([e], !0), p.done((function () { for (r in m || le([e]), Z.remove(e, "fxshow"), f) w.style(e, r, f[r]) }))), c = lt(m ? g[r] : 0, r, p), r in g || (g[r] = c.start, m && (c.end = c.start, c.start = 0)) }], prefilter: function (e, t) { t ? ut.prefilters.unshift(e) : ut.prefilters.push(e) } }), w.speed = function (e, t, n) { var r = e && "object" == typeof e ? w.extend({}, e) : { complete: n || !n && t || h(e) && e, duration: e, easing: n && t || t && !h(t) && t }; return w.fx.off ? r.duration = 0 : "number" != typeof r.duration && (r.duration in w.fx.speeds ? r.duration = w.fx.speeds[r.duration] : r.duration = w.fx.speeds._default), null != r.queue && !0 !== r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function () { h(r.old) && r.old.call(this), r.queue && w.dequeue(this, r.queue) }, r }, w.fn.extend({ fadeTo: function (e, t, n, r) { return this.filter(ie).css("opacity", 0).show().end().animate({ opacity: t }, e, n, r) }, animate: function (e, t, n, r) { var o = w.isEmptyObject(e), i = w.speed(t, n, r), s = function () { var t = ut(this, w.extend({}, e), i); (o || Z.get(this, "finish")) && t.stop(!0) }; return s.finish = s, o || !1 === i.queue ? this.each(s) : this.queue(i.queue, s) }, stop: function (e, t, n) { var r = function (e) { var t = e.stop; delete e.stop, t(n) }; return "string" != typeof e && (n = t, t = e, e = void 0), t && this.queue(e || "fx", []), this.each((function () { var t = !0, o = null != e && e + "queueHooks", i = w.timers, s = Z.get(this); if (o) s[o] && s[o].stop && r(s[o]); else for (o in s) s[o] && s[o].stop && it.test(o) && r(s[o]); for (o = i.length; o--;)i[o].elem !== this || null != e && i[o].queue !== e || (i[o].anim.stop(n), t = !1, i.splice(o, 1)); !t && n || w.dequeue(this, e) })) }, finish: function (e) { return !1 !== e && (e = e || "fx"), this.each((function () { var t, n = Z.get(this), r = n[e + "queue"], o = n[e + "queueHooks"], i = w.timers, s = r ? r.length : 0; for (n.finish = !0, w.queue(this, e, []), o && o.stop && o.stop.call(this, !0), t = i.length; t--;)i[t].elem === this && i[t].queue === e && (i[t].anim.stop(!0), i.splice(t, 1)); for (t = 0; t < s; t++)r[t] && r[t].finish && r[t].finish.call(this); delete n.finish })) } }), w.each(["toggle", "show", "hide"], (function (e, t) { var n = w.fn[t]; w.fn[t] = function (e, r, o) { return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(ct(t, !0), e, r, o) } })), w.each({ slideDown: ct("show"), slideUp: ct("hide"), slideToggle: ct("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, (function (e, t) { w.fn[e] = function (e, n, r) { return this.animate(t, e, n, r) } })), w.timers = [], w.fx.tick = function () { var e, t = 0, n = w.timers; for (et = Date.now(); t < n.length; t++)(e = n[t])() || n[t] !== e || n.splice(t--, 1); n.length || w.fx.stop(), et = void 0 }, w.fx.timer = function (e) { w.timers.push(e), w.fx.start() }, w.fx.interval = 13, w.fx.start = function () { tt || (tt = !0, st()) }, w.fx.stop = function () { tt = null }, w.fx.speeds = { slow: 600, fast: 200, _default: 400 }, w.fn.delay = function (t, n) { return t = w.fx && w.fx.speeds[t] || t, n = n || "fx", this.queue(n, (function (n, r) { var o = e.setTimeout(n, t); r.stop = function () { e.clearTimeout(o) } })) }, nt = g.createElement("input"), rt = g.createElement("select").appendChild(g.createElement("option")), nt.type = "checkbox", f.checkOn = "" !== nt.value, f.optSelected = rt.selected, (nt = g.createElement("input")).value = "t", nt.type = "radio", f.radioValue = "t" === nt.value; var dt, pt = w.expr.attrHandle; w.fn.extend({ attr: function (e, t) { return z(this, w.attr, e, t, arguments.length > 1) }, removeAttr: function (e) { return this.each((function () { w.removeAttr(this, e) })) } }), w.extend({ attr: function (e, t, n) { var r, o, i = e.nodeType; if (3 !== i && 8 !== i && 2 !== i) return void 0 === e.getAttribute ? w.prop(e, t, n) : (1 === i && w.isXMLDoc(e) || (o = w.attrHooks[t.toLowerCase()] || (w.expr.match.bool.test(t) ? dt : void 0)), void 0 !== n ? null === n ? void w.removeAttr(e, t) : o && "set" in o && void 0 !== (r = o.set(e, n, t)) ? r : (e.setAttribute(t, n + ""), n) : o && "get" in o && null !== (r = o.get(e, t)) ? r : null == (r = w.find.attr(e, t)) ? void 0 : r) }, attrHooks: { type: { set: function (e, t) { if (!f.radioValue && "radio" === t && _(e, "input")) { var n = e.value; return e.setAttribute("type", t), n && (e.value = n), t } } } }, removeAttr: function (e, t) { var n, r = 0, o = t && t.match(P); if (o && 1 === e.nodeType) for (; n = o[r++];)e.removeAttribute(n) } }), dt = { set: function (e, t, n) { return !1 === t ? w.removeAttr(e, n) : e.setAttribute(n, n), n } }, w.each(w.expr.match.bool.source.match(/\w+/g), (function (e, t) { var n = pt[t] || w.find.attr; pt[t] = function (e, t, r) { var o, i, s = t.toLowerCase(); return r || (i = pt[s], pt[s] = o, o = null != n(e, t, r) ? s : null, pt[s] = i), o } })); var ft = /^(?:input|select|textarea|button)$/i, ht = /^(?:a|area)$/i; function mt(e) { return (e.match(P) || []).join(" ") } function gt(e) { return e.getAttribute && e.getAttribute("class") || "" } function bt(e) { return Array.isArray(e) ? e : "string" == typeof e && e.match(P) || [] } w.fn.extend({ prop: function (e, t) { return z(this, w.prop, e, t, arguments.length > 1) }, removeProp: function (e) { return this.each((function () { delete this[w.propFix[e] || e] })) } }), w.extend({ prop: function (e, t, n) { var r, o, i = e.nodeType; if (3 !== i && 8 !== i && 2 !== i) return 1 === i && w.isXMLDoc(e) || (t = w.propFix[t] || t, o = w.propHooks[t]), void 0 !== n ? o && "set" in o && void 0 !== (r = o.set(e, n, t)) ? r : e[t] = n : o && "get" in o && null !== (r = o.get(e, t)) ? r : e[t] }, propHooks: { tabIndex: { get: function (e) { var t = w.find.attr(e, "tabindex"); return t ? parseInt(t, 10) : ft.test(e.nodeName) || ht.test(e.nodeName) && e.href ? 0 : -1 } } }, propFix: { for: "htmlFor", class: "className" } }), f.optSelected || (w.propHooks.selected = { get: function (e) { var t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null }, set: function (e) { var t = e.parentNode; t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex) } }), w.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], (function () { w.propFix[this.toLowerCase()] = this })), w.fn.extend({ addClass: function (e) { var t, n, r, o, i, s, a, c = 0; if (h(e)) return this.each((function (t) { w(this).addClass(e.call(this, t, gt(this))) })); if ((t = bt(e)).length) for (; n = this[c++];)if (o = gt(n), r = 1 === n.nodeType && " " + mt(o) + " ") { for (s = 0; i = t[s++];)r.indexOf(" " + i + " ") < 0 && (r += i + " "); o !== (a = mt(r)) && n.setAttribute("class", a) } return this }, removeClass: function (e) { var t, n, r, o, i, s, a, c = 0; if (h(e)) return this.each((function (t) { w(this).removeClass(e.call(this, t, gt(this))) })); if (!arguments.length) return this.attr("class", ""); if ((t = bt(e)).length) for (; n = this[c++];)if (o = gt(n), r = 1 === n.nodeType && " " + mt(o) + " ") { for (s = 0; i = t[s++];)for (; r.indexOf(" " + i + " ") > -1;)r = r.replace(" " + i + " ", " "); o !== (a = mt(r)) && n.setAttribute("class", a) } return this }, toggleClass: function (e, t) { var n = typeof e, r = "string" === n || Array.isArray(e); return "boolean" == typeof t && r ? t ? this.addClass(e) : this.removeClass(e) : h(e) ? this.each((function (n) { w(this).toggleClass(e.call(this, n, gt(this), t), t) })) : this.each((function () { var t, o, i, s; if (r) for (o = 0, i = w(this), s = bt(e); t = s[o++];)i.hasClass(t) ? i.removeClass(t) : i.addClass(t); else void 0 !== e && "boolean" !== n || ((t = gt(this)) && Z.set(this, "__className__", t), this.setAttribute && this.setAttribute("class", t || !1 === e ? "" : Z.get(this, "__className__") || "")) })) }, hasClass: function (e) { var t, n, r = 0; for (t = " " + e + " "; n = this[r++];)if (1 === n.nodeType && (" " + mt(gt(n)) + " ").indexOf(t) > -1) return !0; return !1 } }); var yt = /\r/g; w.fn.extend({ val: function (e) { var t, n, r, o = this[0]; return arguments.length ? (r = h(e), this.each((function (n) { var o; 1 === this.nodeType && (null == (o = r ? e.call(this, n, w(this).val()) : e) ? o = "" : "number" == typeof o ? o += "" : Array.isArray(o) && (o = w.map(o, (function (e) { return null == e ? "" : e + "" }))), (t = w.valHooks[this.type] || w.valHooks[this.nodeName.toLowerCase()]) && "set" in t && void 0 !== t.set(this, o, "value") || (this.value = o)) }))) : o ? (t = w.valHooks[o.type] || w.valHooks[o.nodeName.toLowerCase()]) && "get" in t && void 0 !== (n = t.get(o, "value")) ? n : "string" == typeof (n = o.value) ? n.replace(yt, "") : null == n ? "" : n : void 0 } }), w.extend({ valHooks: { option: { get: function (e) { var t = w.find.attr(e, "value"); return null != t ? t : mt(w.text(e)) } }, select: { get: function (e) { var t, n, r, o = e.options, i = e.selectedIndex, s = "select-one" === e.type, a = s ? null : [], c = s ? i + 1 : o.length; for (r = i < 0 ? c : s ? i : 0; r < c; r++)if (((n = o[r]).selected || r === i) && !n.disabled && (!n.parentNode.disabled || !_(n.parentNode, "optgroup"))) { if (t = w(n).val(), s) return t; a.push(t) } return a }, set: function (e, t) { for (var n, r, o = e.options, i = w.makeArray(t), s = o.length; s--;)((r = o[s]).selected = w.inArray(w.valHooks.option.get(r), i) > -1) && (n = !0); return n || (e.selectedIndex = -1), i } } } }), w.each(["radio", "checkbox"], (function () { w.valHooks[this] = { set: function (e, t) { if (Array.isArray(t)) return e.checked = w.inArray(w(e).val(), t) > -1 } }, f.checkOn || (w.valHooks[this].get = function (e) { return null === e.getAttribute("value") ? "on" : e.value }) })), f.focusin = "onfocusin" in e; var vt = /^(?:focusinfocus|focusoutblur)$/, wt = function (e) { e.stopPropagation() }; w.extend(w.event, { trigger: function (t, n, r, o) { var i, s, a, c, l, d, p, f, b = [r || g], y = u.call(t, "type") ? t.type : t, v = u.call(t, "namespace") ? t.namespace.split(".") : []; if (s = f = a = r = r || g, 3 !== r.nodeType && 8 !== r.nodeType && !vt.test(y + w.event.triggered) && (y.indexOf(".") > -1 && (v = y.split("."), y = v.shift(), v.sort()), l = y.indexOf(":") < 0 && "on" + y, (t = t[w.expando] ? t : new w.Event(y, "object" == typeof t && t)).isTrigger = o ? 2 : 3, t.namespace = v.join("."), t.rnamespace = t.namespace ? new RegExp("(^|\\.)" + v.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = r), n = null == n ? [t] : w.makeArray(n, [t]), p = w.event.special[y] || {}, o || !p.trigger || !1 !== p.trigger.apply(r, n))) { if (!o && !p.noBubble && !m(r)) { for (c = p.delegateType || y, vt.test(c + y) || (s = s.parentNode); s; s = s.parentNode)b.push(s), a = s; a === (r.ownerDocument || g) && b.push(a.defaultView || a.parentWindow || e) } for (i = 0; (s = b[i++]) && !t.isPropagationStopped();)f = s, t.type = i > 1 ? c : p.bindType || y, (d = (Z.get(s, "events") || Object.create(null))[t.type] && Z.get(s, "handle")) && d.apply(s, n), (d = l && s[l]) && d.apply && G(s) && (t.result = d.apply(s, n), !1 === t.result && t.preventDefault()); return t.type = y, o || t.isDefaultPrevented() || p._default && !1 !== p._default.apply(b.pop(), n) || !G(r) || l && h(r[y]) && !m(r) && ((a = r[l]) && (r[l] = null), w.event.triggered = y, t.isPropagationStopped() && f.addEventListener(y, wt), r[y](), t.isPropagationStopped() && f.removeEventListener(y, wt), w.event.triggered = void 0, a && (r[l] = a)), t.result } }, simulate: function (e, t, n) { var r = w.extend(new w.Event, n, { type: e, isSimulated: !0 }); w.event.trigger(r, null, t) } }), w.fn.extend({ trigger: function (e, t) { return this.each((function () { w.event.trigger(e, t, this) })) }, triggerHandler: function (e, t) { var n = this[0]; if (n) return w.event.trigger(e, t, n, !0) } }), f.focusin || w.each({ focus: "focusin", blur: "focusout" }, (function (e, t) { var n = function (e) { w.event.simulate(t, e.target, w.event.fix(e)) }; w.event.special[t] = { setup: function () { var r = this.ownerDocument || this.document || this, o = Z.access(r, t); o || r.addEventListener(e, n, !0), Z.access(r, t, (o || 0) + 1) }, teardown: function () { var r = this.ownerDocument || this.document || this, o = Z.access(r, t) - 1; o ? Z.access(r, t, o) : (r.removeEventListener(e, n, !0), Z.remove(r, t)) } } })); var xt = e.location, kt = { guid: Date.now() }, $t = /\?/; w.parseXML = function (t) { var n; if (!t || "string" != typeof t) return null; try { n = (new e.DOMParser).parseFromString(t, "text/xml") } catch (e) { n = void 0 } return n && !n.getElementsByTagName("parsererror").length || w.error("Invalid XML: " + t), n }; var Ct = /\[\]$/, St = /\r?\n/g, _t = /^(?:submit|button|image|reset|file)$/i, Et = /^(?:input|select|textarea|keygen)/i; function Tt(e, t, n, r) { var o; if (Array.isArray(t)) w.each(t, (function (t, o) { n || Ct.test(e) ? r(e, o) : Tt(e + "[" + ("object" == typeof o && null != o ? t : "") + "]", o, n, r) })); else if (n || "object" !== v(t)) r(e, t); else for (o in t) Tt(e + "[" + o + "]", t[o], n, r) } w.param = function (e, t) { var n, r = [], o = function (e, t) { var n = h(t) ? t() : t; r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n) }; if (null == e) return ""; if (Array.isArray(e) || e.jquery && !w.isPlainObject(e)) w.each(e, (function () { o(this.name, this.value) })); else for (n in e) Tt(n, e[n], t, o); return r.join("&") }, w.fn.extend({ serialize: function () { return w.param(this.serializeArray()) }, serializeArray: function () { return this.map((function () { var e = w.prop(this, "elements"); return e ? w.makeArray(e) : this })).filter((function () { var e = this.type; return this.name && !w(this).is(":disabled") && Et.test(this.nodeName) && !_t.test(e) && (this.checked || !ue.test(e)) })).map((function (e, t) { var n = w(this).val(); return null == n ? null : Array.isArray(n) ? w.map(n, (function (e) { return { name: t.name, value: e.replace(St, "\r\n") } })) : { name: t.name, value: n.replace(St, "\r\n") } })).get() } }); var At = /%20/g, Rt = /#.*$/, Lt = /([?&])_=[^&]*/, Nt = /^(.*?):[ \t]*([^\r\n]*)$/gm, Dt = /^(?:GET|HEAD)$/, Pt = /^\/\//, jt = {}, It = {}, Ot = "*/".concat("*"), qt = g.createElement("a"); function Wt(e) { return function (t, n) { "string" != typeof t && (n = t, t = "*"); var r, o = 0, i = t.toLowerCase().match(P) || []; if (h(n)) for (; r = i[o++];)"+" === r[0] ? (r = r.slice(1) || "*", (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n) } } function Mt(e, t, n, r) { var o = {}, i = e === It; function s(a) { var c; return o[a] = !0, w.each(e[a] || [], (function (e, a) { var l = a(t, n, r); return "string" != typeof l || i || o[l] ? i ? !(c = l) : void 0 : (t.dataTypes.unshift(l), s(l), !1) })), c } return s(t.dataTypes[0]) || !o["*"] && s("*") } function zt(e, t) { var n, r, o = w.ajaxSettings.flatOptions || {}; for (n in t) void 0 !== t[n] && ((o[n] ? e : r || (r = {}))[n] = t[n]); return r && w.extend(!0, e, r), e } qt.href = xt.href, w.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: xt.href, type: "GET", isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(xt.protocol), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": Ot, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": JSON.parse, "text xml": w.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function (e, t) { return t ? zt(zt(e, w.ajaxSettings), t) : zt(w.ajaxSettings, e) }, ajaxPrefilter: Wt(jt), ajaxTransport: Wt(It), ajax: function (t, n) { "object" == typeof t && (n = t, t = void 0), n = n || {}; var r, o, i, s, a, c, l, u, d, p, f = w.ajaxSetup({}, n), h = f.context || f, m = f.context && (h.nodeType || h.jquery) ? w(h) : w.event, b = w.Deferred(), y = w.Callbacks("once memory"), v = f.statusCode || {}, x = {}, k = {}, $ = "canceled", C = { readyState: 0, getResponseHeader: function (e) { var t; if (l) { if (!s) for (s = {}; t = Nt.exec(i);)s[t[1].toLowerCase() + " "] = (s[t[1].toLowerCase() + " "] || []).concat(t[2]); t = s[e.toLowerCase() + " "] } return null == t ? null : t.join(", ") }, getAllResponseHeaders: function () { return l ? i : null }, setRequestHeader: function (e, t) { return null == l && (e = k[e.toLowerCase()] = k[e.toLowerCase()] || e, x[e] = t), this }, overrideMimeType: function (e) { return null == l && (f.mimeType = e), this }, statusCode: function (e) { var t; if (e) if (l) C.always(e[C.status]); else for (t in e) v[t] = [v[t], e[t]]; return this }, abort: function (e) { var t = e || $; return r && r.abort(t), S(0, t), this } }; if (b.promise(C), f.url = ((t || f.url || xt.href) + "").replace(Pt, xt.protocol + "//"), f.type = n.method || n.type || f.method || f.type, f.dataTypes = (f.dataType || "*").toLowerCase().match(P) || [""], null == f.crossDomain) { c = g.createElement("a"); try { c.href = f.url, c.href = c.href, f.crossDomain = qt.protocol + "//" + qt.host != c.protocol + "//" + c.host } catch (e) { f.crossDomain = !0 } } if (f.data && f.processData && "string" != typeof f.data && (f.data = w.param(f.data, f.traditional)), Mt(jt, f, n, C), l) return C; for (d in (u = w.event && f.global) && 0 == w.active++ && w.event.trigger("ajaxStart"), f.type = f.type.toUpperCase(), f.hasContent = !Dt.test(f.type), o = f.url.replace(Rt, ""), f.hasContent ? f.data && f.processData && 0 === (f.contentType || "").indexOf("application/x-www-form-urlencoded") && (f.data = f.data.replace(At, "+")) : (p = f.url.slice(o.length), f.data && (f.processData || "string" == typeof f.data) && (o += ($t.test(o) ? "&" : "?") + f.data, delete f.data), !1 === f.cache && (o = o.replace(Lt, "$1"), p = ($t.test(o) ? "&" : "?") + "_=" + kt.guid++ + p), f.url = o + p), f.ifModified && (w.lastModified[o] && C.setRequestHeader("If-Modified-Since", w.lastModified[o]), w.etag[o] && C.setRequestHeader("If-None-Match", w.etag[o])), (f.data && f.hasContent && !1 !== f.contentType || n.contentType) && C.setRequestHeader("Content-Type", f.contentType), C.setRequestHeader("Accept", f.dataTypes[0] && f.accepts[f.dataTypes[0]] ? f.accepts[f.dataTypes[0]] + ("*" !== f.dataTypes[0] ? ", " + Ot + "; q=0.01" : "") : f.accepts["*"]), f.headers) C.setRequestHeader(d, f.headers[d]); if (f.beforeSend && (!1 === f.beforeSend.call(h, C, f) || l)) return C.abort(); if ($ = "abort", y.add(f.complete), C.done(f.success), C.fail(f.error), r = Mt(It, f, n, C)) { if (C.readyState = 1, u && m.trigger("ajaxSend", [C, f]), l) return C; f.async && f.timeout > 0 && (a = e.setTimeout((function () { C.abort("timeout") }), f.timeout)); try { l = !1, r.send(x, S) } catch (e) { if (l) throw e; S(-1, e) } } else S(-1, "No Transport"); function S(t, n, s, c) { var d, p, g, x, k, $ = n; l || (l = !0, a && e.clearTimeout(a), r = void 0, i = c || "", C.readyState = t > 0 ? 4 : 0, d = t >= 200 && t < 300 || 304 === t, s && (x = function (e, t, n) { for (var r, o, i, s, a = e.contents, c = e.dataTypes; "*" === c[0];)c.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type")); if (r) for (o in a) if (a[o] && a[o].test(r)) { c.unshift(o); break } if (c[0] in n) i = c[0]; else { for (o in n) { if (!c[0] || e.converters[o + " " + c[0]]) { i = o; break } s || (s = o) } i = i || s } if (i) return i !== c[0] && c.unshift(i), n[i] }(f, C, s)), !d && w.inArray("script", f.dataTypes) > -1 && (f.converters["text script"] = function () { }), x = function (e, t, n, r) { var o, i, s, a, c, l = {}, u = e.dataTypes.slice(); if (u[1]) for (s in e.converters) l[s.toLowerCase()] = e.converters[s]; for (i = u.shift(); i;)if (e.responseFields[i] && (n[e.responseFields[i]] = t), !c && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), c = i, i = u.shift()) if ("*" === i) i = c; else if ("*" !== c && c !== i) { if (!(s = l[c + " " + i] || l["* " + i])) for (o in l) if ((a = o.split(" "))[1] === i && (s = l[c + " " + a[0]] || l["* " + a[0]])) { !0 === s ? s = l[o] : !0 !== l[o] && (i = a[0], u.unshift(a[1])); break } if (!0 !== s) if (s && e.throws) t = s(t); else try { t = s(t) } catch (e) { return { state: "parsererror", error: s ? e : "No conversion from " + c + " to " + i } } } return { state: "success", data: t } }(f, x, C, d), d ? (f.ifModified && ((k = C.getResponseHeader("Last-Modified")) && (w.lastModified[o] = k), (k = C.getResponseHeader("etag")) && (w.etag[o] = k)), 204 === t || "HEAD" === f.type ? $ = "nocontent" : 304 === t ? $ = "notmodified" : ($ = x.state, p = x.data, d = !(g = x.error))) : (g = $, !t && $ || ($ = "error", t < 0 && (t = 0))), C.status = t, C.statusText = (n || $) + "", d ? b.resolveWith(h, [p, $, C]) : b.rejectWith(h, [C, $, g]), C.statusCode(v), v = void 0, u && m.trigger(d ? "ajaxSuccess" : "ajaxError", [C, f, d ? p : g]), y.fireWith(h, [C, $]), u && (m.trigger("ajaxComplete", [C, f]), --w.active || w.event.trigger("ajaxStop"))) } return C }, getJSON: function (e, t, n) { return w.get(e, t, n, "json") }, getScript: function (e, t) { return w.get(e, void 0, t, "script") } }), w.each(["get", "post"], (function (e, t) { w[t] = function (e, n, r, o) { return h(n) && (o = o || r, r = n, n = void 0), w.ajax(w.extend({ url: e, type: t, dataType: o, data: n, success: r }, w.isPlainObject(e) && e)) } })), w.ajaxPrefilter((function (e) { var t; for (t in e.headers) "content-type" === t.toLowerCase() && (e.contentType = e.headers[t] || "") })), w._evalUrl = function (e, t, n) { return w.ajax({ url: e, type: "GET", dataType: "script", cache: !0, async: !1, global: !1, converters: { "text script": function () { } }, dataFilter: function (e) { w.globalEval(e, t, n) } }) }, w.fn.extend({ wrapAll: function (e) { var t; return this[0] && (h(e) && (e = e.call(this[0])), t = w(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map((function () { for (var e = this; e.firstElementChild;)e = e.firstElementChild; return e })).append(this)), this }, wrapInner: function (e) { return h(e) ? this.each((function (t) { w(this).wrapInner(e.call(this, t)) })) : this.each((function () { var t = w(this), n = t.contents(); n.length ? n.wrapAll(e) : t.append(e) })) }, wrap: function (e) { var t = h(e); return this.each((function (n) { w(this).wrapAll(t ? e.call(this, n) : e) })) }, unwrap: function (e) { return this.parent(e).not("body").each((function () { w(this).replaceWith(this.childNodes) })), this } }), w.expr.pseudos.hidden = function (e) { return !w.expr.pseudos.visible(e) }, w.expr.pseudos.visible = function (e) { return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length) }, w.ajaxSettings.xhr = function () { try { return new e.XMLHttpRequest } catch (e) { } }; var Ft = { 0: 200, 1223: 204 }, Ut = w.ajaxSettings.xhr(); f.cors = !!Ut && "withCredentials" in Ut, f.ajax = Ut = !!Ut, w.ajaxTransport((function (t) { var n, r; if (f.cors || Ut && !t.crossDomain) return { send: function (o, i) { var s, a = t.xhr(); if (a.open(t.type, t.url, t.async, t.username, t.password), t.xhrFields) for (s in t.xhrFields) a[s] = t.xhrFields[s]; for (s in t.mimeType && a.overrideMimeType && a.overrideMimeType(t.mimeType), t.crossDomain || o["X-Requested-With"] || (o["X-Requested-With"] = "XMLHttpRequest"), o) a.setRequestHeader(s, o[s]); n = function (e) { return function () { n && (n = r = a.onload = a.onerror = a.onabort = a.ontimeout = a.onreadystatechange = null, "abort" === e ? a.abort() : "error" === e ? "number" != typeof a.status ? i(0, "error") : i(a.status, a.statusText) : i(Ft[a.status] || a.status, a.statusText, "text" !== (a.responseType || "text") || "string" != typeof a.responseText ? { binary: a.response } : { text: a.responseText }, a.getAllResponseHeaders())) } }, a.onload = n(), r = a.onerror = a.ontimeout = n("error"), void 0 !== a.onabort ? a.onabort = r : a.onreadystatechange = function () { 4 === a.readyState && e.setTimeout((function () { n && r() })) }, n = n("abort"); try { a.send(t.hasContent && t.data || null) } catch (e) { if (n) throw e } }, abort: function () { n && n() } } })), w.ajaxPrefilter((function (e) { e.crossDomain && (e.contents.script = !1) })), w.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { "text script": function (e) { return w.globalEval(e), e } } }), w.ajaxPrefilter("script", (function (e) { void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET") })), w.ajaxTransport("script", (function (e) { var t, n; if (e.crossDomain || e.scriptAttrs) return { send: function (r, o) { t = w("<script>").attr(e.scriptAttrs || {}).prop({ charset: e.scriptCharset, src: e.url }).on("load error", n = function (e) { t.remove(), n = null, e && o("error" === e.type ? 404 : 200, e.type) }), g.head.appendChild(t[0]) }, abort: function () { n && n() } } })); var Bt, Ht = [], Gt = /(=)\?(?=&|$)|\?\?/; w.ajaxSetup({ jsonp: "callback", jsonpCallback: function () { var e = Ht.pop() || w.expando + "_" + kt.guid++; return this[e] = !0, e } }), w.ajaxPrefilter("json jsonp", (function (t, n, r) { var o, i, s, a = !1 !== t.jsonp && (Gt.test(t.url) ? "url" : "string" == typeof t.data && 0 === (t.contentType || "").indexOf("application/x-www-form-urlencoded") && Gt.test(t.data) && "data"); if (a || "jsonp" === t.dataTypes[0]) return o = t.jsonpCallback = h(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback, a ? t[a] = t[a].replace(Gt, "$1" + o) : !1 !== t.jsonp && (t.url += ($t.test(t.url) ? "&" : "?") + t.jsonp + "=" + o), t.converters["script json"] = function () { return s || w.error(o + " was not called"), s[0] }, t.dataTypes[0] = "json", i = e[o], e[o] = function () { s = arguments }, r.always((function () { void 0 === i ? w(e).removeProp(o) : e[o] = i, t[o] && (t.jsonpCallback = n.jsonpCallback, Ht.push(o)), s && h(i) && i(s[0]), s = i = void 0 })), "script" })), f.createHTMLDocument = ((Bt = g.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === Bt.childNodes.length), w.parseHTML = function (e, t, n) { return "string" != typeof e ? [] : ("boolean" == typeof t && (n = t, t = !1), t || (f.createHTMLDocument ? ((r = (t = g.implementation.createHTMLDocument("")).createElement("base")).href = g.location.href, t.head.appendChild(r)) : t = g), i = !n && [], (o = E.exec(e)) ? [t.createElement(o[1])] : (o = be([e], t, i), i && i.length && w(i).remove(), w.merge([], o.childNodes))); var r, o, i }, w.fn.load = function (e, t, n) { var r, o, i, s = this, a = e.indexOf(" "); return a > -1 && (r = mt(e.slice(a)), e = e.slice(0, a)), h(t) ? (n = t, t = void 0) : t && "object" == typeof t && (o = "POST"), s.length > 0 && w.ajax({ url: e, type: o || "GET", dataType: "html", data: t }).done((function (e) { i = arguments, s.html(r ? w("<div>").append(w.parseHTML(e)).find(r) : e) })).always(n && function (e, t) { s.each((function () { n.apply(this, i || [e.responseText, t, e]) })) }), this }, w.expr.pseudos.animated = function (e) { return w.grep(w.timers, (function (t) { return e === t.elem })).length }, w.offset = { setOffset: function (e, t, n) { var r, o, i, s, a, c, l = w.css(e, "position"), u = w(e), d = {}; "static" === l && (e.style.position = "relative"), a = u.offset(), i = w.css(e, "top"), c = w.css(e, "left"), ("absolute" === l || "fixed" === l) && (i + c).indexOf("auto") > -1 ? (s = (r = u.position()).top, o = r.left) : (s = parseFloat(i) || 0, o = parseFloat(c) || 0), h(t) && (t = t.call(e, n, w.extend({}, a))), null != t.top && (d.top = t.top - a.top + s), null != t.left && (d.left = t.left - a.left + o), "using" in t ? t.using.call(e, d) : ("number" == typeof d.top && (d.top += "px"), "number" == typeof d.left && (d.left += "px"), u.css(d)) } }, w.fn.extend({ offset: function (e) { if (arguments.length) return void 0 === e ? this : this.each((function (t) { w.offset.setOffset(this, e, t) })); var t, n, r = this[0]; return r ? r.getClientRects().length ? (t = r.getBoundingClientRect(), n = r.ownerDocument.defaultView, { top: t.top + n.pageYOffset, left: t.left + n.pageXOffset }) : { top: 0, left: 0 } : void 0 }, position: function () { if (this[0]) { var e, t, n, r = this[0], o = { top: 0, left: 0 }; if ("fixed" === w.css(r, "position")) t = r.getBoundingClientRect(); else { for (t = this.offset(), n = r.ownerDocument, e = r.offsetParent || n.documentElement; e && (e === n.body || e === n.documentElement) && "static" === w.css(e, "position");)e = e.parentNode; e && e !== r && 1 === e.nodeType && ((o = w(e).offset()).top += w.css(e, "borderTopWidth", !0), o.left += w.css(e, "borderLeftWidth", !0)) } return { top: t.top - o.top - w.css(r, "marginTop", !0), left: t.left - o.left - w.css(r, "marginLeft", !0) } } }, offsetParent: function () { return this.map((function () { for (var e = this.offsetParent; e && "static" === w.css(e, "position");)e = e.offsetParent; return e || ne })) } }), w.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, (function (e, t) { var n = "pageYOffset" === t; w.fn[e] = function (r) { return z(this, (function (e, r, o) { var i; if (m(e) ? i = e : 9 === e.nodeType && (i = e.defaultView), void 0 === o) return i ? i[t] : e[r]; i ? i.scrollTo(n ? i.pageXOffset : o, n ? o : i.pageYOffset) : e[r] = o }), e, r, arguments.length) } })), w.each(["top", "left"], (function (e, t) { w.cssHooks[t] = ze(f.pixelPosition, (function (e, n) { if (n) return n = Me(e, t), Ie.test(n) ? w(e).position()[t] + "px" : n })) })), w.each({ Height: "height", Width: "width" }, (function (e, t) { w.each({ padding: "inner" + e, content: t, "": "outer" + e }, (function (n, r) { w.fn[r] = function (o, i) { var s = arguments.length && (n || "boolean" != typeof o), a = n || (!0 === o || !0 === i ? "margin" : "border"); return z(this, (function (t, n, o) { var i; return m(t) ? 0 === r.indexOf("outer") ? t["inner" + e] : t.document.documentElement["client" + e] : 9 === t.nodeType ? (i = t.documentElement, Math.max(t.body["scroll" + e], i["scroll" + e], t.body["offset" + e], i["offset" + e], i["client" + e])) : void 0 === o ? w.css(t, n, a) : w.style(t, n, o, a) }), t, s ? o : void 0, s) } })) })), w.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], (function (e, t) { w.fn[t] = function (e) { return this.on(t, e) } })), w.fn.extend({ bind: function (e, t, n) { return this.on(e, null, t, n) }, unbind: function (e, t) { return this.off(e, null, t) }, delegate: function (e, t, n, r) { return this.on(t, e, n, r) }, undelegate: function (e, t, n) { return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n) }, hover: function (e, t) { return this.mouseenter(e).mouseleave(t || e) } }), w.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), (function (e, t) { w.fn[t] = function (e, n) { return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t) } })); var Vt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; w.proxy = function (e, t) { var n, r, i; if ("string" == typeof t && (n = e[t], t = e, e = n), h(e)) return r = o.call(arguments, 2), (i = function () { return e.apply(t || this, r.concat(o.call(arguments))) }).guid = e.guid = e.guid || w.guid++, i }, w.holdReady = function (e) { e ? w.readyWait++ : w.ready(!0) }, w.isArray = Array.isArray, w.parseJSON = JSON.parse, w.nodeName = _, w.isFunction = h, w.isWindow = m, w.camelCase = H, w.type = v, w.now = Date.now, w.isNumeric = function (e) { var t = w.type(e); return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e)) }, w.trim = function (e) { return null == e ? "" : (e + "").replace(Vt, "") }; var Zt = e.jQuery, Yt = e.$; return w.noConflict = function (t) { return e.$ === w && (e.$ = Yt), t && e.jQuery === w && (e.jQuery = Zt), w }, void 0 === t && (e.jQuery = e.$ = w), w
    }))
  })); window.$ = window.jQuery = $r, window.$.fn.renameElement = function (e) { const t = []; return this.each((function () { const n = Rn(this, e); t.push(n) })), $r(t) }, window.$.fn.getDfnTitles = function () { return Tn(this[0]) }, window.$.fn.linkTargets = function () { return An(this[0]) }, window.$.fn.makeID = function (e = "", t = "", n = !1) { return _n(this[0], e, t, n) }, window.$.fn.allTextNodes = function (e) { return En(this[0], e) }; var Cr = Object.freeze({ __proto__: null, name: "core/jquery-enhanced" }); var Sr = Object.freeze({ __proto__: null, name: "core/location-hash", run: function () { r("start", "core/location-hash"), location.hash && document.respecIsReady.then(() => { let e = decodeURIComponent(location.hash).substr(1); const t = document.getElementById(e), n = /\W/.test(e); if (!t && n) { const t = e.replace(/[\W]+/gim, "-").replace(/^-+/, "").replace(/-+$/, ""); document.getElementById(t) && (e = t) } location.hash = "#" + e }) } }); const _r = new WeakMap; class Er { constructor(e, t) { _r.set(this, { name: e, lintingFunction: t }) } get name() { return _r.get(this).name } lint(e = { lint: { [this.name]: !1 } }, t = document) { if (function (e, t) { return !(!1 === e.hasOwnProperty("lint") || !1 === e.lint || !e.lint[t]) }(e, this.name)) return _r.get(this).lintingFunction(e, t) } } const Tr = { en: { description: "Document must only contain one `<meta>` tag with charset set to 'utf-8'", howToFix: 'Add this line in your document `<head>` section - `<meta charset="utf-8">` or set charset to "utf-8" if not set already.' } }, Ar = g in Tr ? g : "en"; const Rr = new Er("check-charset", (function (e, t) { const n = t.querySelectorAll("meta[charset]"), r = []; for (const e of n) r.push(e.getAttribute("charset").trim().toLowerCase()); return r.includes("utf-8") && 1 === n.length ? [] : { name: "check-charset", occurrences: n.length, ...Tr[Ar] } })), Lr = "check-internal-slots", Nr = { en: { description: "Internal slots should be preceded by a '.'", howToFix: "Add a '.' between the elements mentioned.", help: "See developer console." } }, Dr = g in Nr ? g : "en"; const Pr = new Er(Lr, (function (e, t) { const n = [...t.querySelectorAll("var+a")].filter(({ previousSibling: { nodeName: e } }) => e && "VAR" === e); if (n.length) return { name: Lr, offendingElements: n, occurrences: n.length, ...Nr[Dr] } })), jr = [".", ":", "!", "?"], Ir = { en: { description: "`p` elements should end with a punctuation mark.", howToFix: `Please make sure \`p\` elements end with one of: ${jr.map(e => `"${e}"`).join(", ")}.` } }, Or = g in Ir ? g : "en"; const qr = new Er("check-punctuation", (function (e, t) { const n = new RegExp(`[${jr.join("")}\\]]$|^ *$`, "m"), r = [...t.querySelectorAll("p:not(#back-to-top)")].filter(e => !n.test(e.textContent.trim())); if (r.length) return { name: "check-punctuation", offendingElements: r, occurrences: r.length, ...Ir[Or] } })), Wr = new WeakMap; const Mr = new class { constructor() { Wr.set(this, { rules: new Set }) } get rules() { return Wr.get(this).rules } register(...e) { e.forEach(e => this.rules.add(e)) } async lint(e, t = window.document) { const n = [...Wr.get(this).rules].map(n => async function (e) { const t = await e; if (!t) return; const n = { ...zr, ...t }, { description: o, help: i, howToFix: s, name: a, occurrences: c, offendingElements: l } = n, u = `Linter (${a}): ${o} ${s} ${i}`; l.length ? dn(l, u + " Occured") : r("warn", `${u} (Count: ${c})`) }(n.lint(e, t))); await n } }, zr = { name: "unknown", description: "", occurrences: 0, howToFix: "", offendingElements: [], help: "" }; var Fr = Object.freeze({ __proto__: null, name: "core/linter", default: Mr, run: function (e) { !1 !== e.lint && (async () => { await document.respecIsReady; try { await Mr.lint(e, document) } catch (e) { console.error("Error ocurred while running the linter", e) } })() } }); const Ur = { en: { description: "Broken local reference found in document.", howToFix: "Please fix the links mentioned.", help: "See developer console." } }, Br = g in Ur ? g : "en"; const Hr = new Er("local-refs-exist", (function (e, t) { const n = [...t.querySelectorAll("a[href^='#']")].filter(Gr); if (n.length) return { name: "local-refs-exist", offendingElements: n, occurrences: n.length, ...Ur[Br] } })); function Gr(e) { const t = e.getAttribute("href").substring(1), n = e.ownerDocument; return !n.getElementById(t) && !n.getElementsByName(t).length } const Vr = "no-headingless-sections", Zr = { en: { description: "All sections must start with a `h2-6` element.", howToFix: "Add a `h2-6` to the offending section or use a `<div>`.", help: "See developer console." }, nl: { description: "Alle secties moeten beginnen met een `h2-6` element.", howToFix: "Voeg een `h2-6` toe aan de conflicterende sectie of gebruik een `<div>`.", help: "Zie de developer console." } }, Yr = g in Zr ? g : "en", Xr = ({ firstElementChild: e }) => null === e || !1 === /^h[1-6]$/.test(e.localName); const Kr = new Er(Vr, (function (e, t) { const n = [...t.querySelectorAll("section")].filter(Xr); if (n.length) return { name: Vr, offendingElements: n, occurrences: n.length, ...Zr[Yr] } })), Jr = { en: { description: "Insecure URLs are not allowed in `respecConfig`.", howToFix: "Please change the following properties to 'https://': " } }, Qr = g in Jr ? g : "en"; const eo = new Er("no-http-props", (function (e, t) { if (!t.location.href.startsWith("http")) return; const n = Object.getOwnPropertyNames(e).filter(e => e.endsWith("URI") || "prevED" === e).filter(n => new URL(e[n], t.location.href).href.startsWith("http://")); if (!n.length) return; const r = { name: "no-http-props", occurrences: n.length, ...Jr[Qr] }; return r.howToFix += n.map(e => `\`${e}\``).join(", ") + ".", r })), to = { en: { description: "Document must a 'Privacy and/or Security' Considerations section.", howToFix: "Add a privacy and/or security considerations section.", help: "See the [Self-Review Questionnaire](https://w3ctag.github.io/security-questionnaire/)." } }, no = g in to ? g : "en"; const ro = new Er("privsec-section", (function (e, t) { if (e.isRecTrack && !function (e) { return Array.from(e.querySelectorAll("h2, h3, h4, h5, h6")).some(({ textContent: e }) => { const t = /(privacy|security)/im.test(e), n = /(considerations)/im.test(e); return t && n || t }) }(t)) return { name: "privsec-section", occurrences: 1, ...to[no] } })); Mr.register(eo, Kr, qr, Hr, Pr, Rr, ro); const oo = { lint: { "no-headingless-sections": !0, "no-http-props": !0, "check-punctuation": !1, "local-refs-exist": !0, "check-internal-slots": !1, "check-charset": !1, "privsec-section": !1 }, pluralize: !0, specStatus: "base", highlightVars: !0, addSectionLinks: !0 }, io = new Wn; function so(e, t) { for (const n of t) io.has(n) || io.set(n, new Set), io.get(n).add(e) } const ao = { en: { description: "Non-existent Web Platform Tests", howToFix: "Please fix the tests mentioned.", help: "See developer console." } }, co = g in ao ? g : "en"; const lo = new Er("wpt-tests-exist", (async function (e, t) { const n = await async function (e, t) { let n; try { const t = new URL(e); if (t.pathname.startsWith("/web-platform-tests/wpt/tree/master/")) { const e = /web-platform-tests\/wpt\/tree\/master\/(.+)/; n = t.pathname.match(e)[1].replace(/\//g, "") } else n = t.pathname.replace(/\//g, "") } catch (e) { return r("warn", "Failed to parse WPT directory from testSuiteURI"), console.error(e), null } const o = new URL("web-platform-tests/wpt/files", t + "/"); o.searchParams.set("path", n); const i = await fetch(o); if (!i.ok) { const e = await i.text(); return r("warn", `Failed to fetch files from WPT repository. Request failed with error: ${e} (${i.status})`), null } const { entries: s } = await i.json(), a = s.filter(e => !e.endsWith("/")); return new Set(a) }(e.testSuiteURI, e.githubAPI); if (!n) return; const o = [], i = new Set, s = [...t.querySelectorAll("[data-tests]")].filter(e => e.dataset.tests); for (const e of s) { const t = e.dataset.tests.split(/,/gm).map(e => e.trim().split("#")[0]).filter(e => e).filter(e => !n.has(e)); t.length && (o.push(e), t.forEach(e => i.add(e))) } if (!o.length) return; const a = [...i].map(e => `\`${e}\``); return { name: "wpt-tests-exist", offendingElements: o, occurrences: o.length, ...ao[co], description: `${ao[co].description}: ${a.join(", ")}.` } })); Mr.register(ro, lo); const uo = { lint: { "privsec-section": !0, "wpt-tests-exist": !1 }, doJsonLd: !1, license: "w3c-software-doc", logos: [{ src: "https://www.w3.org/StyleSheets/TR/2016/logos/W3C", alt: "W3C", height: 48, width: 72, url: "https://www.w3.org/" }], xref: !0 }; var po = Object.freeze({ __proto__: null, name: "w3c/defaults", run: function (e) { const t = !1 !== e.lint && { ...oo.lint, ...uo.lint, ...e.lint }; Object.assign(e, { ...oo, ...uo, ...e, lint: t }), Object.assign(e, { ...Object.fromEntries(io) }) } }); const fo = async function () { const e = document.createElement("style"); return e.id = "respec-mainstyle", e.textContent = await async function () { try { return (await Promise.resolve().then((function () { return yl }))).default } catch { return Gn("respec.css") } }(), document.head.appendChild(e), e }(); var ho = Object.freeze({ __proto__: null, name: "core/style", run: async function (e) { e.noReSpecCSS && (await fo).remove() } }); const mo = [{ hint: "preconnect", href: "https://www.w3.org" }, { hint: "preload", href: "https://www.w3.org/scripts/TR/2016/fixup.js", as: "script" }, { hint: "preload", href: "https://www.w3.org/StyleSheets/TR/2016/base.css", as: "style" }, { hint: "preload", href: "https://www.w3.org/StyleSheets/TR/2016/logos/W3C", as: "image" }].map(ln).reduce((e, t) => (e.appendChild(t), e), document.createDocumentFragment()); mo.appendChild(function () { const e = document.createElement("link"); return e.rel = "stylesheet", e.href = "https://www.w3.org/StyleSheets/TR/2016/base.css", e.classList.add("removeOnSave"), e }()), document.head.querySelector("meta[name=viewport]") || mo.prepend(function () { const e = document.createElement("meta"); return e.name = "viewport", e.content = function (e, t = ", ", n = "=") { return Array.from(Object.entries(e)).map(([e, t]) => `${e}${n}${JSON.stringify(t)}`).join(t) }({ width: "device-width", "initial-scale": "1", "shrink-to-fit": "no" }).replace(/"/g, ""), e }()), document.head.prepend(mo); var go = Object.freeze({ __proto__: null, name: "w3c/style", run: function (e) { if (!e.specStatus) { const t = "`respecConfig.specStatus` missing. Defaulting to 'base'."; e.specStatus = "base", r("warn", t) } let t = "W3C-"; switch (e.specStatus.toUpperCase()) { case "CG-DRAFT": case "CG-FINAL": case "BG-DRAFT": case "BG-FINAL": t = e.specStatus.toLowerCase(); break; case "FPWD": case "LC": case "WD-NOTE": case "LC-NOTE": t += "WD"; break; case "WG-NOTE": case "FPWD-NOTE": t += "WG-NOTE.css"; break; case "UNOFFICIAL": t += "UD"; break; case "FINDING": case "FINDING-DRAFT": case "BASE": t = "base.css"; break; default: t += e.specStatus }const n = function (e) { let t = ""; switch (e) { case null: case !0: t = "2016"; break; default: e && !isNaN(e) && (t = e.toString().trim()) }return t }(e.useExperimentalStyles || "2016"); n && !e.noToc && o("end-all", () => { !function (e, t) { const n = e.createElement("script"); location.hash && n.addEventListener("load", () => { window.location.href = location.hash }, { once: !0 }), n.src = `https://www.w3.org/scripts/TR/${t}/fixup.js`, e.body.appendChild(n) }(document, n) }, { once: !0 }); const i = `https://www.w3.org/StyleSheets/TR/${n ? n + "/" : ""}${t}`; var s; !function (e, t) { const n = [].concat(t).map(t => { const n = e.createElement("link"); return n.rel = "stylesheet", n.href = t, n }).reduce((e, t) => (e.appendChild(t), e), e.createDocumentFragment()); e.head.appendChild(n) }(document, i), o("beforesave", (s = i, e => { const t = e.querySelector(`head link[href="${s}"]`); e.querySelector("head").append(t) })) } }); const bo = {
    en: {
      status_at_publication: Qt`This section describes the status of this
      document at the time of its publication. Other documents may supersede
      this document. A list of current W3C publications and the latest revision
      of this technical report can be found in the
      <a href="https://www.w3.org/TR/">W3C technical reports index</a> at
      https://www.w3.org/TR/.`}, ko: {
      status_at_publication: Qt`       
      .       . W3C   
           https://www.w3.org/TR/ 
      <a href="https://www.w3.org/TR/">W3C technical reports index</a> 
        .`}, zh: {
      status_at_publication: Qt`W3C
      <a href="https://www.w3.org/TR/">W3C</a
      >`}, ja: {
      status_at_publication: Qt`W3C
      <a href="https://www.w3.org/TR/">W3C technical reports index</a>
      (https://www.w3.org/TR/)`}, es: {
      status_at_publication: Qt`Esta seccin describe el estado del presente
      documento al momento de su publicacin. El presente documento puede ser
      remplazado por otros. Una lista de las publicaciones actuales del W3C y la
      ltima revisin del presente informe tcnico puede hallarse en
      http://www.w3.org/TR/
      <a href="https://www.w3.org/TR/">el ndice de informes tcnicos</a> del
      W3C.`}, de: {
      status_at_publication: Qt`Dieser Abschnitt beschreibt den Status des
      Dokuments zum Zeitpunkt der Publikation. Neuere Dokumente knnen dieses
      Dokument obsolet machen. Eine Liste der aktuellen Publikatinen des W3C und
      die aktuellste Fassung dieser Spezifikation kann im
      <a href="https://www.w3.org/TR/">W3C technical reports index</a> unter
      https://www.w3.org/TR/ abgerufen werden.`}
  }; Object.keys(bo).forEach(e => { m[e] || (m[e] = {}), Object.assign(m[e], bo[e]) }); var yo = Object.freeze({ __proto__: null, name: "w3c/l10n" }); let vo, wo; const xo = new Promise((e, t) => { vo = e, wo = e => { r("error", e), t(new Error(e)) } }), ko = yn({ en: { file_a_bug: "File a bug", participate: "Participate", commit_history: "Commit history" }, ko: { participate: "" }, zh: { participate: "", file_a_bug: "" }, ja: { file_a_bug: "", participate: "", commit_history: "" }, nl: { commit_history: "Revisiehistorie", file_a_bug: "Dien een melding in", participate: "Doe mee" }, es: { commit_history: "Historia de cambios", file_a_bug: "Nota un bug", participate: "Participe" }, de: { file_a_bug: "Fehler melden", participate: "Mitmachen", commit_history: "Revisionen" } }); var $o = Object.freeze({ __proto__: null, name: "core/github", github: xo, run: async function (e) { if (!e.hasOwnProperty("github") || !e.github) return void vo(null); if ("object" == typeof e.github && !e.github.hasOwnProperty("repoURL")) { return void wo("Config option `[github](https://github.com/w3c/respec/wiki/github)` is missing property `repoURL`.") } let t, n = e.github.repoURL || e.github; n.endsWith("/") || (n += "/"); try { t = new URL(n, "https://github.com") } catch { return void wo(`\`respecConf.github\` is not a valid URL? (${t})`) } if ("https://github.com" !== t.origin) { return void wo(`\`respecConf.github\` must be HTTPS and pointing to GitHub. (${t})`) } const [o, i] = t.pathname.split("/").filter(e => e); if (!o || !i) { return void wo("`respecConf.github` URL needs a path with, for example, w3c/my-spec") } const s = e.github.branch || "gh-pages", a = new URL("./issues/", t).href, c = { edDraftURI: `https://${o.toLowerCase()}.github.io/${i}/`, githubToken: void 0, githubUser: void 0, issueBase: a, atRiskBase: a, otherLinks: [], pullBase: new URL("./pulls/", t).href, shortName: i }, l = { key: ko.participate, data: [{ value: `GitHub ${o}/${i}`, href: t }, { value: ko.file_a_bug, href: c.issueBase }, { value: ko.commit_history, href: new URL("./commits/" + s, t.href).href }, { value: "Pull requests", href: c.pullBase }] }; let u = "https://respec.org/github"; if (e.githubAPI) if (new URL(e.githubAPI).hostname === window.parent.location.hostname) u = e.githubAPI; else { r("warn", "`respecConfig.githubAPI` should not be added manually.") } const d = { branch: s, repoURL: t.href, apiBase: u, fullName: `${o}/${i}` }; vo(d); const p = { ...c, ...e, github: d, githubAPI: u }; Object.assign(e, p), e.otherLinks.unshift(l) } }); function Co(e, t, n) { const r = document.querySelector(`[data-include-id=${t}]`), o = xn(e, r.dataset.oninclude, n), i = "string" == typeof r.dataset.includeReplace; !function (e, t, { replace: n }) { const { includeFormat: r } = e.dataset; let o = t; if ("markdown" === r) { const r = Pn(e), i = function (e, t) { const n = e.split("\n"); return `${n.shift()}\n${n.map(e => t + e).join("\n")}` }(t, r); o = n ? i : `\n\n${r}${i}\n\n${r}` } "text" === r ? e.textContent = o : e.innerHTML = o, n && e.replaceWith(...e.childNodes) }(r, o, { replace: i }), i || function (e) { ["data-include", "data-include-format", "data-include-replace", "data-include-id", "oninclude"].forEach(t => e.removeAttribute(t)) }(r) } var So = Object.freeze({ __proto__: null, name: "core/data-include", run: async function () { const e = document.querySelectorAll("[data-include]"), t = Array.from(e).map(async e => { const t = e.dataset.include; if (!t) return; const n = "include-" + String(Math.random()).substr(2); e.dataset.includeId = n; try { const e = await fetch(t); Co(await e.text(), n, t) } catch (n) { const o = `\`data-include\` failed: \`${t}\` (${n.message}). See console for details.`; console.error("data-include failed for element: ", e, n), r("error", o) } }); await Promise.all(t) } }); const _o = yn({ en: { default_title: "No Title" }, de: { default_title: "Kein Titel" } }); var Eo = Object.freeze({
    __proto__: null, name: "core/title", run: function (e) {
      const t = document.querySelector("h1#title") || Qt`<h1 id="title"></h1>`; if (t.isConnected && "" === t.textContent.trim()) { pn(t, 'The document is missing a title, so using a default title. To fix this, please give your document a `<title>`. If you need special markup in the document\'s title, please use a `<h1 id="title">`.', "Document is missing a title") } t.id || (t.id = "title"), t.classList.add("title"), function (e, t) {
        t.isConnected || (t.textContent = document.title || "" + _o.default_title); let n = bn(t.textContent); if (e.isPreview && e.prNumber) {
          const r = e.prUrl || `${e.github.repoURL}pull/${e.prNumber}`, { childNodes: o } = Qt`
      Preview of PR <a href="${r}">#${e.prNumber}</a>:
    `; t.prepend(...o), n = `Preview of PR #${e.prNumber}: ${n}`
        } document.title = n, e.title = n
      }(e, t), document.body.prepend(t)
    }
  }); const To = yn({ en: { level: "" } }); var Ao = Object.freeze({ __proto__: null, name: "w3c/level", run: function (e) { if (!e.hasOwnProperty("level")) return; const t = document.querySelector("h1#title"), n = parseInt(e.level); !Number.isInteger(n) || n < 0 ? pn(t, `The \`level\` configuration option must be a number greater or equal to 0. It is currently set to \`${n}\``, "Invalid level config.") : (t.append(` ${To.level} ${n}`), document.title = `${document.title} ${To.level} ${n}`, e.shortName = `${e.shortName}-${n}`, e.level = n) } }), Ro = e => {
    if (!e.key) { const t = "Found a link without `key` attribute in the configuration. See dev console."; return r("warn", t), void console.warn("warn", t, e) } return Qt`
    <dt class="${e.class ? e.class : null}">${e.key}:</dt>
    ${e.data ? e.data.map(Lo) : Lo(e)}
  `}; function Lo(e) {
    return Qt`<dd class="${e.class ? e.class : null}">
    ${e.href ? Qt`<a href="${e.href}">${e.value || e.href}</a>` : e.value}
  </dd>`} var No = e => {
    const t = Qt`<a href="${e.url || ""}" class="logo"></a>`; e.alt || dn(t, "Found spec logo without an `alt` attribute"); const n = Qt`<img
    id="${e.id}"
    alt="${e.alt}"
    width="${e.width}"
    height="${e.height}"
  />`; return n.src = e.src, t.append(n), t
  }; const Do = { en: { until: e => Qt` Until ${e} ` }, es: { until: e => Qt` Hasta ${e} ` }, ko: { until: e => Qt` ${e}  ` }, ja: { until: e => Qt` ${e}  ` }, de: { until: e => Qt` bis ${e} ` } }, Po = g in Do ? g : "en"; var jo = (e = []) => {
    const t = Do[Po]; return e.map((function (e) {
      const r = [e.name], o = [e.company], i = e.w3cid ? parseInt(e.w3cid, 10) : null, s = Qt`<dd
      class="p-author h-card vcard"
      data-editor-id="${i}"
    ></dd>`, a = document.createDocumentFragment(), c = []; e.mailto ? c.push(Qt`<a
        class="ed_mailto u-email email p-name"
        href="${"mailto:" + e.mailto}"
        >${r}</a
      >`) : e.url ? c.push(Qt`<a class="u-url url p-name fn" href="${e.url}">${r}</a>`) : c.push(Qt`<span class="p-name fn">${r}</span>`); e.orcid && c.push(Qt`<a class="p-name orcid" href="${e.orcid}"
          ><svg
            width="16"
            height="16"
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 256 256"
          >
            <style>
              .st1 {
                fill: #fff;
              }
            </style>
            <path
              d="M256 128c0 70.7-57.3 128-128 128S0 198.7 0 128 57.3 0 128 0s128 57.3 128 128z"
              fill="#a6ce39"
            />
            <path
              class="st1"
              d="M86.3 186.2H70.9V79.1h15.4v107.1zM108.9 79.1h41.6c39.6 0 57 28.3 57 53.6 0 27.5-21.5 53.6-56.8 53.6h-41.8V79.1zm15.4 93.3h24.5c34.9 0 42.9-26.5 42.9-39.7C191.7 111.2 178 93 148 93h-23.7v79.4zM88.7 56.8c0 5.5-4.5 10.1-10.1 10.1s-10.1-4.6-10.1-10.1c0-5.6 4.5-10.1 10.1-10.1s10.1 4.6 10.1 10.1z"
            />
          </svg>
        </a>`); e.company && (e.companyURL ? c.push(Qt`
            (<a class="p-org org h-org h-card" href="${e.companyURL}"
              >${o}</a
            >)
          `) : c.push(Qt` (${o}) `)); e.note && c.push(document.createTextNode(` (${e.note})`)); if (e.extras) { const t = e.extras.filter(e => e.name && e.name.trim()).map(n); for (const e of t) c.push(document.createTextNode(", "), e) } if (e.retiredDate) { const n = new Date(e.retiredDate), r = "Invalid Date" !== n.toString(), o = document.createElement("time"); o.textContent = r ? wn(n) : "Invalid Date", r || pn(o, "The date is invalid. The expected format is YYYY-MM-DD.", "Invalid date"), o.dateTime = (l = n, on.format(l)), c.push(Qt` - ${t.until(o)} `) } var l; return Qt.bind(a)`${c}`, s.appendChild(a), s
    })); function n(e) { const t = Qt`<span class="${e.class || null}"></span>`; let n = t; return e.href && (n = Qt`<a href="${e.href}"></a>`, t.appendChild(n)), n.textContent = e.name, t }
  }; const Io = "https://creativecommons.org/licenses/by/4.0/", Oo = "https://www.w3.org/Consortium/Legal/copyright-documents", qo = yn({ en: { author: "Author:", authors: "Authors:", editor: "Editor:", editors: "Editors:", former_editor: "Former editor:", former_editors: "Former editors:", latest_editors_draft: "Latest editor's draft:", latest_published_version: "Latest published version:", edited_in_place: "edited in place", this_version: "This version:" },  uk: { author: ":", authors: ":", editor: ":", editors: ":", former_editor: " :", former_editors: " :", latest_editors_draft: "  :", latest_published_version: "  :", this_version: " :" }, ko: { author: ":", authors: ":", editor: ":", editors: ":", former_editor: " :", former_editors: " :", latest_editors_draft: "  :", latest_published_version: " :", this_version: " :" }, zh: { editor: "", editors: "", former_editor: "", former_editors: "", latest_editors_draft: "", latest_published_version: "", this_version: "" }, ja: { author: "", authors: "", editor: "", editors: "", former_editor: "", former_editors: "", latest_editors_draft: "", latest_published_version: "", this_version: "" }, nl: { author: "Auteur:", authors: "Auteurs:", editor: "Redacteur:", editors: "Redacteurs:", latest_editors_draft: "Laatste werkversie:", latest_published_version: "Laatst gepubliceerde versie:", this_version: "Deze versie:" }, es: { author: "Autor:", authors: "Autores:", editor: "Editor:", editors: "Editores:", latest_editors_draft: "Borrador de editor mas reciente:", latest_published_version: "Versin publicada mas reciente:", this_version: "sta versin:" }, de: { author: "Autor/in:", authors: "Autor/innen:", editor: "Redaktion:", editors: "Redaktion:", former_editor: "Frhere Mitwirkende:", former_editors: "Frhere Mitwirkende:", latest_editors_draft: "Letzter Entwurf:", latest_published_version: "Letzte publizierte Fassung:", this_version: "Diese Fassung:" } }); var Wo = (e, t) => Qt`<div class="head">
    ${e.logos.map(No)} ${document.querySelector("h1#title")}
    ${function (e) { let t = document.querySelector("h2#subtitle"); return t && t.parentElement ? (t.remove(), e.subtitle = t.textContent.trim()) : e.subtitle && (t = document.createElement("h2"), t.textContent = e.subtitle, t.id = "subtitle"), t && t.classList.add("subtitle"), t }(e)}
    <h2>
      ${e.prependW3C ? "W3C " : ""}${e.textStatus}
      <time class="dt-published" datetime="${e.dashDate}"
        >${e.publishHumanDate}</time
      >${e.modificationDate ? Qt`, ${qo.edited_in_place}${" "}
          ${function (e) {
        const t = wn(new Date(e)); return Qt`<time class="dt-modified" datetime="${e}"
    >${t}</time
  >`}(e.modificationDate)}` : ""}
    </h2>
    <dl>
      ${e.isNoTrack ? "" : Qt`
            <dt>${qo.this_version}</dt>
            <dd>
              <a class="u-url" href="${e.thisVersion}"
                >${e.thisVersion}</a
              >
            </dd>
            <dt>${qo.latest_published_version}</dt>
            <dd>
              ${e.latestVersion ? Qt`<a href="${e.latestVersion}"
                    >${e.latestVersion}</a
                  >`: "none"}
            </dd>
          `}
      ${e.edDraftURI ? Qt`
            <dt>${qo.latest_editors_draft}</dt>
            <dd><a href="${e.edDraftURI}">${e.edDraftURI}</a></dd>
          `: ""}
      ${e.testSuiteURI ? Qt`
            <dt>Test suite:</dt>
            <dd><a href="${e.testSuiteURI}">${e.testSuiteURI}</a></dd>
          `: ""}
      ${e.implementationReportURI ? Qt`
            <dt>Implementation report:</dt>
            <dd>
              <a href="${e.implementationReportURI}"
                >${e.implementationReportURI}</a
              >
            </dd>
          `: ""}
      ${e.isED && e.prevED ? Qt`
            <dt>Previous editor's draft:</dt>
            <dd><a href="${e.prevED}">${e.prevED}</a></dd>
          `: ""}
      ${e.showPreviousVersion ? Qt`
            <dt>Previous version:</dt>
            <dd><a href="${e.prevVersion}">${e.prevVersion}</a></dd>
          `: ""}
      ${e.prevRecURI ? e.isRec ? Qt`
            <dt>Previous Recommendation:</dt>
            <dd><a href="${e.prevRecURI}">${e.prevRecURI}</a></dd>
          `: Qt`
            <dt> :</dt>
            <dd><a href="${e.prevRecURI}">${e.prevRecURI}</a></dd>
          `: ""}
      <dt>${e.multipleEditors ? qo.editors : qo.editor}</dt>
      ${jo(e.editors)}
      ${Array.isArray(e.formerEditors) && e.formerEditors.length > 0 ? Qt`
            <dt>
              ${e.multipleFormerEditors ? qo.former_editors : qo.former_editor}
            </dt>
            ${jo(e.formerEditors)}
          `: ""}
      ${e.authors ? Qt`
            <dt>
              ${e.multipleAuthors ? qo.authors : qo.author}
            </dt>
            ${jo(e.authors)}
          `: ""}
      ${e.otherLinks ? e.otherLinks.map(Ro) : ""}
    </dl>
    ${e.errata ? Qt`<p>
          Please check the
          <a href="${e.errata}"><strong>errata</strong></a> for any errors or
          issues reported since publication.
        </p>`: ""}
    ${e.isRec ? Qt`<p>
          See also
          <a
            href="${"http://www.w3.org/2003/03/Translations/byTechnology?technology=" + e.shortName}"
          >
            <strong>translations</strong></a
          >.
        </p>`: ""}
    ${e.alternateFormats ? Qt`<p>
          ${t.multipleAlternates ? "This document is also available in these non-normative formats:" : "This document is also available in this non-normative format:"}
          ${t.alternatesHTML}
        </p>`: ""}
    ${function (e) {
      const t = document.querySelector(".copyright"); if (t) return t.remove(), t; if (e.hasOwnProperty("overrideCopyright")) { r("warn", 'The `overrideCopyright` configuration option is deprecated. Please use `<p class="copyright">` instead.') } return e.isUnofficial ? e.additionalCopyrightHolders ? Qt`<p class="copyright">${[e.additionalCopyrightHolders]}</p>` : e.overrideCopyright ? [e.overrideCopyright] : Qt`<p class="copyright">
          This document is licensed under a
          ${Mo("Creative Commons Attribution 4.0 License", Io, "subfoot")}.
        </p>`: e.overrideCopyright ? [e.overrideCopyright] : function (e) {
        return Qt`<p class="copyright">
    <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright"
      >Copyright</a
    >
    &copy;
    ${e.copyrightStart ? e.copyrightStart + "-" : ""}${e.publishYear}
    ${e.additionalCopyrightHolders ? Qt` ${[e.additionalCopyrightHolders]} &amp; ` : ""}
    <a href="https://www.w3.org/"
      ><abbr title="World Wide Web Consortium">W3C</abbr></a
    ><sup>&reg;</sup> (<a href="https://www.csail.mit.edu/"
      ><abbr title="Massachusetts Institute of Technology">MIT</abbr></a
    >,
    <a href="https://www.ercim.eu/"
      ><abbr
        title="European Research Consortium for Informatics and Mathematics"
        >ERCIM</abbr
      ></a
    >, <a href="https://www.keio.ac.jp/">Keio</a>,
    <a href="https://ev.buaa.edu.cn/">Beihang</a>). ${function (e) {
            if (!e.isCCBY) return; return Qt`
    Some Rights Reserved: this document is dual-licensed,
    ${Mo("CC-BY", Io)} and
    ${Mo("W3C Document License", Oo)}.
  `}(e)}
    W3C <a href="${"https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer"}">liability</a>,
    <a href="${"https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks"}">trademark</a> and ${function (e) { if (e.isCCBY) return Mo("document use", "https://www.w3.org/Consortium/Legal/2013/copyright-documents-dual.html"); if (e.isW3CSoftAndDocLicense) return Mo("permissive document license", "https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document"); return Mo("document use", Oo) }(e)} rules
    apply.
  </p>`}(e)
    }(e)}
    <hr title="Separator for header" />
  </div>`; function Mo(e, t, n) { return Qt`<a rel="license" href="${t}" class="${n}">${e}</a>` } var zo = (e, t) => {
    const n = document.querySelector(".copyright"); n && n.remove(); const r = document.querySelector("h1#title"), o = r.cloneNode(!0); return Qt`<div class="head">
    ${e.logos.map(No)} ${r}
    ${e.subtitle ? Qt`<h2 id="subtitle">${e.subtitle}</h2>` : ""}
    <h2>
      ${e.longStatus}
      <time class="dt-published" datetime="${e.dashDate}"
        >${e.publishHumanDate}</time
      >
    </h2>
    <dl>
      ${e.thisVersion ? Qt`
            <dt>${qo.this_version}</dt>
            <dd>
              <a class="u-url" href="${e.thisVersion}"
                >${e.thisVersion}</a
              >
            </dd>
          `: ""}
      ${e.latestVersion ? Qt`
            <dt>${qo.latest_published_version}</dt>
            <dd>
              <a href="${e.latestVersion}">${e.latestVersion}</a>
            </dd>
          `: ""}
      ${e.edDraftURI ? Qt`
            <dt>${qo.latest_editors_draft}</dt>
            <dd><a href="${e.edDraftURI}">${e.edDraftURI}</a></dd>
          `: ""}
      ${e.testSuiteURI ? Qt`
            <dt>Test suite:</dt>
            <dd><a href="${e.testSuiteURI}">${e.testSuiteURI}</a></dd>
          `: ""}
      ${e.implementationReportURI ? Qt`
            <dt>Implementation report:</dt>
            <dd>
              <a href="${e.implementationReportURI}"
                >${e.implementationReportURI}</a
              >
            </dd>
          `: ""}
      ${e.prevVersion ? Qt`
            <dt>Previous version:</dt>
            <dd><a href="${e.prevVersion}">${e.prevVersion}</a></dd>
          `: ""}
      ${e.isCGFinal ? "" : Qt`
            ${e.prevED ? Qt`
                  <dt>Previous editor's draft:</dt>
                  <dd><a href="${e.prevED}">${e.prevED}</a></dd>
                `: ""}
          `}
      <dt>${e.multipleEditors ? qo.editors : qo.editor}</dt>
      ${jo(e.editors)}
      ${Array.isArray(e.formerEditors) && e.formerEditors.length > 0 ? Qt`
            <dt>
              ${e.multipleFormerEditors ? qo.former_editors : qo.former_editor}
            </dt>
            ${jo(e.formerEditors)}
          `: ""}
      ${e.authors ? Qt`
            <dt>
              ${e.multipleAuthors ? qo.authors : qo.author}
            </dt>
            ${jo(e.authors)}
          `: ""}
      ${e.otherLinks ? e.otherLinks.map(Ro) : ""}
    </dl>
    ${e.alternateFormats ? Qt`<p>
          ${t.multipleAlternates ? "This document is also available in these non-normative formats:" : "This document is also available in this non-normative format:"}
          ${t.alternatesHTML}
        </p>`: ""}
    ${n || Qt`<p class="copyright">
          <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright"
            >Copyright</a
          >
          &copy;
          ${e.copyrightStart ? e.copyrightStart + "-" : ""}${e.publishYear}
          ${e.additionalCopyrightHolders ? Qt` ${[e.additionalCopyrightHolders]} &amp; ` : ""}
          the Contributors to the ${o.childNodes}
          Specification, published by the
          <a href="${e.wgURI}">${e.wg}</a> under the
          ${e.isCGFinal ? Qt`
                <a href="https://www.w3.org/community/about/agreements/fsa/"
                  >W3C Community Final Specification Agreement (FSA)</a
                >. A human-readable
                <a
                  href="https://www.w3.org/community/about/agreements/fsa-deed/"
                  >summary</a
                >
                is available.
              `: Qt`
                <a href="https://www.w3.org/community/about/agreements/cla/"
                  >W3C Community Contributor License Agreement (CLA)</a
                >. A human-readable
                <a
                  href="https://www.w3.org/community/about/agreements/cla-deed/"
                  >summary</a
                >
                is available.
              `}
        </p>`}
    <hr title="Separator for header" />
  </div>`}; const Fo = yn({ en: { sotd: "Status of This Document" }, ko: { sotd: "  " }, zh: { sotd: "" }, ja: { sotd: "" }, nl: { sotd: "Status van dit document" }, es: { sotd: "Estado de este Document" }, de: { sotd: "Status dieses Dokuments" }, uk: { sotd: " " } }); var Uo = (e, t) => Qt`
    <h2>${Fo.sotd}</h2>
    ${e.isPreview ? function (e) {
      const { prUrl: t, prNumber: n, edDraftURI: r } = e; return Qt`<details class="annoying-warning" open="">
    <summary
      >This is a
      preview${t && n ? Qt`
            of pull request
            <a href="${t}">#${n}</a>
          `: ""}</summary
    >
    <p>
      Do not attempt to implement this version of the specification. Do not
      reference this version as authoritative in any way.
      ${r ? Qt`
            Instead, see
            <a href="${r}">${r}</a> for the Editor's draft.
          `: ""}
    </p>
  </details>`}(e) : ""}
    ${e.isUnofficial ? function (e) {
      const { additionalContent: t } = e; return Qt`
    <p>
      This document is draft of a potential specification. It has no official
      standing of any kind and does not represent the support or consensus of
      any standards organization.
    </p>
    ${t}
  `}(t) : e.isTagFinding ? t.additionalContent : e.isNoTrack ? function (e, t) {
      const { isMO: n } = e, { additionalContent: r } = t; return Qt`
    <p>
      This document is merely a W3C-internal
      ${n ? "member-confidential" : ""} document. It has no official standing
      of any kind and does not represent consensus of the W3C Membership.
    </p>
    ${r}
  `}(e, t) : Qt`
          <p><em>${e.l10n.status_at_publication}</em></p>
          ${e.isSubmission ? function (e, t) {
        return Qt`
    ${t.additionalContent}
    ${e.isMemberSubmission ? function (e) {
            const t = `https://www.w3.org/Submission/${e.publishDate.getUTCFullYear()}/${e.submissionCommentNumber}/Comment/`; return Qt`<p>
    By publishing this document, W3C acknowledges that the
    <a href="${e.thisVersion}">Submitting Members</a> have made a formal
    Submission request to W3C for discussion. Publication of this document by
    W3C indicates no endorsement of its content by W3C, nor that W3C has, is, or
    will be allocating any resources to the issues addressed by it. This
    document is not the product of a chartered W3C group, but is published as
    potential input to the
    <a href="https://www.w3.org/Consortium/Process">W3C Process</a>. A
    <a href="${t}">W3C Team Comment</a> has been published in
    conjunction with this Member Submission. Publication of acknowledged Member
    Submissions at the W3C site is one of the benefits of
    <a href="https://www.w3.org/Consortium/Prospectus/Joining">
      W3C Membership</a
    >. Please consult the requirements associated with Member Submissions of
    <a href="https://www.w3.org/Consortium/Patent-Policy/#sec-submissions"
      >section 3.3 of the W3C Patent Policy</a
    >. Please consult the complete
    <a href="https://www.w3.org/Submission"
      >list of acknowledged W3C Member Submissions</a
    >.
  </p>`}(e) : e.isTeamSubmission ? function (e, t) {
            return Qt`
    <p>
      If you wish to make comments regarding this document, please send them to
      <a href="${t.mailToWGPublicListWithSubject}"
        >${e.wgPublicList}@w3.org</a
      >
      (<a href="${t.mailToWGPublicListSubscription}">subscribe</a>,
      <a href="${`https://lists.w3.org/Archives/Public/${e.wgPublicList}/`}"
        >archives</a
      >)${e.subjectPrefix ? Qt`
            with <code>${e.subjectPrefix}</code> at the start of your email's
            subject
          `: ""}.
    </p>
    <p>
      Please consult the complete
      <a href="https://www.w3.org/TeamSubmission/">list of Team Submissions</a>.
    </p>
  `}(e, t) : ""}
  `}(e, t) : Qt`
                ${e.sotdAfterWGinfo ? "" : t.additionalContent}
                ${e.overrideStatus ? "" : Qt`
                      ${function (e) {
            if (!e.wg) return; return Qt`<p>
    This document was published by ${e.wgHTML} as ${e.anOrA}
    ${e.longStatus}.
    ${e.notYetRec ? "This document is intended to become a W3C Recommendation." : ""}
  </p>`}(e)} ${function (e, t) {
            if (!e.github && !e.wgPublicList) return; return Qt`<p>
    ${e.github ? Qt`
          <a href="${e.issueBase}">GitHub Issues</a> are preferred for
          discussion of this specification.
        `: ""}
    ${e.wgPublicList ? Qt`
          ${e.github && e.wgPublicList ? "Alternatively, you can send comments to our mailing list." : "Comments regarding this document are welcome."}
          Please send them to
          <a href="${t.mailToWGPublicListWithSubject}"
            >${e.wgPublicList}@w3.org</a
          >
          (<a
            href="${`https://lists.w3.org/Archives/Public/${e.wgPublicList}/`}"
            >archives</a
          >)${e.subjectPrefix ? Qt`
                with <code>${e.subjectPrefix}</code> at the start of your
                email's subject
              `: ""}.
        `: ""}
  </p>`}(e, t)}
                      ${e.isCR || e.isPER || e.isPR ? Qt`<p>
                            ${e.isCR ? `\n                  W3C publishes a Candidate Recommendation to indicate that the document is believed to be\n                  stable and to encourage implementation by the developer community. This Candidate\n                  Recommendation is expected to advance to Proposed Recommendation no earlier than\n                  ${e.humanCREnd}.\n                ` : ""}
                            ${e.isPER ? Qt`
                                  W3C Advisory Committee Members are invited to
                                  send formal review comments on this Proposed
                                  Edited Recommendation to the W3C Team until
                                  ${e.humanPEREnd}. Members of the Advisory
                                  Committee will find the appropriate review
                                  form for this document by consulting their
                                  list of current
                                  <a
                                    href="https://www.w3.org/2002/09/wbs/myQuestionnaires"
                                    >WBS questionnaires</a
                                  >.
                                `: ""}
                            ${e.isPR ? Qt`
                                  The W3C Membership and other interested
                                  parties are invited to review the document and
                                  send comments to
                                  <a
                                    rel="discussion"
                                    href="${t.mailToWGPublicList}"
                                    >${e.wgPublicList}@w3.org</a
                                  >
                                  (<a
                                    href="${t.mailToWGPublicListSubscription}"
                                    >subscribe</a
                                  >,
                                  <a
                                    href="${`https://lists.w3.org/Archives/Public/${e.wgPublicList}/`}"
                                    >archives</a
                                  >) through ${e.humanPREnd}. Advisory
                                  Committee Representatives should consult their
                                  <a
                                    href="https://www.w3.org/2002/09/wbs/myQuestionnaires"
                                    >WBS questionnaires</a
                                  >. Note that substantive technical comments
                                  were expected during the Candidate
                                  Recommendation review period that ended
                                  ${e.humanCREnd}.
                                `: ""}
                          </p>`: ""}
                    `}
                ${e.implementationReportURI ? function (e) {
          const { implementationReportURI: t } = e; return Qt`<p>
    Please see the Working Group's
    <a href="${t}">implementation report</a>.
  </p>`}(e) : ""}
                ${e.sotdAfterWGinfo ? t.additionalContent : ""}
                ${e.isRec ? Qt`<p>
    This document has been reviewed by W3C Members, by software developers, and
    by other W3C groups and interested parties, and is endorsed by the Director
    as a W3C Recommendation. It is a stable document and may be used as
    reference material or cited from another document. W3C's role in making the
    Recommendation is to draw attention to the specification and to promote its
    widespread deployment. This enhances the functionality and interoperability
    of the Web.
  </p>`: function ({ anOrA: e, textStatus: t }) {
          return Qt`<p>
    Publication as ${e} ${t} does not imply endorsement by the W3C
    Membership. This is a draft document and may be updated, replaced or
    obsoleted by other documents at any time. It is inappropriate to cite this
    document as other than work in progress.
  </p>`}(e)}
                ${function (e) {
          const { isNote: t, wgId: n, isIGNote: r, multipleWGs: o, recNotExpected: i, wgPatentHTML: s, wgPatentURI: a, charterDisclosureURI: c } = e, l = r ? "" : Qt`
        This document was produced by ${o ? "groups" : "a group"}
        operating under the
        <a href="https://www.w3.org/Consortium/Patent-Policy/"
          >W3C Patent Policy</a
        >.
      `; return Qt`<p data-deliverer="${t ? n : null}">
    ${l} ${i ? "The group does not expect this document to become a W3C Recommendation." : ""}
    ${t || r ? "" : Qt`
          ${o ? Qt` W3C maintains ${s} ` : Qt`
                W3C maintains a
                <a href="${[a]}" rel="disclosure"
                  >public list of any patent disclosures</a
                >
              `}
          made in connection with the deliverables of
          ${o ? "each group; these pages also include" : "the group; that page also includes"}
          instructions for disclosing a patent. An individual who has actual
          knowledge of a patent which the individual believes contains
          <a href="https://www.w3.org/Consortium/Patent-Policy/#def-essential"
            >Essential Claim(s)</a
          >
          must disclose the information in accordance with
          <a href="https://www.w3.org/Consortium/Patent-Policy/#sec-Disclosure"
            >section 6 of the W3C Patent Policy</a
          >.
        `}
    ${r ? Qt`
          The disclosure obligations of the Participants of this group are
          described in the
          <a href="${c}">charter</a>.
        `: ""}
  </p>`}(e)}
                <p>
                  This document is governed by the
                  <a
                    id="w3c_process_revision"
                    href="https://www.w3.org/2019/Process-20190301/"
                    >1 March 2019 W3C Process Document</a
                  >.
                </p>
                ${e.addPatentNote ? Qt`<p>${[e.addPatentNote]}</p>` : ""}
              `}
        `}
    ${t.additionalSections}
  `; var Bo = (e, t) => Qt`
    <h2>${Fo.sotd}</h2>
    ${e.isPreview ? Qt`<details class="annoying-warning" open="">
          <summary
            >This is a
            preview${e.prUrl && e.prNumber ? Qt`
                  of pull request
                  <a href="${e.prUrl}">#${e.prNumber}</a>
                `: ""}</summary
          >
          <p>
            Do not attempt to implement this version of the specification. Do
            not reference this version as authoritative in any way.
            ${e.edDraftURI ? Qt`
                  Instead, see
                  <a href="${e.edDraftURI}">${e.edDraftURI}</a> for the
                  Editor's draft.
                `: ""}
          </p>
        </details>`: ""}
    <p>
      This specification was published by the
      <a href="${e.wgURI}">${e.wg}</a>. It is not a W3C Standard nor is it
      on the W3C Standards Track.
      ${e.isCGFinal ? Qt`
            Please note that under the
            <a href="https://www.w3.org/community/about/agreements/final/"
              >W3C Community Final Specification Agreement (FSA)</a
            >
            other conditions apply.
          `: Qt`
            Please note that under the
            <a href="https://www.w3.org/community/about/agreements/cla/"
              >W3C Community Contributor License Agreement (CLA)</a
            >
            there is a limited opt-out and other conditions apply.
          `}
      Learn more about
      <a href="https://www.w3.org/community/"
        >W3C Community and Business Groups</a
      >.
    </p>
    ${e.sotdAfterWGinfo ? "" : t.additionalContent}
    ${e.wgPublicList ? Qt`<p>
          If you wish to make comments regarding this document, please send them
          to
          <a href="${t.mailToWGPublicListWithSubject}"
            >${e.wgPublicList}@w3.org</a
          >
          (<a href="${t.mailToWGPublicListSubscription}">subscribe</a>,
          <a
            href="${`https://lists.w3.org/Archives/Public/${e.wgPublicList}/`}"
            >archives</a
          >)${e.subjectPrefix ? Qt`
                with <code>${e.subjectPrefix}</code> at the start of your
                email's subject
              `: ""}.
        </p>`: ""}
    ${e.sotdAfterWGinfo ? t.additionalContent : ""}
    ${t.additionalSections}
  `; const Ho = new Intl.DateTimeFormat(["en-AU"], { timeZone: "UTC", year: "numeric", month: "long", day: "2-digit" }), Go = { LS: "WD", LD: "WD", FPWD: "WD", LC: "WD", FPLC: "WD", "FPWD-NOTE": "NOTE", "WD-NOTE": "WD", "LC-NOTE": "LC", "IG-NOTE": "NOTE", "WG-NOTE": "NOTE" }, Vo = { NOTE: "w3p:NOTE", WD: "w3p:WD", LC: "w3p:LastCall", CR: "w3p:CR", PR: "w3p:PR", REC: "w3p:REC", PER: "w3p:PER", RSCND: "w3p:RSCND" }, Zo = { NOTE: "Working Group Note", "WG-NOTE": "Working Group Note", "CG-NOTE": "Co-ordination Group Note", "IG-NOTE": "Interest Group Note", "Member-SUBM": "Member Submission", "Team-SUBM": "Team Submission", MO: "Member-Only Document", ED: "Editor's Draft", LS: "Living Standard", LD: "Living Document", FPWD: "First Public Working Draft", WD: "Working Draft", "FPWD-NOTE": "Working Group Note", "WD-NOTE": "Working Draft", "LC-NOTE": "Working Draft", FPLC: "First Public and Last Call Working Draft", LC: "Last Call Working Draft", CR: "Candidate Recommendation", PR: "Proposed Recommendation", PER: "Proposed Edited Recommendation", REC: "Recommendation", RSCND: "Rescinded Recommendation", unofficial: "Unofficial Draft", base: "Document", finding: "TAG Finding", "draft-finding": "Draft TAG Finding", "CG-DRAFT": "Draft Community Group Report", "CG-FINAL": "Final Community Group Report", "BG-DRAFT": "Draft Business Group Report", "BG-FINAL": "Final Business Group Report" }, Yo = { ...Zo, "FPWD-NOTE": "First Public Working Group Note", "LC-NOTE": "Last Call Working Draft" }, Xo = ["FPWD", "WD"], Ko = ["FPLC", "LC", "CR", "PR", "PER", "REC"], Jo = ["base", "BG-DRAFT", "BG-FINAL", "CG-DRAFT", "CG-FINAL", "draft-finding", "finding", "MO", "unofficial"], Qo = ["CG-DRAFT", "CG-FINAL", "BG-DRAFT", "BG-FINAL"], ei = ["ED", "IG-NOTE"], ti = { cc0: { name: "Creative Commons 0 Public Domain Dedication", short: "CC0", url: "https://creativecommons.org/publicdomain/zero/1.0/" }, "w3c-software": { name: "W3C Software Notice and License", short: "W3C Software", url: "https://www.w3.org/Consortium/Legal/2002/copyright-software-20021231" }, "w3c-software-doc": { name: "W3C Software and Document Notice and License", short: "W3C Software and Document", url: "https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document" }, "cc-by": { name: "Creative Commons Attribution 4.0 International Public License", short: "CC-BY", url: "https://creativecommons.org/licenses/by/4.0/legalcode" } }, ni = Object.freeze({ id: "", alt: "", href: "", src: "", height: "48", width: "72" }); function ri(e, t, n = new Date) { const o = e[t] ? new Date(e[t]) : new Date(n); if (Number.isFinite(o.valueOf())) { const e = on.format(o); return new Date(e) } return r("error", `[\`${t}\`](https://github.com/w3c/respec/wiki/${t}) is not a valid date: "${e[t]}". Expected format 'YYYY-MM-DD'.`), new Date(on.format(new Date)) } function oi(e, { isTagFinding: t = !1 }) { const n = e.cloneNode(!0), o = document.createDocumentFragment(); for (; n.hasChildNodes() && (n.firstChild.nodeType !== Node.ELEMENT_NODE || "section" !== n.firstChild.localName);)o.appendChild(n.firstChild); return t && !o.hasChildNodes() && r("warn", "ReSpec does not support automated SotD generation for TAG findings, please add the prerequisite content in the 'sotd' section"), { additionalContent: o, additionalSections: n.childNodes } } var ii = Object.freeze({
            __proto__: null, name: "w3c/headers", run: function (e) {
              if (e.isUnofficial = "unofficial" === e.specStatus, e.isUnofficial && !Array.isArray(e.logos) && (e.logos = []), e.isCCBY = "cc-by" === e.license, e.isW3CSoftAndDocLicense = "w3c-software-doc" === e.license, ["cc-by"].includes(e.license)) { let t = `You cannot use license "\`${e.license}\`" with W3C Specs. `; t += 'Please set `respecConfig.license: "w3c-software-doc"` instead.', r("error", t) } if (e.licenseInfo = ti[e.license], e.isCGBG = Qo.includes(e.specStatus), e.isCGFinal = e.isCGBG && e.specStatus.endsWith("G-FINAL"), e.isBasic = "base" === e.specStatus, e.isRegular = !e.isCGBG && !e.isBasic, e.specStatus || r("error", "Missing required configuration: `specStatus`"), e.isRegular && !e.shortName && r("error", "Missing required configuration: `shortName`"), e.testSuiteURI) { const t = new URL(e.testSuiteURI, location.href), { host: n, pathname: o } = t; if ("github.com" === n && o.startsWith("/w3c/web-platform-tests/")) { r("warn", `Web Platform Tests have moved to a new Github Organization at https://github.com/web-platform-tests. Please update your [\`testSuiteURI\`](https://github.com/w3c/respec/wiki/testSuiteURI) to point to the new tests repository (e.g., https://github.com/web-platform-tests/wpt/${e.shortName} ).`) } } if (e.subtitle || (e.subtitle = ""), e.publishDate = ri(e, "publishDate", document.lastModified), e.publishYear = e.publishDate.getUTCFullYear(), e.publishHumanDate = Ho.format(e.publishDate), e.isNoTrack = Jo.includes(e.specStatus), e.isRecTrack = !e.noRecTrack && Ko.concat(Xo).includes(e.specStatus), e.isMemberSubmission = "Member-SUBM" === e.specStatus, e.isMemberSubmission) { const t = { alt: "W3C Member Submission", href: "https://www.w3.org/Submission/", src: "https://www.w3.org/Icons/member_subm-v.svg", width: "211" }; e.logos.push({ ...ni, ...t }) } if (e.isTeamSubmission = "Team-SUBM" === e.specStatus, e.isTeamSubmission) { const t = { alt: "W3C Team Submission", href: "https://www.w3.org/TeamSubmission/", src: "https://www.w3.org/Icons/team_subm-v.svg", width: "211" }; e.logos.push({ ...ni, ...t }) } e.isSubmission = e.isMemberSubmission || e.isTeamSubmission, e.anOrA = ei.includes(e.specStatus) ? "an" : "a", e.isTagFinding = "finding" === e.specStatus || "draft-finding" === e.specStatus, e.edDraftURI || (e.edDraftURI = "", "ED" === e.specStatus && r("warn", "Editor's Drafts should set edDraftURI.")), e.maturity = Go[e.specStatus] ? Go[e.specStatus] : e.specStatus; let t = "TR"; if ("Member-SUBM" === e.specStatus ? t = "Submission" : "Team-SUBM" === e.specStatus && (t = "TeamSubmission"), e.isRegular && (e.thisVersion = `https://www.w3.org/${t}/${e.publishDate.getUTCFullYear()}/${e.maturity}-${e.shortName}-${vn(e.publishDate)}/`), "ED" === e.specStatus && (e.thisVersion = e.edDraftURI), e.isRegular && (e.latestVersion = `https://www.w3.org/${t}/${e.shortName}/`), e.isTagFinding && (e.latestVersion = "https://www.w3.org/2001/tag/doc/" + e.shortName, e.thisVersion = `${e.latestVersion}-${on.format(e.publishDate)}`), e.previousPublishDate) { e.previousMaturity || e.isTagFinding || r("error", "`previousPublishDate` is set, but not `previousMaturity`."), e.previousPublishDate = ri(e, "previousPublishDate"); const t = Go[e.previousMaturity] ? Go[e.previousMaturity] : e.previousMaturity; e.isTagFinding ? e.prevVersion = `${e.latestVersion}-${on.format(e.previousPublishDate)}` : e.isCGBG ? e.prevVersion = e.prevVersion || "" : e.isBasic ? e.prevVersion = "" : e.prevVersion = `https://www.w3.org/TR/${e.previousPublishDate.getUTCFullYear()}/${t}-${e.shortName}-${vn(e.previousPublishDate)}/` } else e.specStatus.endsWith("NOTE") || "FPWD" === e.specStatus || "FPLC" === e.specStatus || "ED" === e.specStatus || e.noRecTrack || e.isNoTrack || e.isSubmission || r("error", "Document on track but no previous version: Add `previousMaturity`, and `previousPublishDate` to ReSpec's config."), e.prevVersion || (e.prevVersion = ""); e.prevRecShortname && !e.prevRecURI && (e.prevRecURI = "https://www.w3.org/TR/" + e.prevRecShortname); const n = function (e) { if (e.name || r("error", "All authors and editors must have a name."), e.orcid) try { e.orcid = function (e) { const t = new URL(e, "https://orcid.org/"); if ("https://orcid.org" !== t.origin) throw new Error(`The origin should be "https://orcid.org", not "${t.origin}".`); const n = t.pathname.slice(1).replace(/\/$/, ""); if (!/^\d{4}-\d{4}-\d{4}-\d{3}(\d|X)$/.test(n)) throw new Error(`ORCIDs have the format "1234-1234-1234-1234", not "${n}"`); const r = n[n.length - 1], o = (12 - n.split("").slice(0, -1).filter(e => /\d/.test(e)).map(Number).reduce((e, t) => 2 * (e + t), 0) % 11) % 11, i = 10 === o ? "X" : String(o); if (r !== i) throw new Error(`"${n}" has an invalid checksum.`); return t.href }(e.orcid) } catch (t) { r("error", `"${e.orcid}" is not an ORCID. ${t.message}`), delete e.orcid } }; if (e.formerEditors || (e.formerEditors = []), e.editors) { e.editors.forEach(n); for (let t = 0; t < e.editors.length; t++) { const n = e.editors[t]; "retiredDate" in n && (e.formerEditors.push(n), e.editors.splice(t--, 1)) } } e.editors && 0 !== e.editors.length || r("error", "At least one editor is required"), e.formerEditors.length && e.formerEditors.forEach(n), e.authors && e.authors.forEach(n), e.multipleEditors = e.editors && e.editors.length > 1, e.multipleFormerEditors = e.formerEditors.length > 1, e.multipleAuthors = e.authors && e.authors.length > 1, (e.alternateFormats || []).forEach(e => { e.uri && e.label || r("error", "All alternate formats must have a uri and a label.") }), e.copyrightStart && e.copyrightStart == e.publishYear && (e.copyrightStart = ""), e.longStatus = Yo[e.specStatus], e.textStatus = Zo[e.specStatus], Vo[e.specStatus] && (e.rdfStatus = Vo[e.specStatus]), e.showThisVersion = !e.isNoTrack || e.isTagFinding, e.showPreviousVersion = "FPWD" !== e.specStatus && "FPLC" !== e.specStatus && "ED" !== e.specStatus && !e.isNoTrack && !e.isSubmission, e.specStatus.endsWith("NOTE") && !e.prevVersion && (e.showPreviousVersion = !1), e.isTagFinding && (e.showPreviousVersion = !!e.previousPublishDate), e.notYetRec = e.isRecTrack && "REC" !== e.specStatus, e.isRec = e.isRecTrack && "REC" === e.specStatus, e.isRec && !e.errata && r("error", "Recommendations must have an errata link."), e.prependW3C = !e.isUnofficial, e.isED = "ED" === e.specStatus, e.isCR = "CR" === e.specStatus, e.isPR = "PR" === e.specStatus, e.isPER = "PER" === e.specStatus, e.isMO = "MO" === e.specStatus, e.isNote = ["FPWD-NOTE", "WG-NOTE"].includes(e.specStatus), e.isIGNote = "IG-NOTE" === e.specStatus, e.dashDate = on.format(e.publishDate), e.publishISODate = e.publishDate.toISOString(), e.shortISODate = on.format(e.publishDate), e.hasOwnProperty("wgPatentURI") && !Array.isArray(e.wgPatentURI) ? Object.defineProperty(e, "wgId", { get() { const e = this.wgPatentURI.split("/"), t = e.findIndex(e => "pp-impl" === e) + 1; return e[t] || "" } }) : e.wgId = e.wgId ? e.wgId : ""; const o = {
                get multipleAlternates() { return e.alternateFormats && e.alternateFormats.length > 1 }, get alternatesHTML() {
                  return e.alternateFormats && Cn(e.alternateFormats, e => {
                    const t = e.hasOwnProperty("lang") && e.lang ? e.lang : null, n = e.hasOwnProperty("type") && e.type ? e.type : null; return Qt`<a
            rel="alternate"
            href="${e.uri}"
            hreflang="${t}"
            type="${n}"
            >${e.label}</a
          >`})
                }
              }, i = (e.isCGBG ? zo : Wo)(e, o); document.body.prepend(i), document.body.classList.add("h-entry"); const s = document.getElementById("sotd") || document.createElement("section"); !e.isCGBG && e.isNoTrack && !e.isTagFinding || s.id || r("error", "A custom SotD paragraph is required for your type of document."), s.id = s.id || "sotd", s.classList.add("introductory"); const a = [e.wg, e.wgURI, e.wgPatentURI]; if (a.some(e => Array.isArray(e)) && !a.every(e => Array.isArray(e)) && r("error", "If one of '`wg`', '`wgURI`', or '`wgPatentURI`' is an array, they all have to be."), e.isCGBG && !e.wg && r("error", "[`wg`](https://github.com/w3c/respec/wiki/wg) configuration option is required for this kind of document."), Array.isArray(e.wg)) {
                e.multipleWGs = e.wg.length > 1, e.wgHTML = Cn(e.wg, (t, n) => Qt`the <a href="${e.wgURI[n]}">${t}</a>`); const t = []; for (let n = 0, r = e.wg.length; n < r; n++)t.push(Qt`a
          <a href="${e.wgPatentURI[n]}" rel="disclosure"
            >public list of any patent disclosures (${e.wg[n]})</a
          >`); e.wgPatentHTML = Cn(t)
              } else e.multipleWGs = !1, e.wg && (e.wgHTML = Qt`the <a href="${e.wgURI}">${e.wg}</a>`); "PR" !== e.specStatus || e.crEnd || r("error", '`specStatus` is "PR" but no `crEnd` is specified (needed to indicate end of previous CR).'), "CR" !== e.specStatus || e.crEnd || r("error", '`specStatus` is "CR", but no `crEnd` is specified in Respec config.'), e.crEnd = ri(e, "crEnd"), e.humanCREnd = Ho.format(e.crEnd), "PR" !== e.specStatus || e.prEnd || r("error", '`specStatus` is "PR" but no `prEnd` is specified.'), e.prEnd = ri(e, "prEnd"), e.humanPREnd = Ho.format(e.prEnd), "PER" !== e.specStatus || e.perEnd || r("error", "Status is PER but no perEnd is specified"), e.perEnd = ri(e, "perEnd"), e.humanPEREnd = Ho.format(e.perEnd), e.recNotExpected = !(!e.noRecTrack && !e.recNotExpected) || !e.isRecTrack && "WD" == e.maturity && "FPWD-NOTE" !== e.specStatus, e.noRecTrack && Ko.includes(e.specStatus) && r("error", `Document configured as [\`noRecTrack\`](https://github.com/w3c/respec/wiki/noRecTrack), but its status ("${e.specStatus}") puts it on the W3C Rec Track. Status cannot be any of: ${Ko.join(", ")}. [More info](https://github.com/w3c/respec/wiki/noRecTrack).`), e.isIGNote && !e.charterDisclosureURI && r("error", "IG-NOTEs must link to charter's disclosure section using `charterDisclosureURI`."), s.classList.contains("override") || Qt.bind(s)`${function (e, t) { const n = { ...oi(t, e), get mailToWGPublicList() { return `mailto:${e.wgPublicList}@w3.org` }, get mailToWGPublicListWithSubject() { const t = e.subjectPrefix ? "?subject=" + encodeURIComponent(e.subjectPrefix) : ""; return this.mailToWGPublicList + t }, get mailToWGPublicListSubscription() { return `mailto:${e.wgPublicList}-request@w3.org?subject=subscribe` } }; return (e.isCGBG ? Bo : Uo)(e, n) }(e, s)}`, !e.implementationReportURI && e.isCR && r("error", "CR documents must have an [`implementationReportURI`](https://github.com/w3c/respec/wiki/implementationReportURI) that describes [implementation experience](https://www.w3.org/2019/Process-20190301/#implementation-experience)."), !e.implementationReportURI && e.isPR && r("warn", "PR documents should include an  [`implementationReportURI`](https://github.com/w3c/respec/wiki/implementationReportURI) that describes [implementation experience](https://www.w3.org/2019/Process-20190301/#implementation-experience)."), r("amend-user-config", { publishISODate: e.publishISODate, generatedSubtitle: `${e.longStatus} ${e.publishHumanDate}` })
            }
          }); const si = yn({ en: { abstract: "" }, ko: { abstract: "" }, zh: { abstract: "" }, ja: { abstract: "" }, nl: { abstract: "Samenvatting" }, es: { abstract: "Resumen" }, de: { abstract: "Zusammenfassung" } }); var ai = Object.freeze({ __proto__: null, name: "w3c/abstract", run: async function () { const e = document.getElementById("abstract"); if (!e) return void r("error", 'Document must have one element with `id="abstract"'); e.classList.add("introductory"); let t = document.querySelector("#abstract>h2"); t || (t = document.createElement("h2"), t.textContent = si.abstract, e.prepend(t)) } }); var ci = Object.freeze({ __proto__: null, name: "core/data-transform", run: function () { document.querySelectorAll("[data-transform]").forEach(e => { e.innerHTML = xn(e.innerHTML, e.dataset.transform), e.removeAttribute("data-transform") }) } }); function li(e) { const t = (n = e).dataset.abbr ? n.dataset.abbr : n.textContent.match(/\b([a-z])/gi).join("").toUpperCase(); var n; const r = e.textContent.replace(/\s\s+/g, " ").trim(); e.insertAdjacentHTML("afterend", ` (<abbr title="${r}">${t}</abbr>)`); const o = e.dataset.lt || ""; e.dataset.lt = o.split("|").filter(e => e.trim()).concat(t).join("|") } var ui = Object.freeze({ __proto__: null, name: "core/dfn-abbr", run: function () { const e = document.querySelectorAll("[data-abbr]"); for (const t of e) { const { localName: e } = t; switch (e) { case "dfn": li(t); break; default: dn(t, `[\`data-abbr\`](https://github.com/w3c/respec/wiki/data-abbr) attribute not supported on \`${e}\` elements.`, "Error: unsupported.") } } } }); const di = /^[a-z]+(\s+[a-z]+)+$/, pi = /\B"([^"]*)"\B/, fi = /(\w+)\((.*)\)$/, hi = /^\[\[(\w+)\]\]$/, mi = /^((?:\[\[)?(?:\w+)(?:\]\])?)$/, gi = /^(\w+)\["([\w- ]*)"\]$/, bi = /\.?(\w+\(.*\)$)/; function yi(e) { const { identifier: t, renderParent: n } = e; if (n) return Qt`<a data-xref-type="_IDL_"><code>${t}</code></a>` } function vi(e) {
            const { identifier: t, parent: n, renderParent: r } = e, { identifier: o } = n || {}; return Qt`${n && r ? "." : ""}<a
      data-xref-type="attribute"
      data-link-for=${o}
      data-xref-for=${o}
      data-lt="${`[[${t}]]`}"
      ><code>[[${t}]]</code></a
    >`} function wi(e) {
    const { parent: t, identifier: n, renderParent: r } = e, { identifier: o } = t || {}; return Qt`${r ? "." : ""}<a
      data-xref-type="attribute|dict-member"
      data-link-for="${o}"
      data-xref-for="${o}"
      ><code>${n}</code></a
    >`} function xi(e) {
    const { args: t, identifier: n, type: r, parent: o, renderParent: i } = e, { identifier: s } = o || {}, a = $n(t, e => Qt`<var>${e}</var>`), c = `${n}(${t.join(", ")})`; return Qt`${o && i ? "." : ""}<a
      data-xref-type="${r}"
      data-link-for="${s}"
      data-xref-for="${s}"
      data-lt="${c}"
      ><code>${n}</code></a
    ><code>(${a})</code>`
  } function ki(e) {
    const { identifier: t, enumValue: n, parent: r } = e, o = r ? r.identifier : t; return Qt`"<a
      data-xref-type="enum-value"
      data-link-for="${o}"
      data-xref-for="${o}"
      data-lt="${n ? null : "the-empty-string"}"
      ><code>${n}</code></a
    >"`} function $i(e) {
    const { identifier: t } = e; return Qt`"<a data-cite="WebIDL" data-xref-type="exception"
      ><code>${t}</code></a
    >"`} function Ci(e) {
    const { identifier: t } = e; return Qt`<a data-cite="WebIDL" data-xref-type="interface"
    ><code>${t}</code></a
  >`} function Si(e) { let t; try { t = function (e) { const [t, n] = e.split(bi), r = t.split(/[./]/).concat(n).filter(e => e && e.trim()).map(e => e.trim()), o = !e.includes("/"), i = []; for (; r.length;) { const t = r.pop(); if (fi.test(t)) { const [, e, n] = t.match(fi), r = n.split(/,\s*/).filter(e => e); i.push({ type: "method", identifier: e, args: r, renderParent: o }) } else if (gi.test(t)) { const [, e, n] = t.match(gi); i.push({ type: "enum", identifier: e, enumValue: n, renderParent: o }) } else if (pi.test(t)) { const [, e] = t.match(pi); o ? i.push({ type: "exception", identifier: e }) : i.push({ type: "enum", enumValue: e, renderParent: o }) } else if (hi.test(t)) { const [, e] = t.match(hi); i.push({ type: "internal-slot", identifier: e, renderParent: o }) } else if (mi.test(t) && r.length) { const [, e] = t.match(mi); i.push({ type: "attribute", identifier: e, renderParent: o }) } else if (di.test(t)) i.push({ type: "idl-primitive", identifier: t, renderParent: o }); else { if (!mi.test(t) || 0 !== r.length) throw new SyntaxError(`IDL micro-syntax parsing error in \`{{ ${e} }}\``); i.push({ type: "base", identifier: t, renderParent: o }) } } return i.forEach((e, t, n) => { e.parent = n[t + 1] || null }), i.reverse() }(e) } catch (t) { const n = Qt`<span>{{ ${e} }}</span>`; return pn(n, t.message, "Error: Invalid inline IDL string"), n } const n = Qt(document.createDocumentFragment()), r = []; for (const e of t) switch (e.type) { case "base": { const t = yi(e); t && r.push(t); break } case "attribute": r.push(wi(e)); break; case "internal-slot": r.push(vi(e)); break; case "method": r.push(xi(e)); break; case "enum": r.push(ki(e)); break; case "exception": r.push($i(e)); break; case "idl-primitive": r.push(Ci(e)); break; default: throw new Error("Unknown type.") }return n`${r}` } const _i = new Set(["alias", "reference"]), Ei = async function () { return await Kt.openDB("respec-biblio2", 12, { upgrade(e) { Array.from(e.objectStoreNames).map(t => e.deleteObjectStore(t)); e.createObjectStore("alias", { keyPath: "id" }).createIndex("aliasOf", "aliasOf", { unique: !1 }), e.createObjectStore("reference", { keyPath: "id" }) } }) }(); const Ti = { get ready() { return Ei }, async find(e) { return await this.isAlias(e) && (e = await this.resolveAlias(e)), await this.get("reference", e) }, async has(e, t) { if (!_i.has(e)) throw new TypeError("Invalid type: " + e); if (!t) throw new TypeError("id is required"); const n = (await this.ready).transaction(e, "readonly").store, r = IDBKeyRange.only(t); return !!await n.openCursor(r) }, async isAlias(e) { return await this.has("alias", e) }, async resolveAlias(e) { if (!e) throw new TypeError("id is required"); const t = (await this.ready).transaction("alias", "readonly").store, n = IDBKeyRange.only(e), r = await t.openCursor(n); return r ? r.value.aliasOf : r }, async get(e, t) { if (!_i.has(e)) throw new TypeError("Invalid type: " + e); if (!t) throw new TypeError("id is required"); const n = (await this.ready).transaction(e, "readonly").store, r = IDBKeyRange.only(t), o = await n.openCursor(r); return o ? o.value : o }, async addAll(e) { if (!e) return; const t = { alias: [], reference: [] }; for (const n of Object.keys(e)) { const r = { id: n, ...e[n] }; r.aliasOf ? t.alias.push(r) : t.reference.push(r) } const n = [..._i].flatMap(e => t[e].map(t => this.add(e, t))); await Promise.all(n) }, async add(e, t) { if (!_i.has(e)) throw new TypeError("Invalid type: " + e); if ("object" != typeof t) throw new TypeError("details should be an object"); if ("alias" === e && !t.hasOwnProperty("aliasOf")) throw new TypeError("Invalid alias object."); const n = await this.ready, r = await this.has(e, t.id), o = n.transaction(e, "readwrite").store; return r ? await o.put(t) : await o.add(t) }, async close() { (await this.ready).close() }, async clear() { const e = await this.ready, t = [..._i], n = e.transaction(t, "readwrite"), r = t.map(e => n.objectStore(e).clear()); await Promise.all(r) } }, Ai = {}, Ri = new URL("https://specref.herokuapp.com/bibrefs?refs="), Li = ln({ hint: "dns-prefetch", href: Ri.origin }); let Ni; document.head.appendChild(Li); const Di = new Promise(e => { Ni = e }); async function Pi(e, t = { forceUpdate: !1 }) { const n = [...new Set(e)].filter(e => e.trim()); if (!n.length || !1 === navigator.onLine) return null; let r; try { r = await fetch(Ri.href + n.join(",")) } catch (e) { return console.error(e), null } if (!t.forceUpdate && !r.ok || 200 !== r.status) return null; const o = await r.json(); try { await Ti.addAll(o) } catch (e) { console.error(e) } return o } async function ji(e) { const t = await Di; if (!t.hasOwnProperty(e)) return null; const n = t[e]; return n.aliasOf ? await ji(n.aliasOf) : n } var Ii = Object.freeze({ __proto__: null, biblio: Ai, name: "core/biblio", updateFromNetwork: Pi, resolveRef: ji, Plugin: class { constructor(e) { this.conf = e } normalizeReferences() { const e = new Set([...this.conf.normativeReferences].map(e => e.toLowerCase())); Array.from(this.conf.informativeReferences).filter(t => e.has(t.toLowerCase())).forEach(e => this.conf.informativeReferences.delete(e)) } getRefKeys() { return { informativeReferences: Array.from(this.conf.informativeReferences), normativeReferences: Array.from(this.conf.normativeReferences) } } async run() { this.conf.localBiblio || (this.conf.localBiblio = {}), this.conf.biblio = Ai; const e = Object.keys(this.conf.localBiblio).filter(e => this.conf.localBiblio[e].hasOwnProperty("aliasOf")).map(e => this.conf.localBiblio[e].aliasOf).filter(e => !this.conf.localBiblio.hasOwnProperty(e)); this.normalizeReferences(); const t = this.getRefKeys(), n = Array.from(new Set(t.normativeReferences.concat(t.informativeReferences).filter(e => !this.conf.localBiblio.hasOwnProperty(e)).concat(e).sort())), r = await async function (e) { const t = []; try { await Ti.ready; const n = e.map(async e => ({ id: e, data: await Ti.find(e) })); t.push(...await Promise.all(n)) } catch (n) { t.push(...e.map(e => ({ id: e, data: null }))), console.warn(n) } return t }(n), o = { hasData: [], noData: [] }; r.forEach(e => { (e.data ? o.hasData : o.noData).push(e) }), o.hasData.forEach(e => { Ai[e.id] = e.data }); const i = o.noData.map(e => e.id); if (i.length) { const e = await Pi(i, { forceUpdate: !0 }); Object.assign(Ai, e) } Object.assign(Ai, this.conf.localBiblio), (() => { Ni(this.conf.biblio) })() } }, wireReference: Hi, stringifyReference: Gi }); const Oi = yn({ en: { info_references: "Informative references", norm_references: "Normative references", references: "References" }, uk: { info_references: " ", norm_references: " ", references: "" }, ko: { references: "" }, nl: { info_references: "Informatieve referenties", norm_references: "Normatieve referenties", references: "Referenties" }, es: { info_references: "Referencias informativas", norm_references: "Referencias normativas", references: "Referencias" }, ja: { info_references: "", norm_references: "", references: "" }, de: { info_references: "Weiterfhrende Informationen", norm_references: "Normen und Spezifikationen", references: "Referenzen" } }), qi = new Map([["CR", "W3C Candidate Recommendation"], ["ED", "W3C Editor's Draft"], ["FPWD", "W3C First Public Working Draft"], ["LCWD", "W3C Last Call Working Draft"], ["NOTE", "W3C Note"], ["PER", "W3C Proposed Edited Recommendation"], ["PR", "W3C Proposed Recommendation"], ["REC", "W3C Recommendation"], ["WD", "W3C Working Draft"], ["WG-NOTE", "W3C Working Group Note"]]), Wi = Object.freeze({ authors: [], date: "", href: "", publisher: "", status: "", title: "", etAl: !1 }), Mi = (zi = ".", e => { const t = e.trim(); return !t || t.endsWith(zi) ? t : t + zi }); var zi; function Fi(e) { let t = Ai[e], n = e; const o = new Set([n]); for (; t && t.aliasOf;)if (o.has(t.aliasOf)) { t = null; r("error", `Circular reference in biblio DB between [\`${e}\`] and [\`${n}\`].`) } else n = t.aliasOf, t = Ai[n], o.add(n); return t && !t.id && (t.id = e.toLowerCase()), { ref: e, refcontent: t } } function Ui(e, t) {
    const n = e.replace(/^(!|\?)/, ""), r = "#bib-" + n.toLowerCase(), o = Qt`<cite
    ><a class="bibref" href="${r}" data-link-type="biblio">${t || n}</a></cite
  >`; return t ? o : Qt`[${o}]`
  } function Bi({ ref: e, refcontent: t }) {
    const n = "bib-" + e.toLowerCase(); return t ? Qt`
      <dt id="${n}">[${e}]</dt>
      <dd>${{ html: Gi(t) }}</dd>
    `: Qt`
      <dt id="${n}">[${e}]</dt>
      <dd><em class="respec-offending-element">Reference not found.</em></dd>
    `} function Hi(e, t = "_blank") {
    if ("object" != typeof e) throw new TypeError("Only modern object references are allowed"); const n = Object.assign({}, Wi, e), r = n.authors.join("; ") + (n.etAl ? " et al" : ""), o = qi.get(n.status) || n.status; return Qt.wire(n)`
    <cite>
      <a
        href="${n.href}"
        target="${t}"
        rel="noopener noreferrer">
        ${n.title.trim()}</a>.
    </cite>
    <span class="authors">
      ${Mi(r)}
    </span>
    <span class="publisher">
      ${Mi(n.publisher)}
    </span>
    <span class="pubDate">
      ${Mi(n.date)}
    </span>
    <span class="pubStatus">
      ${Mi(o)}
    </span>
  `} function Gi(e) { if ("string" == typeof e) return e; let t = `<cite>${e.title}</cite>`; return t = e.href ? `<a href="${e.href}">${t}</a>. ` : t + ". ", e.authors && e.authors.length && (t += e.authors.join("; "), e.etAl && (t += " et al"), t += ". "), e.publisher && (t = `${t} ${Mi(e.publisher)} `), e.date && (t += e.date + ". "), e.status && (t += (qi.get(e.status) || e.status) + ". "), e.href && (t += `URL: <a href="${e.href}">${e.href}</a>`), t } function Vi(e) { return e.reduce((e, t) => { const n = t.refcontent.id; return (e.has(n) ? e.get(n) : e.set(n, []).get(n)).push(t.ref), e }, new Map) } function Zi(e, t) { e.map(({ ref: e, refcontent: n }) => { const r = "#bib-" + e.toLowerCase(), o = t.get(n.id).map(e => `a.bibref[href="#bib-${e.toLowerCase()}"]`).join(","); return { refUrl: r, elems: document.querySelectorAll(o), refcontent: n } }).forEach(({ refUrl: e, elems: t, refcontent: n }) => { t.forEach(t => { t.setAttribute("href", e), t.setAttribute("title", n.title), t.dataset.linkType = "biblio" }) }) } function Yi(e) { e.forEach(({ ref: e }) => { const t = [...document.querySelectorAll(`a.bibref[href="#bib-${e.toLowerCase()}"]`)].filter(({ textContent: t }) => t.toLowerCase() === e.toLowerCase()); r("error", `Bad reference: [\`${e}\`] (appears ${t.length} times)`), console.warn("Bad references: ", t) }) } var Xi = Object.freeze({
      __proto__: null, name: "core/render-biblio", run: function (e) {
        const t = Array.from(e.informativeReferences), n = Array.from(e.normativeReferences); if (!t.length && !n.length) return; const r = document.querySelector("section#references") || Qt`<section id="references"></section>`; document.querySelector("section#references > h2") || r.prepend(Qt`<h2>${Oi.references}</h2>`), r.classList.add("appendix"); for (const e of ["Normative", "Informative"]) {
          const o = "Normative" === e ? n : t; if (!o.length) continue; const i = Qt`<section>
      <h3>
        ${"Normative" === e ? Oi.norm_references : Oi.info_references}
      </h3>
    </section>`; _n(i); const { goodRefs: s, badRefs: a } = o.map(Fi).reduce((e, t) => (e[t.refcontent ? "goodRefs" : "badRefs"].push(t), e), { goodRefs: [], badRefs: [] }), c = [...s.reduce((e, t) => (e.has(t.refcontent.id) || e.set(t.refcontent.id, t), e), new Map).values()], l = c.concat(a).sort((e, t) => e.ref.toLocaleLowerCase().localeCompare(t.ref.toLocaleLowerCase())); i.appendChild(Qt`<dl class="bibliography">
      ${l.map(Bi)}
    </dl>`), r.appendChild(i); Zi(c, Vi(s)), Yi(a)
        } document.body.appendChild(r)
      }, renderInlineCitation: Ui, wireReference: Hi, stringifyReference: Gi
    }); const Ki = {}, Ji = yn({ en: { rfc2119Keywords: () => new RegExp(["\\bMUST(?:\\s+NOT)?\\b", "\\bSHOULD(?:\\s+NOT)?\\b", "\\bSHALL(?:\\s+NOT)?\\b", "\\bMAY\\b", "\\b(?:NOT\\s+)?REQUIRED\\b", "\\b(?:NOT\\s+)?RECOMMENDED\\b", "\\bOPTIONAL\\b"].join("|")) }, de: { rfc2119Keywords: () => new RegExp(["\\bMUSS\\b", "\\bERFORDERLICH\\b", "\\b(?:NICHT\\s+)?NTIG\\b", "\\bDARF(?:\\s+NICHT)?\\b", "\\bVERBOTEN\\b", "\\bSOLL(?:\\s+NICHT)?\\b", "\\b(?:NICHT\\s+)?EMPFOHLEN\\b", "\\bKANN\\b", "\\bOPTIONAL\\b"].join("|")) } }), Qi = /(?:`[^`]+`)(?!`)/, es = /(?:{{[^}]+}})/, ts = /\B\|\w[\w\s]*(?:\s*:[\w\s&;<>]+)?\|\B/, ns = /(?:\[\[(?:!|\\|\?)?[\w.-]+(?:|[^\]]+)?\]\])/, rs = /(?:\[\[\[(?:!|\\|\?)?#?[\w-.]+\]\]\])/, os = /(?:\[=[^=]+=\])/, is = /(?:\[\^[^^]+\^\])/; function ss(e) {
      const t = e.slice(2, -2).trim(), [n, r] = t.split("/", 2).map(e => e && e.trim()), [o, i, s] = r ? ["element-attr", n, r] : ["element", null, n]; return Qt`<code
    ><a data-xref-type="${o}" data-xref-for="${i}"
      >${s}</a
    ></code
  >`} function as(e) { const t = bn(e), n = Qt`<em class="rfc2119" title="${t}">${t}</em>`; return Ki[t] = !0, n } function cs(e) { const t = e.slice(3, -3).trim(); if (!t.startsWith("#")) return Qt`<a data-cite="${t}"></a>`; if (document.querySelector(t)) return Qt`<a href="${t}"></a>`; const n = Qt`<span>${e}</span>`; return pn(n, `Wasn't able to expand ${e} as it didn't match any id in the document.`, `Please make sure there is element with id ${t} in the document.`), n } function ls(e) { const t = e.slice(2, -2).trim(); return t.startsWith("\\") ? e.replace("\\", "") : Si(bn(t)) } function us(e, t, n) { const r = e.slice(2, -2); if (r.startsWith("\\")) return [`[[${r.slice(1)}]]`]; const [o, i] = r.split("|").map(bn), { type: s, illegal: a } = Ln(o, t.parentNode), c = Ui(o, i), l = o.replace(/^(!|\?)/, ""); if (a && !n.normativeReferences.has(l)) { dn(c.childNodes[1] || c, `Normative references in informative sections are not allowed. Remove '!' from the start of the reference \`[[${r}]]\``) } return "informative" !== s || a ? n.normativeReferences.add(l) : n.informativeReferences.add(l), c.childNodes[1] ? c.childNodes : [c] } function ds(e, t, n) { return "ABBR" === t.parentElement.tagName ? e : Qt`<abbr title="${n.get(e)}">${e}</abbr>` } function ps(e) { const t = e.slice(1, -1).split(":", 2), [n, r] = t.map(e => e.trim()); return Qt`<var data-type="${r}">${n}</var>` } function fs(e) {
    const t = (e = e.slice(2, -2)).split("/", 2).map(e => e.trim()), [n, r] = 2 === t.length ? t : [null, t[0]], [o, i] = r.includes("|") ? r.split("|", 2).map(e => e.trim()) : [null, r], s = function e(t) { if (Qi.test(t)) return t.split(/(`[^`]+`)(?!`)/).map(t => t.startsWith("`") ? hs(t) : e(t)); return document.createTextNode(t) }(i), a = n ? bn(n) : null; return Qt`<a
    data-link-for="${a}"
    data-xref-for="${a}"
    data-lt="${o}"
    >${s}</a
  >`} function hs(e) { const t = e.slice(1, -1); return Qt`<code>${t}</code>` } var ms = Object.freeze({ __proto__: null, name: "core/inlines", rfc2119Usage: Ki, run: function (e) { const t = new Map; document.normalize(), document.querySelector("section#conformance") || document.body.classList.add("informative"), e.normativeReferences = new jn, e.informativeReferences = new jn, e.respecRFC2119 || (e.respecRFC2119 = Ki); const n = document.querySelectorAll("abbr[title]"); for (const e of n) t.set(e.textContent, e.title); const r = [...t.keys()], o = r.length ? `(?:\\b${r.join("\\b)|(?:\\b")}\\b)` : null, i = En(document.body, ["#respec-ui", ".head", "pre"], { wsNodes: !1 }), s = Ji.rfc2119Keywords(), a = new RegExp(`(${[s.source, es.source, ts.source, ns.source, rs.source, os.source, Qi.source, is.source, ...o ? [o] : []].join("|")})`); for (const n of i) { const r = n.data.split(a); if (1 === r.length) continue; const o = document.createDocumentFragment(); let i = !0; for (const a of r) if (i = !i, i) if (a.startsWith("{{")) { const e = ls(a); o.append(e) } else if (a.startsWith("[[[")) { const e = cs(a); o.append(e) } else if (a.startsWith("[[")) { const t = us(a, n, e); o.append(...t) } else if (a.startsWith("|")) { const e = ps(a); o.append(e) } else if (a.startsWith("[=")) { const e = fs(a); o.append(e) } else if (a.startsWith("`")) { const e = hs(a); o.append(e) } else if (a.startsWith("[^")) { const e = ss(a); o.append(e) } else if (t.has(a)) { const e = ds(a, n, t); o.append(e) } else { if (!s.test(a)) throw new Error(`Found token '${a}' but it does not correspond to anything`); { const e = as(a); o.append(e) } } else o.append(a); n.replaceWith(o) } } }); const gs = yn({
      en: {
        conformance: "Conformance", normativity: "As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative. Everything else in this specification is normative.", keywordInterpretation: (e, t) => Qt`<p>
        The key word${t ? "s" : ""} ${e} in this document
        ${t ? "are" : "is"} to be interpreted as described in
        <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>
        ${Ui("RFC2119")} ${Ui("RFC8174")}
        when, and only when, they appear in all capitals, as shown here.
      </p>`}, de: {
        conformance: "Anforderungen", normativity: "Neben den explizit als nicht-normativ gekennzeichneten Abschnitten sind auch alle Diagramme, Beispiele und Hinweise in diesem Dokument nicht normativ. Alle anderen Angaben sind normativ.", keywordInterpretation: (e, t) => Qt`<p>
        ${t ? "Die Schlsselwrter" : "Das Schlsselwort"} ${e} in
        diesem Dokument ${t ? "sind" : "ist"} gem
        <a href="https://tools.ietf.org/html/bcp14">BCP 14</a>
        ${Ui("RFC2119")} ${Ui("RFC8174")}
        und unter Bercksichtigung von
        <a href="https://github.com/adfinis-sygroup/2119/blob/master/2119de.rst"
          >2119de</a
        >
        zu interpretieren, wenn und nur wenn ${t ? "sie" : "es"} wie hier
        gezeigt durchgehend gro geschrieben wurde${t ? "n" : ""}.
      </p>`}
    }); var bs = Object.freeze({
      __proto__: null, name: "w3c/conformance", run: function (e) {
        const t = document.querySelector("section#conformance"); t && !t.classList.contains("override") && function (e, t) {
          const n = [...Object.keys(Ki)]; n.length && (t.normativeReferences.add("RFC2119"), t.normativeReferences.add("RFC8174")); const r = Cn(n.sort(), e => Qt`<em class="rfc2119">${e}</em>`), o = n.length > 1, i = Qt`
    <h2>${gs.conformance}</h2>
    <p>
      ${gs.normativity}
    </p>
    ${n.length ? gs.keywordInterpretation(r, o) : null}
  `; e.prepend(...i.childNodes)
        }(t, e), !t && Object.keys(Ki).length && r("warn", 'Document uses RFC2119 keywords but lacks a conformance section. Please add a `<section id="conformance">`.'), r("end", "w3c/conformance")
      }
    }); var ys = Object.freeze({ __proto__: null, name: "core/dfn", run: function () { document.querySelectorAll("dfn").forEach(e => { const t = Tn(e); so(e, t), e.dataset.dfnType || (e.dataset.dfnType = "dfn"), 1 === t.length && t[0] === bn(e.textContent) || (e.dataset.lt = t.join("|")) }) } }); var vs = Object.freeze({ __proto__: null, name: "core/pluralize", run: function (e) { if (!e.pluralize) return; const t = function () { const e = new Set; document.querySelectorAll("a:not([href])").forEach(t => { const n = bn(t.textContent).toLowerCase(); e.add(n), t.dataset.lt && e.add(t.dataset.lt) }); const t = new Set; return document.querySelectorAll("dfn:not([data-lt-noDefault])").forEach(e => { const n = bn(e.textContent).toLowerCase(); t.add(n), e.dataset.lt && e.dataset.lt.split("|").forEach(e => t.add(e)), e.dataset.localLt && e.dataset.localLt.split("|").forEach(e => t.add(e)) }), function (n) { const r = bn(n).toLowerCase(), o = tn.isSingular(r) ? tn.plural(r) : tn.singular(r); return e.has(o) && !t.has(o) ? o : "" } }(); document.querySelectorAll("dfn:not([data-lt-no-plural]):not([data-lt-noDefault])").forEach(e => { const n = [e.textContent]; e.dataset.lt && n.push(...e.dataset.lt.split("|")), e.dataset.localLt && n.push(...e.dataset.localLt.split("|")); const r = new Set(n.map(t).filter(e => e)); if (r.size) { const t = e.dataset.plurals ? e.dataset.plurals.split("|") : [], n = [...new Set([...t, ...r])]; e.dataset.plurals = n.join("|"), so(e, n) } }) } }); const ws = yn({ en: { example: "Example" }, nl: { example: "Voorbeeld" }, es: { example: "Ejemplo" }, ko: { example: "" }, ja: { example: "" }, de: { example: "Beispiel" } }), xs = async function () { try { return (await Promise.resolve().then((function () { return vl }))).default } catch { return Gn("examples.css") } }(); function ks(e, t, n) {
      n.title = e.title, n.title && e.removeAttribute("title"); const r = t > 0 ? " " + t : "", o = n.title ? Qt`<span class="example-title">: ${n.title}</span>` : ""; return Qt`<div class="marker">
    <a class="self-link">${ws.example}<bdi>${r}</bdi></a
    >${o}
  </div>`} var $s = Object.freeze({
        __proto__: null, name: "core/examples", run: async function () {
          const e = document.querySelectorAll("pre.example, pre.illegal-example, aside.example"); if (!e.length) return; const t = await xs; document.head.insertBefore(Qt`<style>
      ${t}
    </style>`, document.querySelector("link")); let n = 0; e.forEach(e => {
            const t = e.classList.contains("illegal-example"), o = { number: n, illegal: t }, { title: i } = e; if ("aside" === e.localName) { ++n; const t = ks(e, n, o); e.prepend(t), i ? _n(e, "example-" + n, i) : _n(e, "example", String(n)); const { id: s } = e; t.querySelector("a.self-link").href = "#" + s, r("example", o) } else {
              const t = !!e.closest("aside"); t || ++n, o.content = e.innerHTML, e.classList.remove("example", "illegal-example"); const s = e.id ? e.id : null; s && e.removeAttribute("id"); const a = ks(e, t ? 0 : n, o), c = Qt`<div class="example" id="${s}">
        ${a} ${e.cloneNode(!0)}
      </div>`; i && _n(c, "example-" + n, i), _n(c, "example", String(n)); c.querySelector("a.self-link").href = "#" + c.id, e.replaceWith(c), t || r("example", o)
            }
          })
        }
      }); const Cs = async function () { try { return (await Promise.resolve().then((function () { return wl }))).default } catch { return Gn("issues-notes.css") } }(); const Ss = yn({ en: { editors_note: "Editor's note", feature_at_risk: "(Feature at Risk) Issue", issue: "Issue", issue_summary: "Issue Summary", no_issues_in_spec: "There are no issues listed in this specification.", note: "Note", warning: "Warning" }, uk: {note: ""},zh: { note: "" }, ja: { note: "", editors_note: "", feature_at_risk: "() Issue", issue: "Issue", issue_summary: "Issue ", no_issues_in_spec: " issues ", warning: "" }, nl: { editors_note: "Redactionele noot", issue_summary: "Lijst met issues", no_issues_in_spec: "Er zijn geen problemen vermeld in deze specificatie.", note: "Noot", warning: "Waarschuwing" }, es: { editors_note: "Nota de editor", issue: "Cuestin", issue_summary: "Resumen de la cuestin", note: "Nota", no_issues_in_spec: "No hay problemas enumerados en esta especificacin.", warning: "Aviso" }, de: { editors_note: "Redaktioneller Hinweis", issue: "Frage", issue_summary: "Offene Fragen", no_issues_in_spec: "Diese Spezifikation enthlt keine offenen Fragen.", note: "Hinweis", warning: "Warnung" } }); function _s(e, t, n) {
        const o = function () { if (document.querySelector(".issue[data-number]")) return e => { if (e.dataset.number) return Number(e.dataset.number) }; let e = 0; return t => { if (t.classList.contains("issue") && "span" !== t.localName) return ++e } }(), i = document.createElement("ul"); e.forEach(e => {
          const { type: s, displayType: a, isFeatureAtRisk: c } = function (e) { const t = e.classList.contains("issue"), n = e.classList.contains("warning"), r = e.classList.contains("ednote"), o = e.classList.contains("atrisk"), i = t ? "issue" : n ? "warning" : r ? "ednote" : "note", s = t ? o ? Ss.feature_at_risk : Ss.issue : n ? Ss.warning : r ? Ss.editors_note : Ss.note; return { type: i, displayType: s, isFeatureAtRisk: o } }(e), l = "issue" === s, u = "span" === e.localName, { number: d } = e.dataset, p = { type: s, inline: u, title: e.title, number: o(e) }; if (!u) {
            const o = Qt`<div class="${c ? s + " atrisk" : s}" role="${"note" === s ? "note" : null}"></div>`, u = document.createElement("span"), f = Qt`
        <div role='heading' class='${s + "-title marker"}'>${u}</div>`; _n(f, "h", s); let h, m = a; if (e.id ? (o.id = e.id, e.removeAttribute("id")) : _n(o, "issue-container", p.number ? "number-" + p.number : ""), l) {
              if (void 0 !== p.number && (m += " " + p.number), e.dataset.hasOwnProperty("number")) { const e = function (e, t, { isFeatureAtRisk: n = !1 } = {}) { if (!n && t.issueBase) return Qt`<a href='${t.issueBase + e}'/>`; if (n && t.atRiskBase) return Qt`<a href='${t.atRiskBase + e}'/>` }(d, n, { isFeatureAtRisk: c }); e && (u.before(e), e.append(u)), u.classList.add("issue-number"), h = t.get(d), h || r("warning", "Failed to fetch issue number " + d), h && !p.title && (p.title = h.title) } void 0 !== p.number && i.append(function (e, t, n) {
                const r = `${e} ${t.number}`, o = t.title ? Qt`<span style="text-transform: none">: ${t.title}</span>` : ""; return Qt`
    <li><a href="${"#" + n}">${r}</a>${o}</li>
  `}(Ss.issue, p, o.id))
            } if (u.textContent = m, p.title) {
              e.removeAttribute("title"); const { repoURL: t = "" } = n.github || {}, r = h ? h.labels : []; h && "CLOSED" === h.state && o.classList.add("closed"), f.append(function (e, t, n) {
                const r = e.map(e => function (e, t) {
                  const { color: n, name: r } = e, o = new URL("./issues/", t); o.searchParams.set("q", `is:issue is:open label:"${e.name}"`); const i = (s = n, parseInt(s, 16) > 8388607.5 ? "#000" : "#fff"); var s; return Qt`<a
    class="respec-gh-label"
    style="${`background-color: #${n}; color: ${i}`}"
    href="${o.href}">${r}</a>`
                }(e, n)), o = e.map(e => e.name), i = gn(o); r.length && r.unshift(document.createTextNode(" ")); if (o.length) {
                  return Qt`<span
      class="issue-label"
      aria-label="${`This issue is labelled as ${i}.`}">: ${t}${r}</span>`
                } return Qt`<span class="issue-label">: ${t}${r}</span>`
              }(r, p.title, t))
            } let g = e; e.replaceWith(o), g.classList.remove(s), g.removeAttribute("data-number"), h && !g.innerHTML.trim() && (g = document.createRange().createContextualFragment(h.bodyHTML)), o.append(f, g); const b = Dn(f, "section").length + 2; f.setAttribute("aria-level", b)
          } r(p.type, p)
        }), function (e) { const t = document.getElementById("issue-summary"); if (!t) return; const n = t.querySelector("h2, h3, h4, h5, h6"); e.hasChildNodes() ? t.append(e) : t.append(Qt`<p>${Ss.no_issues_in_spec}</p>`), (!n || n && n !== t.firstElementChild) && t.insertAdjacentHTML("afterbegin", `<h2>${Ss.issue_summary}</h2>`) }(i)
      } var Es = Object.freeze({ __proto__: null, name: "core/issues-notes", run: async function (e) { const t = document.querySelectorAll(".issue, .note, .warning, .ednote"); if (!t.length) return; const n = await async function (e) { if (!e || !e.apiBase) return new Map; const t = [...document.querySelectorAll(".issue[data-number]")].map(e => Number.parseInt(e.dataset.number, 10)).filter(e => e); if (!t.length) return new Map; const n = new URL("issues", `${e.apiBase}/${e.fullName}/`); n.searchParams.set("issues", t.join(",")); const o = await fetch(n.href); if (!o.ok) { return r("error", `Error fetching issues from GitHub. (HTTP Status ${o.status}).`), new Map } const i = await o.json(); return new Map(Object.entries(i)) }(e.github), o = await Cs, { head: i } = document; i.insertBefore(Qt`<style>${o}</style>`, i.querySelector("link")), _s(t, n, e), document.querySelectorAll(".ednote").forEach(e => { e.classList.remove("ednote"), e.classList.add("note") }) } }); const Ts = { en: { best_practice: "Best Practice " }, ja: { best_practice: " " }, de: { best_practice: "Musterbeispiel " } }, As = yn(Ts), Rs = g in Ts ? g : "en"; var Ls = Object.freeze({
        __proto__: null, name: "core/best-practices", run: function () {
          const e = document.querySelectorAll(".practicelab"), t = document.getElementById("bp-summary"), n = t ? document.createElement("ul") : null;[...e].forEach((e, t) => {
            const r = _n(e, "bp"), o = Qt`<a class="marker self-link" href="${"#" + r}"
      ><bdi lang="${Rs}">${As.best_practice}${t + 1}</bdi></a
    >`; if (n) {
              const t = Qt`
        <li>
          ${o}: ${In(e)}
        </li>
      `; n.appendChild(t)
            } const i = e.closest("div"); if (!i) return void e.classList.add("advisement"); i.classList.add("advisement"); const s = Qt`${o.cloneNode(!0)}: ${e}`; i.prepend(...s.childNodes)
          }), e.length ? t && (t.appendChild(Qt`<h2>Best Practices Summary</h2>`), t.appendChild(n)) : t && (r("warn", "Using best practices summary (#bp-summary) but no best practices found."), t.remove())
        }
      }); const Ns = yn({ en: { list_of_figures: "List of Figures", fig: "Figure " }, ja: { fig: " ", list_of_figures: "" }, ko: { fig: " ", list_of_figures: " " }, nl: { fig: "Figuur ", list_of_figures: "Lijst met figuren" }, es: { fig: "Figura ", list_of_figures: "Lista de Figuras" }, zh: { fig: " ", list_of_figures: "List of Figures" }, de: { fig: "Abbildung", list_of_figures: "Abbildungsverzeichnis" } }); var Ds = Object.freeze({
        __proto__: null, name: "core/figures", run: function () {
          document.querySelectorAll(":not(picture)>img:not([width]):not([height]):not([srcset])").forEach(e => { 0 !== e.naturalHeight && 0 !== e.naturalWidth && (e.height = e.naturalHeight, e.width = e.naturalWidth) }); const e = function () {
            const e = []; return document.querySelectorAll("figure").forEach((t, n) => {
              const r = t.querySelector("figcaption"); r ? (!function (e, t, n) { const r = t.textContent; _n(e, "fig", r), Nn(t, Qt`<span class="fig-title"></span>`), t.prepend(Ns.fig, Qt`<bdi class="figno">${n + 1}</bdi>`, " ") }(t, r, n), e.push(function (e, t) {
                const n = t.cloneNode(!0); return n.querySelectorAll("a").forEach(e => { Rn(e, "span").removeAttribute("href") }), Qt`<li class="tofline">
    <a class="tocxref" href="${"#" + e}">${n.childNodes}</a>
  </li>`}(t.id, r))) : dn(t, "Found a `<figure>` without a `<figcaption>`")
            }), e
          }(), t = document.getElementById("tof"); e.length && t && (!function (e) { if (e.classList.contains("appendix") || e.classList.contains("introductory") || e.closest("section")) return; const t = function (e) { const t = []; for (const n of function* (e) { let t = e; for (; t.previousElementSibling;)t = t.previousElementSibling, yield t }(e)) "section" === n.localName && t.push(n); return t }(e); t.every(e => e.classList.contains("introductory")) ? e.classList.add("introductory") : t.some(e => e.classList.contains("appendix")) && e.classList.add("appendix") }(t), t.append(Qt`<h2>${Ns.list_of_figures}</h2>`, Qt`<ul class="tof">
        ${e}
      </ul>`))
        }
      }); const Ps = new Set(["callback interface", "callback", "dictionary", "enum", "interface mixin", "interface", "typedef"]); function js(e, t, { parent: n = "" } = {}) { switch (e.type) { case "constructor": case "operation": return function (e, t, n) { if (n.includes("!overload")) return Is(e, t, n); return Is(e, t, n + "()", n) }(e, n, t); default: return Is(e, n, t) } } function Is(e, t, ...n) { const { type: r } = e; for (const e of n) { let n = "enum-value" === r && "" === e ? "the-empty-string" : e, o = qs(n, t, e, r); if (0 === o.length && "" !== t) { n = `${t}.${n}`; const e = io.get(n); e && 1 === e.size && (o = [...e], so(o[0], [n])) } else n = e; if (o.length > 1) { pn(o, `WebIDL identifier \`${e}\` ${t ? `for \`${t}\`` : ""} is defined multiple times`, "Duplicate definition.") } if (o.length) return o[0] } } function Os(e, t, n, r) { if (!e.id) { const t = n.toLowerCase(), o = t ? t + "-" : ""; let i = r.toLowerCase().replace(/[()]/g, "").replace(/\s/g, "-"); "" === i && (i = "the-empty-string"), e.id = `dom-${o}${i}` } switch (e.dataset.idl = t.type, e.dataset.title = e.textContent, e.dataset.dfnFor = n, t.type) { case "operation": case "attribute": case "field": e.dataset.type = Ws(t) }switch (e.querySelector("code") || e.closest("code") || !e.children || Nn(e, e.ownerDocument.createElement("code")), t.type) { case "attribute": case "constructor": case "operation": !function (e, t) { const { local: n, exportable: r } = t, o = e.dataset.lt ? new Set(e.dataset.lt.split("|")) : new Set; for (const e of r) o.add(e); n.filter(e => o.has(e)).forEach(e => o.delete(e)), e.dataset.lt = [...o].join("|"), e.dataset.localLt = n.join("|"), so(e, [...n, ...r]) }(e, function (e, t, n) { const { type: r } = e, o = `${t}.${n}`; switch (r) { case "constructor": case "operation": return { local: [o, o + "()", n], exportable: [n + "()", ...function (e, t) { const n = []; if (0 === t.length) return n; const r = [], o = []; for (const { name: e, optional: n, variadic: i } of t) n || i ? o.push(e) : r.push(e); const i = r.join(", "), s = `${e}(${i})`; n.push(s); const a = o.map((t, n) => { const r = o.slice(0, n + 1).join(", "); return `${e}(${i}${r ? ", " + r : ""})` }); return n.push(...a), n }(n, e.arguments)] }; case "attribute": return { local: [o], exportable: [n] } } }(t, n, r)) }return e } function qs(e, t, n, r) { const o = io.get(e); if (!o || 0 === o.size) return []; const i = [...o], s = i.filter(e => { const n = e.closest("[data-dfn-for]"); return n && n.dataset.dfnFor === t }); if (0 === s.length && "" === t && 1 === i.length) return i[0].textContent === n ? i : []; if (Ps.has(r) && i.length) { const e = i.find(e => e.textContent.trim() === n); if (e) return [e] } return s } function Ws(e) { const { idlType: t, generic: n, union: r } = e; return "string" == typeof t ? t : n || (r ? t.map(Ws).join("|") : Ws(t)) } const Ms = function () { const e = document.createElement("button"); return e.innerHTML = '<svg height="16" viewBox="0 0 14 16" width="14"><path fill-rule="evenodd" d="M2 13h4v1H2v-1zm5-6H2v1h5V7zm2 3V8l-3 3 3 3v-2h5v-2H9zM4.5 9H2v1h2.5V9zM2 12h2.5v-1H2v1zm9 1h1v2c-.02.28-.11.52-.3.7-.19.18-.42.28-.7.3H1c-.55 0-1-.45-1-1V4c0-.55.45-1 1-1h3c0-1.11.89-2 2-2 1.11 0 2 .89 2 2h3c.55 0 1 .45 1 1v5h-1V6H1v9h10v-2zM2 5h8c0-.55-.45-1-1-1H8c-.55 0-1-.45-1-1s-.45-1-1-1-1 .45-1 1-.45 1-1 1H3c-.55 0-1 .45-1 1z"/></svg>', e.title = "Copy IDL to clipboard", e.classList.add("respec-button-copy-paste", "removeOnSave"), e }(); function zs(e) { const t = e.closest("pre.idl").cloneNode(!0); t.querySelector(".idlHeader").remove(); const { textContent: n } = t, r = Ms.cloneNode(!0); r.addEventListener("click", () => { navigator.clipboard.writeText(n) }), e.append(r) } var Fs = Object.freeze({ __proto__: null, name: "core/webidl-clipboard", addCopyIDLButton: zs }); const Us = {}, Bs = {}, Hs = {
        wrap: e => e.flat().filter(e => "" !== e).map(e => "string" == typeof e ? new Text(e) : e), trivia: e => e.trim() ? Qt`<span class="idlSectionComment">${e}</span>` : e, generic: e => /^[A-Z]/.test(e) ? Qt`<a data-xref-type="interface" data-cite="WebIDL">${e}</a>` : Qt`<a data-xref-type="dfn" data-cite="WebIDL">${e}</a>`, reference(e, t, n) {
          if ("extended-attribute" === n.type && "Exposed" !== n.name) return e; let r, o = "_IDL_", i = null; switch (t) { case "Window": o = "interface", i = "HTML"; break; case "object": o = "interface", i = "WebIDL"; break; default: t.includes("Worker") && "extended-attribute" === n.type && (r = t + "GlobalScope", o = "interface", i = ["Worker", "DedicatedWorker", "SharedWorker"].includes(t) ? "HTML" : null) }return Qt`<a data-xref-type="${o}" data-cite="${i}" data-lt="${r}"
      >${e}</a
    >`}, name(e, { data: t, parent: n }) { if (t.idlType && "argument-type" === t.idlType.type) return Qt`<span class="idlParamName">${e}</span>`; const r = Gs(e, t, n); if ("enum-value" !== t.type) { const e = n ? "idlName" : "idlID"; r.classList.add(e) } return r }, nameless(e, { data: t, parent: n }) { switch (t.type) { case "constructor": return Gs(e, t, n); default: return e } }, type: e => Qt`<span class="idlType">${e}</span>`, inheritance: e => Qt`<span class="idlSuperclass">${e}</span>`, definition(e, { data: t, parent: n }) {
          const r = function (e) { switch (e.type) { case "callback interface": return "idlInterface"; case "operation": return "idlMethod"; case "field": return "idlMember"; case "enum-value": return "idlEnumItem"; case "callback function": return "idlCallback" }return `idl${e.type[0].toUpperCase()}${e.type.slice(1)}` }(t); switch (t.type) { case "includes": case "enum-value": return Qt`<span class="${r}">${e}</span>` }const o = n ? n.name : "", { name: i, idlId: s } = Zs(t, o); return Qt`<span
      class="${r}"
      id="${s}"
      data-idl
      data-title="${i}"
      >${e}</span
    >`}, extendedAttribute: e => Qt`<span class="extAttr">${e}</span>`, extendedAttributeReference: e => Qt`<a data-xref-type="extended-attribute">${e}</a>`
      }; function Gs(e, t, n) {
        const r = n ? n.name : "", { name: o } = Zs(t, r), i = js(t, o, { parent: r }), s = function (e) { switch (e) { case "operation": return "method"; case "field": return "dict-member"; case "callback interface": case "interface mixin": return "interface"; default: return e } }(t.type); if (i) {
          t.partial || (i.dataset.export = "", i.dataset.dfnType = s), Os(i, t, r, o); const n = "#" + i.id; return Qt`<a
      data-link-for="${r}"
      data-link-type="${s}"
      href="${n}"
      class="internalDFN"
      ><code>${e}</code></a
    >`} if ("operation" === t.type && "toJSON" === t.name && t.extAttrs.some(({ name: e }) => "Default" === e)) return Qt`<a data-link-type="dfn" data-lt="default toJSON steps"
      >${e}</a
    >`; if (!t.partial) {
          const n = Qt`<dfn data-export data-dfn-type="${s}"
      >${e}</dfn
    >`; return so(n, [o]), Os(n, t, r, o), n
        } const a = Qt`<a
    data-idl="${t.partial ? "partial" : null}"
    data-link-type="${s}"
    data-title="${t.name}"
    data-xref-type="${s}"
    >${e}</a
  >`; if (o && "typedef" !== t.type && !(t.partial && !i)) { dn(a, `Missing \`<dfn>\` for${r ? ` \`${r}\`'s` : ""} \`${"operation" === t.type ? o + "()" : o}\` ${t.type}. [More info](https://github.com/w3c/respec/wiki/WebIDL-thing-is-not-defined).`, "") } return a
      } const Vs = new WeakMap; function Zs(e, t = "") { if (Vs.has(e)) return Vs.get(e); const n = function (e, t) { let n = function (e) { switch (e.type) { case "enum-value": return e.value; case "operation": return e.name; default: return e.name || e.type } }(e), r = function (e, t) { if (!t) return "idl-def-" + e.toLowerCase(); return `idl-def-${t.toLowerCase()}-${e.toLowerCase()}` }(n, t); switch (e.type) { case "callback interface": case "dictionary": case "interface": case "interface mixin": r += function (e) { if (!e.partial) return ""; Bs[e.name] || (Bs[e.name] = 0); return Bs[e.name] += 1, "-partial-" + Bs[e.name] }(e); break; case "constructor": case "operation": { const o = function (e, t) { const n = `${t}.${e}`, r = n + "()"; let o; Us[r] || (Us[r] = 0); Us[n] ? o = "!overload-" + Us[n] : Us[n] = 0; return Us[r] += 1, Us[n] += 1, o || "" }(n, t); o ? (n += o, r += o) : e.arguments.length && (r += e.arguments.map(e => "-" + e.name.toLowerCase()).join("")); break } }return { name: n, idlId: r } }(e, t); return Vs.set(e, n), n } function Ys(e, t) { let n; try { n = Jt.parse(e.textContent, { sourceName: String(t) }) } catch (t) { return pn(e, `Failed to parse WebIDL: ${t.bareMessage}.`, t.bareMessage, { details: `<pre>${t.context}</pre>` }), [] } e.classList.add("def", "idl"); const r = Jt.write(n, { templates: Hs }); Qt.bind(e)`${r}`, e.querySelectorAll("[data-idl]").forEach(e => { if (e.dataset.dfnFor) return; const t = e.dataset.title, n = e.parentElement.closest("[data-idl][data-title]"); n && (e.dataset.dfnFor = n.dataset.title), so(e, [t]) }); const o = e.closest("[data-cite], body"), { dataset: i } = o; if (i.cite || (i.cite = "WebIDL"), !/\bwebidl\b/i.test(i.cite)) { const e = i.cite.trim().split(/\s+/); i.cite = ["WebIDL", ...e].join(" ") } return Xs(e), n } function Xs(e) {
        Sn(e, "webidl"); const t = Qt`<span class="idlHeader"
    ><a class="self-link" href="${"#" + e.id}">WebIDL</a></span
  >`; e.prepend(t), zs(t)
      } const Ks = async function () { try { return (await Promise.resolve().then((function () { return xl }))).default } catch { return Gn("webidl.css") } }(); var Js = Object.freeze({ __proto__: null, name: "core/webidl", addIDLHeader: Xs, run: async function () { const e = document.querySelectorAll("pre.idl, pre.webidl"); if (!e.length) return; if (!document.querySelector(".idl:not(pre), .webidl:not(pre)")) { const e = document.querySelector("head link"); if (e) { const t = document.createElement("style"); t.textContent = await Ks, e.before(t) } } const t = [...e].map(Ys), n = Jt.validate(t); for (const r of n) { let n = `<pre>${r.context}</pre>`; if (r.autofix) { r.autofix(); const e = Jt.write(t[r.sourceName]); n += `Try fixing as:\n      <pre>${e.replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/</g, "&lt;")}</pre>` } pn(e[r.sourceName], "WebIDL validation error: " + r.bareMessage, r.bareMessage, { details: n }) } document.normalize() } }); function Qs(e) { return t => { const n = t.search(e); return -1 !== n ? t.substring(n) : "" } } function ea(e) { const t = Qs("#"), n = Qs("/"); return function r(o) { const { dataset: i } = o, { cite: s, citeFrag: a, citePath: c } = i; if (s.startsWith("#") && !a) { const t = o.parentElement.closest('[data-cite]:not([data-cite^="#"])'), { key: n, isNormative: a } = t ? r(t) : { key: e.shortName || "", isNormative: !1 }; return i.cite = a ? n : "?" + n, i.citeFrag = s.replace("#", ""), r(o) } const l = a ? "#" + a : t(s), u = c || n(s).split("#")[0], { type: d } = Ln(s, o), p = "normative" === d, f = /^[?|!]/.test(s); return { key: s.split(/[/|#]/)[0].substring(Number(f)), isNormative: p, frag: l, path: u } } } async function ta(e, t = respecConfig) { const n = function (e) { const t = ea(e); return async n => { const r = n.dataset.cite, { key: o, frag: i, path: s } = t(n); let a = "", c = ""; if (o.toLowerCase() === e.shortName.toLowerCase()) console.log(n, `The reference "${o}" is resolved into the current document per \`conf.shortName\`.`), a = document.location.href; else { const e = await ji(o); if (!e) return void dn(n, `Couldn't find a match for "${r}"`); a = e.href, c = e.title } if (s) { const e = s.startsWith("/") ? "." + s : s; a = new URL(e, a).href } switch (i && (a = new URL(i, a).href), n.localName) { case "a": if ("" === n.textContent && "the-empty-string" !== n.dataset.lt && (n.textContent = c), n.href = a, !s && !i) { const e = document.createElement("cite"); n.replaceWith(e), e.append(n) } break; case "dfn": { const e = document.createElement("a"); if (e.href = a, n.textContent ? Nn(n, e) : (e.textContent = c, n.append(e)), !s && !i) { const t = document.createElement("cite"); t.append(e), n.append(t) } "export" in n.dataset && (pn(n, "Exporting an linked external definition is not allowed. Please remove the `data-export` attribute", "Please remove the `data-export` attribute."), delete n.dataset.export), n.dataset.noExport = ""; break } } } }(t), r = [...e.querySelectorAll("dfn[data-cite]:not([data-cite='']), a[data-cite]:not([data-cite=''])")], o = ea(t), i = r.map(o).map(async e => ({ entry: e, result: await ji(e.key) })), s = (await Promise.all(i)).filter(({ result: e }) => null === e).map(({ entry: { key: e } }) => e), a = await Pi(s); a && Object.assign(Ai, a); const c = [...new Set(r)].map(n); return await Promise.all(c) } function na(e) { const t = ["data-cite", "data-cite-frag", "data-cite-path"]; e.querySelectorAll("a[data-cite], dfn[data-cite]").forEach(e => t.forEach(t => e.removeAttribute(t))) } var ra = Object.freeze({ __proto__: null, name: "core/data-cite", citeDetailsConverter: ea, run: async function (e) { const t = ea(e), n = document.querySelectorAll("dfn[data-cite], a[data-cite]"); Array.from(n).filter(e => e.dataset.cite).map(t).filter(({ key: t }) => t.toLowerCase() !== (e.shortName || "").toLowerCase()).forEach(({ isNormative: t, key: n }) => { t || e.normativeReferences.has(n) ? (e.normativeReferences.add(n), e.informativeReferences.delete(n)) : e.informativeReferences.add(n) }), o("beforesave", na) }, linkInlineCitations: ta }); var oa = Object.freeze({ __proto__: null, name: "core/webidl-index", run: function () { const e = document.querySelector("section#idl-index"); if (!e) return; const t = [2, 3, 4, 5, 6].map(e => `h${e}:first-child`).join(","); if (!e.querySelector(t)) { const t = document.createElement("h2"); e.title ? (t.textContent = e.title, e.removeAttribute("title")) : t.textContent = "IDL Index", e.prepend(t) } const n = Array.from(document.querySelectorAll("pre.def.idl:not(.exclude)")).filter(e => !e.closest(cn)); if (0 === n.length) { const t = "This specification doesn't declare any Web IDL."; return void e.append(t) } const r = document.createElement("pre"); r.classList.add("idl", "def"), r.id = "actual-idl-index", n.map(e => { const t = document.createDocumentFragment(); for (const n of e.children) t.appendChild(n.cloneNode(!0)); return t }).forEach(e => { r.lastChild && r.append("\n\n"), r.appendChild(e) }), r.querySelectorAll("*[id]").forEach(e => e.removeAttribute("id")), r.querySelectorAll(".idlHeader").forEach(e => e.remove()), e.appendChild(r), Xs(r) } }); async function ia() { const e = await Kt.openDB("xref", 1, { upgrade(e) { e.createObjectStore("xrefs") } }); return new mn(e, "xrefs") } async function sa(e) { try { const t = await ia(); return await async function (e, t) { if (await async function (e) { const t = await e.get("__LAST_VERSION_CHECK__"), n = Date.now(); if (!t) return await e.set("__LAST_VERSION_CHECK__", n), !1; if (n - t < 3e5) return !1; const r = new URL("meta/version", ca).href, o = await fetch(r); if (!o.ok) return !1; const i = await o.text(); return await e.set("__LAST_VERSION_CHECK__", n), parseInt(i, 10) > t }(t)) return await t.clear(), new Map; return await t.getMany(e.map(e => e.id)) }(e, t) } catch (e) { return console.error(e), new Map } } const aa = { "web-platform": ["HTML", "INFRA", "URL", "WEBIDL", "DOM", "FETCH"] }, ca = "https://respec.org/xref/"; if (!document.querySelector("link[rel='preconnect'][href='https://respec.org']")) { const e = ln({ hint: "preconnect", href: "https://respec.org" }); document.head.appendChild(e) } async function la(e, t) { const n = function (e) { const t = { url: ca, specs: null }, n = Object.assign({}, t); switch (Array.isArray(e) ? "array" : typeof e) { case "boolean": break; case "string": e.toLowerCase() in aa ? Object.assign(n, { specs: aa[e.toLowerCase()] }) : o(e); break; case "array": Object.assign(n, { specs: e }); break; case "object": if (Object.assign(n, e), e.profile) { const t = e.profile.toLowerCase(); if (t in aa) { const r = (e.specs || []).concat(aa[t]); Object.assign(n, { specs: r }) } else o(e.profile) } break; default: r("error", `Invalid value for \`xref\` configuration option. Received: "${e}".`) }return n; function o(e) { r("error", `Invalid profile "${e}" in \`respecConfig.xref\`. Please use one of the supported profiles: ${Object.keys(aa).map(e => `"${e}"`).join(", ")}.`) } }(e.xref); if (n.specs) { const e = document.body.dataset.cite ? document.body.dataset.cite.split(/\s+/) : []; document.body.dataset.cite = e.concat(n.specs).join(" ") } if (!t.length) return; const i = []; for (const e of t) { const t = ua(e), n = await fa(t); i.push({ ...t, id: n }) } const s = await async function (e, t) { const n = new Set, r = e.filter(e => !n.has(e.id) && (n.add(e.id) && !0)), o = await sa(r), i = r.filter(e => !o.get(e.id)), s = await async function (e, t) { if (!e.length) return new Map; const n = { keys: e }, r = { method: "POST", body: JSON.stringify(n), headers: { "Content-Type": "application/json" } }, o = await fetch(t, r), i = await o.json(); return new Map(i.result) }(i, t); s.size && await async function (e) { try { const t = await ia(); await t.addMany(e) } catch (e) { console.error(e) } }(s); return new Map([...o, ...s]) }(i, n.url); !function (e, t, n, r) { const o = { ambiguous: new Map, notFound: new Map }; for (let i = 0, s = e.length; i < s; i++) { if (e[i].closest("[data-no-xref]")) continue; const s = e[i], a = t[i], { id: c } = a, l = n.get(c); if (1 === l.length) pa(s, a, l[0], r); else { const e = o[0 === l.length ? "notFound" : "ambiguous"]; e.has(c) || e.set(c, { elems: [], results: l, query: a }), e.get(c).elems.push(s) } } !function ({ ambiguous: e, notFound: t }) { const n = (e, t, n = []) => { const r = new URL(ca); return r.searchParams.set("term", e), t.for && r.searchParams.set("for", t.for), r.searchParams.set("types", t.types.join(",")), n.length && r.searchParams.set("specs", n.join(",")), r }; for (const { query: e, elems: r } of t.values()) { const t = e.specs ? [...new Set(e.specs.flat())].sort() : [], o = da(r[0]), i = n(o, e), s = t.map(e => `\`${e}\``).join(", "); pn(r, `Couldn't match "**${o}**" to anything in the document or in any other document cited in this specification: ${s}. See [how to cite to resolve the error](${i})`, "Error: No matching dfn found.") } for (const { query: t, elems: r, results: o } of e.values()) { const e = [...new Set(o.map(e => e.shortname))].sort(), i = e.map(e => `**${e}**`).join(", "), s = da(r[0]), a = n(s, t, e); pn(r, `The term "**${s}**" is defined in ${i} in multiple ways, so it's ambiguous. See [how to cite to resolve the error](${a})`, "Error: Linking an ambiguous dfn.") } }(o) }(t, i, s, e), o("beforesave", ma) } function ua(e) { const t = "xrefType" in e.dataset; let n = da(e); t || (n = n.toLowerCase()); const r = function (e) { const t = []; let n = e.closest("[data-cite]"); if (n !== e) { const n = e.closest("section"), r = [...n ? n.querySelectorAll("a.bibref") : []].map(e => e.textContent.toLowerCase()); r.length && t.push(r) } for (; n;) { const r = n.dataset.cite.toLowerCase().replace(/[!?]/g, "").split(/\s+/).filter(e => e); if (r.length && t.push(r), n === e) break; n = n.parentElement.closest("[data-cite]") } return function (e) { const t = []; for (const n of e) { const e = t[t.length - 1] || [], r = [...new Set(n)].filter(t => !e.includes(t)); t.push(r.sort()) } return t }(t) }(e), o = function (e, t) { if (t) return e.dataset.xrefType ? e.dataset.xrefType.split("|") : ["_IDL_"]; return ["_CONCEPT_"] }(e, t), i = function (e, t) { if (e.dataset.xrefFor) return bn(e.dataset.xrefFor); if (t) { const t = e.closest("[data-xref-for]"); if (t) return bn(t.dataset.xrefFor) } return null }(e, t); return { term: n, types: o, ...r.length && { specs: r }, ..."string" == typeof i && { for: i } } } function da(e) { const { lt: t } = e.dataset; let n = t ? t.split("|", 1)[0] : e.textContent; return n = bn(n), "the-empty-string" === n ? "" : n } function pa(e, t, n, r) { const { term: o } = t, { uri: i, shortname: s, normative: a, type: c, for: l } = n, u = i.includes("/") ? i.split("/", 1)[1] : i, [d, p] = u.split("#"), f = { cite: s, citePath: d, citeFrag: p, type: c }; l && (f.linkFor = l[0]), Object.assign(e.dataset, f), function (e, t, n, r, o) { if (!function (e) { const t = e.closest(".normative"), n = e.closest(cn); return !n || e === t || t && n && n.contains(t) }(e)) return void (o.normativeReferences.has(t) || o.informativeReferences.add(t)); if (n) { const e = o.informativeReferences.has(t) ? o.informativeReferences.getCanonicalKey(t) : t; return o.normativeReferences.add(e), void o.informativeReferences.delete(e) } dn(e, `Adding an informative reference to "${r}" from "${t}" in a normative section`, "Error: Informative reference in normative section") }(e, s, a, o, r) } function fa(e) { const t = JSON.stringify(e, Object.keys(e).sort()), n = (new TextEncoder).encode(t); return crypto.subtle.digest("SHA-1", n).then(ha) } function ha(e) { return [...new Uint8Array(e)].map(e => e.toString(16).padStart(2, "0")).join("") } function ma(e) { const t = e.querySelectorAll("a[data-xref-for], a[data-xref-type], a[data-link-for]"), n = ["data-xref-for", "data-xref-type", "data-link-for"]; t.forEach(e => { n.forEach(t => e.removeAttribute(t)) }) } const ga = yn({ en: { duplicateMsg: e => `Duplicate definition(s) of '${e}'`, duplicateTitle: "This is defined more than once in the document." }, ja: { duplicateMsg: e => `'${e}' `, duplicateTitle: "" }, de: { duplicateMsg: e => `Mehrfache Definition von '${e}'`, duplicateTitle: "Das Dokument enthlt mehrere Definitionen dieses Eintrags." } }); function ba(e) { const t = new Map, n = []; for (const r of io.get(e)) { const { dfnFor: o = "" } = r.dataset; if (t.has(o)) { const e = "dfn" === t.get(o).localName, i = "dfn" === r.localName; if (e) { if (!i) continue; n.push(r) } } t.set(o, r), _n(r, "dfn", e) } return { result: t, duplicates: n } } function ya(e, t = "") { switch (e.localName) { case "a": if (e.querySelector("code")) return !0; break; default: { const { dataset: n } = e; if (e.textContent.trim() === t) return !0; if (n.title === t) return !0; if (n.lt || n.localLt) { const e = []; return n.lt && e.push(...n.lt.split("|")), n.localLt && e.push(...n.localLt.split("|")), e.includes(t) } } }return !1 } function va(e) { e.forEach(e => { dn(e, `Found linkless \`<a>\` element with text "${e.textContent}" but no matching \`<dfn>\``, "Linking error: not matching `<dfn>`") }) } var wa = Object.freeze({ __proto__: null, name: "core/link-to-dfn", run: async function (e) { const t = function () { const e = new Wn; for (const t of io.keys()) { const { result: n, duplicates: r } = ba(t); e.set(t, n), r.length > 0 && pn(r, ga.duplicateMsg(t), ga.duplicateTitle) } return e }(), n = [], o = []; if (document.querySelectorAll("a[data-cite=''], a:not([href]):not([data-cite]):not(.logo):not(.externalDFN)").forEach(e => { const r = An(e); r.some(r => function (e, t, n, r) { const { linkFor: o } = t.dataset; if (!n.has(e.title) || !n.get(e.title).get(e.for)) return !1; const i = n.get(e.title).get(e.for); if (i.dataset.cite) t.dataset.cite = i.dataset.cite; else if (o && !n.get(o)) r.push(t); else if (i.classList.contains("externalDFN")) { const e = i.dataset.lt ? i.dataset.lt.split("|") : []; t.dataset.lt = e[0] || i.textContent, r.push(t) } else "partial" === t.dataset.idl ? r.push(t) : (t.href = "#" + i.id, t.classList.add("internalDFN")); t.hasAttribute("data-link-type") || (t.dataset.linkType = "idl" in i.dataset ? "idl" : "dfn"); (function (e) { if (e.closest("code,pre")) return !0; if (1 !== e.childNodes.length) return !1; const [t] = e.childNodes; return "code" === t.localName })(i) && function (e, t) { const n = e.textContent.trim(), r = t.dataset.hasOwnProperty("idl"), o = ya(e) || ya(t, n); r && !o || Nn(e, document.createElement("code")) }(t, i); return !0 }(r, e, t, n)) || 0 === r.length || ("" === e.dataset.cite ? o.push(e) : n.push(e)) }), va(o), e.xref) { n.push(...function () { const e = document.querySelectorAll("a[data-cite]:not([data-cite='']):not([data-cite*='#']), dfn[data-cite]:not([data-cite='']):not([data-cite*='#'])"), t = document.querySelectorAll("dfn.externalDFN"); return [...e].filter(e => { if ("" === e.textContent.trim()) return !1; const t = e.closest("[data-cite]"); return !t || "" !== t.dataset.cite }).concat(...t) }()); try { await la(e, n) } catch (e) { console.error(e), va(n) } } else va(n); await ta(document, e), r("end", "core/link-to-dfn") } }); const xa = yn({ en: { heading: "Index", headingExternal: "Terms defined by reference", headlingLocal: "Terms defined by this specification", dfnOf: "definition of" } }), ka = new Set(["attribute", "callback", "dict-member", "dictionary", "element-attr", "element", "enum-value", "enum", "exception", "extended-attribute", "interface", "method", "typedef"]); function $a(e) { const t = e.dataset, n = t.dfnType || t.idl || t.linkType || ""; switch (n) { case "": case "dfn": return ""; default: return n } } function Ca(e) { const t = e.closest("[data-dfn-for]:not([data-dfn-for=''])"); return t ? t.dataset.dfnFor : "" } function Sa(e, t, n = "") { if (n.startsWith("[[")) { return `internal slot for <code>${Ca(e)}</code>` } switch (t) { case "dict-member": case "method": case "attribute": case "enum-value": return `${"dict-member" === t ? "member" : t.replace("-", " ")} for <code>${Ca(e)}</code>`; case "interface": case "dictionary": case "enum": return t; case "constructor": return `for <code>${Ca(e)}</code>`; default: return "" } } function _a() { document.querySelectorAll("#index-defined-here li[data-id]").forEach(e => e.append((e => { const t = "" + document.getElementById(e).closest("section").querySelector(".secno").textContent.trim(); return Qt`<span class="print-only">${t}</span>` })(e.dataset.id))) } function Ea(e) { const t = new Set, n = new Map, r = document.querySelectorAll("a[data-cite]"); for (const o of r) { if (!o.dataset.cite) continue; const r = o.href; if (t.has(r)) continue; const { type: i, linkFor: s } = o.dataset, a = da(o); if (!a) continue; const c = e(o).key.toUpperCase(); (n.get(c) || n.set(c, []).get(c)).push({ term: a, type: i, linkFor: s, elem: o }), t.add(r) } return n } function Ta(e) {
        const { elem: t } = e, n = function (e) { const { term: t, type: n, linkFor: r } = e; let o = t; ka.has(n) && ("extended-attribute" === n && (o = `[${o}]`), o = `<code>${o}</code>`); const i = Ra.has(t) ? "type" : Aa.get(n); i && (o += " " + i); if (r) { let e = r; /\s/.test(r) || (e = `<code>${e}</code>`), "element-attr" === n && (e += " element"), o += ` (for ${e})` } return o }(e), r = Qt`<li>
    <span class="index-term" data-href="${t.href}">${{ html: n }}</span>
  </li>`; return _n(r.querySelector("span"), "index-term"), r
      } const Aa = new Map([["attribute", "attribute"], ["element-attr", "attribute"], ["element", "element"], ["enum", "enum"], ["exception", "exception"], ["extended-attribute", "extended attribute"], ["interface", "interface"]]), Ra = new Set(["boolean", "byte", "octet", "short", "unsigned short", "long", "unsigned long", "long long", "unsigned long long", "float", "unrestricted float", "double", "unrestricted double", "void", "any", "object", "symbol"]); function La(e) { e.querySelectorAll("#index-defined-elsewhere li[data-spec]").forEach(e => e.removeAttribute("data-spec")), e.querySelectorAll("#index-defined-here li[data-id]").forEach(e => e.removeAttribute("data-id")) } var Na = Object.freeze({
        __proto__: null, name: "core/dfn-index", run: async function (e) {
          const t = document.querySelector("section#index"); if (!t) return; const n = document.createElement("style"); n.textContent = await async function () { try { return (await Promise.resolve().then((function () { return kl }))).default } catch { return Gn("dfn-index.css") } }(), document.head.appendChild(n), t.classList.add("appendix"), t.querySelector("h2") || t.prepend(Qt`<h2>${xa.heading}</h2>`); const r = ea(e), i = Qt`<section id="index-defined-here">
    <h3>${xa.headlingLocal}</h3>
    ${function () {
              const e = function () { const e = new Map, t = document.querySelectorAll("dfn:not([data-cite])"); for (const n of t) { if (!n.id) continue; const t = bn(n.textContent); (e.get(t) || e.set(t, []).get(t)).push(n) } return [...e].sort(([e], [t]) => e.slice(e.search(/\w/)).localeCompare(t.slice(t.search(/\w/)))) }(); return Qt`<ul class="index">
    ${e.map(([e, t]) => function (e, t) {
                const n = (e, t, n) => {
                  const r = "#" + e.id; return Qt`<li data-id=${e.id}>
      <a class="index-term" href="${r}">${{ html: t }}</a> ${n ? { html: n } : ""}
    </li>`}; if (1 === t.length) { const r = t[0], o = $a(r), i = function (e, t, n) { let r = n; "enum-value" === t && (r = `"${r}"`); (ka.has(t) || e.dataset.idl || e.closest("code")) && (r = `<code>${r}</code>`); return r }(r, o, e), s = Sa(r, o, e); return n(r, i, s) } return Qt`<li>
    ${e}
    <ul>
      ${t.map(t => { const r = Sa(t, $a(t), e) || xa.dfnOf; return n(t, r) })}
    </ul>
  </li>`}(e, t))}
  </ul>`}()}
  </section>`; t.append(i); const s = Qt`<section id="index-defined-elsewhere">
    <h3>${xa.headingExternal}</h3>
    ${function (e) {
              const t = [...Ea(e).entries()].sort(([e], [t]) => e.localeCompare(t)); return Qt`<ul class="index">
    ${t.map(([e, t]) => Qt`<li data-spec="${e}">
        ${Ui(e)} defines the following:
        <ul>
          ${t.sort((e, t) => e.term.localeCompare(t.term)).map(Ta)}
        </ul>
      </li>`)}
  </ul>`}(r)}
  </section>`; t.append(s), o("toc", _a, { once: !0 }), o("beforesave", La)
        }
      }); var Da = Object.freeze({ __proto__: null, name: "core/contrib", run: async function (e) { if (!document.getElementById("gh-contributors")) return; if (!e.github) { return void r("error", "Requested list of contributors from GitHub, but [`github`](https://github.com/w3c/respec/wiki/github) configuration option is not set.") } const t = e.editors.map(e => e.name), n = `${e.github.apiBase}/${e.github.fullName}/`; await async function (e, t) { const n = document.getElementById("gh-contributors"); if (!n) return; n.textContent = "Fetching list of contributors..."; const o = await async function () { const { href: n } = new URL("contributors", t); try { const t = await kn(n); if (!t.ok) throw new Error(`Request to ${n} failed with status code ${t.status}`); return (await t.json()).filter(t => !e.includes(t.name || t.login)) } catch (e) { return r("error", "Error loading contributors from GitHub."), console.error(e), null } }(); null !== o ? function (e, t) { const n = e.sort((e, t) => { const n = e.name || e.login, r = t.name || t.login; return n.toLowerCase().localeCompare(r.toLowerCase()) }); if ("UL" === t.tagName) return void Qt(t)`${n.map(({ name: e, login: t }) => `<li><a href="https://github.com/${t}">${e || t}</a></li>`)}`; const r = n.map(e => e.name || e.login); t.textContent = gn(r) }(o, n) : n.textContent = "Failed to fetch contributors." }(t, n) } }); var Pa = Object.freeze({ __proto__: null, name: "core/fix-headers", run: function () { [...document.querySelectorAll("section:not(.introductory)")].map(e => e.querySelector("h1, h2, h3, h4, h5, h6")).filter(e => e).forEach(e => { Rn(e, "h" + Math.min(function (e, t) { const n = []; for (; e != e.ownerDocument.body;)e.matches(t) && n.push(e), e = e.parentElement; return n }(e, "section").length + 1, 6)) }) } }); const ja = ["h2", "h3", "h4", "h5", "h6"], Ia = ["h1", ...ja], Oa = yn({ en: { toc: "" }, zh: { toc: "" }, ko: { toc: "" }, ja: { toc: "" }, nl: { toc: "Inhoudsopgave" }, es: { toc: "Tabla de Contenidos" }, de: { toc: "Inhaltsverzeichnis" } }); function qa(e, t) { const n = Qt`<a href="${"#" + t}" class="tocxref" />`; var r; return n.append(...e.cloneNode(!0).childNodes), (r = n).querySelectorAll("a").forEach(e => { const t = Rn(e, "span"); t.className = "formerLink", t.removeAttribute("href") }), r.querySelectorAll("dfn").forEach(e => { Rn(e, "span").removeAttribute("id") }), Qt`<li class="tocline">${n}</li>` } var Wa = Object.freeze({
        __proto__: null, name: "core/structure", run: function (e) {
          if ("tocIntroductory" in e == !1 && (e.tocIntroductory = !1), "maxTocLevel" in e == !1 && (e.maxTocLevel = 1 / 0), function () { const e = function () { const e = Ia.map(e => `section:not(.introductory) ${e}:first-child`).join(","); return [...document.querySelectorAll(e)].filter(e => !e.closest("section.introductory")) }(); if (!e.length) return; e.forEach(e => { const t = "h" + Math.min(Dn(e, "section").length + 1, 6); e.localName !== t && Rn(e, t) }) }(), !e.noTOC) {
            const t = function e(t, n, { prefix: r = "" } = {}) { let o = !1, i = 0, s = 1; if (r.length && !r.endsWith(".") && (r += "."), 0 === t.length) return null; const a = Qt`<ol class="toc"></ol>`; for (const c of t) { !c.isAppendix || r || o || (i = s, o = !0); let t = c.isIntro ? "" : o ? "ABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(s - i) : r + s; const l = Math.ceil(t.length / 2); if (1 === l && (t += ".", c.header.before(document.createComment("OddPage"))), c.isIntro || (s += 1, c.header.prepend(Qt`<bdi class="secno">${t} </bdi>`)), l <= n) { const r = c.header.id || c.element.id, o = qa(c.header, r), i = e(c.subsections, n, { prefix: t }); i && o.append(i), a.append(o) } } return a }(function e(t, { tocIntroductory: n = !1 } = {}) { const r = n ? t.querySelectorAll(":scope > section") : t.querySelectorAll(":scope > section:not(.introductory)"), o = []; for (const t of r) { const r = t.classList.contains("notoc"); if (!t.children.length || r) continue; const i = t.children[0]; if (!ja.includes(i.localName)) continue; const s = i.textContent; _n(t, null, s), o.push({ element: t, header: i, title: s, isIntro: t.classList.contains("introductory"), isAppendix: t.classList.contains("appendix"), subsections: e(t, { tocIntroductory: n }) }) } return o }(document.body, { tocIntroductory: e.tocIntroductory }), e.maxTocLevel); t && function (e) {
              if (!e) return; const t = Qt`<nav id="toc"></nav>`, n = Qt`<h2 class="introductory">${Oa.toc}</h2>`; _n(n), t.append(n, e); const r = document.getElementById("toc") || document.getElementById("sotd") || document.getElementById("abstract"); r && ("toc" === r.id ? r.replaceWith(t) : r.after(t)); const o = Qt`<p role="navigation" id="back-to-top">
    <a href="#title"><abbr title="Back to Top">&uarr;</abbr></a>
  </p>`; document.body.append(o)
            }(t)
          } r("toc")
        }
      }); const Ma = yn({ en: { informative: "This section is non-normative." }, nl: { informative: "Dit onderdeel is niet normatief." }, uk: { informative: "    ." }, ko: { informative: "  ." }, ja: { informative: "" }, de: { informative: "Dieser Abschnitt ist nicht normativ." } }); var za = Object.freeze({ __proto__: null, name: "core/informative", run: function () { Array.from(document.querySelectorAll("section.informative")).map(e => e.querySelector("h2, h3, h4, h5, h6")).filter(e => e).forEach(e => { e.after(Qt`<p><em>${Ma.informative}</em></p>`) }) } }); var Fa = Object.freeze({
        __proto__: null, name: "core/id-headers", run: function (e) {
          const t = document.querySelectorAll("section:not(.head):not(.introductory) h2, h3, h4, h5, h6"); for (const n of t) {
            let t = n.id; t || (_n(n), t = n.parentElement.id || n.id), e.addSectionLinks && n.appendChild(Qt`
      <a href="${"#" + t}" class="self-link" aria-label=""></a>
    `)
          }
        }
      }); const Ua = new Set(["and_chr", "and_ff", "and_uc", "android", "bb", "chrome", "edge", "firefox", "ie", "ios_saf", "op_mini", "op_mob", "opera", "safari", "samsung"]); if (!document.querySelector("link[rel='preconnect'][href='https://respec.org']")) { const e = ln({ hint: "preconnect", href: "https://respec.org" }); document.head.appendChild(e) } const Ba = async function () { try { return (await Promise.resolve().then((function () { return $l }))).default } catch { return Gn("caniuse.css") } }(); var Ha = Object.freeze({
        __proto__: null, name: "core/caniuse", run: async function (e) {
          if (!e.caniuse) return; const t = function (e) { const t = { versions: 4 }; if ("string" == typeof e.caniuse) return { feature: e.caniuse, ...t }; const n = { ...t, ...e.caniuse }, { browsers: o } = n; if (Array.isArray(o)) { const e = o.filter(e => !Ua.has(e)); if (e.length) { r("warn", `Ignoring invalid browser(s): ${e.map(e => `"\`${e}\`"`).join(", ")} in [\`respecConfig.caniuse.browsers\`](https://github.com/w3c/respec/wiki/caniuse)`) } } return n }(e); if (e.caniuse = t, !t.feature) return; const n = new URL(t.feature, "https://caniuse.com/").href, i = await Ba; document.head.appendChild(Qt`<style class="removeOnSave">
    ${i}
  </style>`); const s = document.querySelector(".head dl"), a = (async () => { try { const e = t.apiURL || "https://respec.org/caniuse/", n = await async function (e, t) { const { feature: n, versions: r, browsers: o } = t, i = new URLSearchParams; i.set("feature", n), i.set("versions", r), Array.isArray(o) && i.set("browsers", o.join(",")); i.set("format", "html"); const s = `${e}?${i.toString()}`, a = await fetch(s); if (!a.ok) { const { status: e, statusText: t } = a; throw new Error(`Failed to get caniuse data: (${e}) ${t}`) } return await a.text() }(e, t); return Qt`${{ html: n }}` } catch (e) { console.error(e); return r("error", `Couldn't find feature "${t.feature}" on caniuse.com? Please check the feature key on [caniuse.com](https://caniuse.com)`), Qt`<a href="${n}">caniuse.com</a>` } })(), c = Qt`<dt class="caniuse-title">Browser support:</dt>
    <dd class="caniuse-stats">
      ${{ any: a, placeholder: "Fetching data from caniuse.com..." }}
    </dd>`; s.append(...c.childNodes), await a, r("amend-user-config", { caniuse: t.feature }), o("beforesave", e => {
            Qt.bind(e.querySelector(".caniuse-stats"))`
      <a href="${n}">caniuse.com</a>`
          })
        }
      }); const Ga = { chrome: "Chrome", chrome_android: "Chrome Android", edge: "Edge", edge_mobile: "Edge Mobile", firefox: "Firefox", firefox_android: "Firefox Android", ie: "Internet Explorer", opera: "Opera", opera_android: "Opera Android", safari: "Safari", safari_ios: "Safari iOS", samsunginternet_android: "Samsung Internet", webview_android: "WebView Android" }, Va = async function () { try { return (await Promise.resolve().then((function () { return Cl }))).default } catch { return Gn("mdn-annotation.css") } }(); function Za(e, t) { return e ? kn(e, t).then(e => e.json()) : {} } function Ya(e, t) {
        const { slug: n, summary: r } = t; e.innerHTML += '<button onclick="toggleMDNStatus(this.parentNode)" aria-label="Expand MDN details"><b>MDN</b></button>'; const o = n.slice(n.indexOf("/") + 1), i = Qt`
    <div>
      <a title="${r}" href="${"https://developer.mozilla.org/en-US/docs/Web/" + n}">${o}</a>
    </div>
  `; !function (e, t) {
          if (!t.support) return void (e.innerHTML += '<p class="nosupportdata">No support data.</p>'); const n = Qt`<p class="mdnsupport">
    ${function (e) {
              function t(e, t, n) {
                const r = "Unknown" === t ? "?" : t, o = `${e} ${t.toLowerCase()}`; return Qt`<span class="${o}">
      <span class="browser-name">${Ga[e]}</span>
      <span class="version">${n || r}</span>
    </span>`} function n(e, n) { if (n.version_removed) return t(e, "No", ""); const r = n.version_added; return r ? "boolean" == typeof r ? t(e, r ? "Yes" : "No", "") : t(e, "Yes", r + "+") : t(e, "Unknown", "") } const r = []; return Object.keys(Ga).forEach(o => { e[o] ? Array.isArray(e[o]) ? e[o].forEach(e => { r.push(n(o, e)) }) : r.push(n(o, e[o])) : r.push(t(o, "Unknown", "")) }), r
            }(t.support)}
  </p>`; e.appendChild(n)
        }(i, t), e.appendChild(i)
      } var Xa = Object.freeze({
        __proto__: null, name: "core/mdn-annotation", run: async function (e) {
          const { shortName: t, mdn: n } = e; if (!t || !n) return; const r = n.maxAge || 864e5, o = n.specMapUrl || "https://raw.githubusercontent.com/w3c/mdn-spec-links/master/SPECMAP.json", i = n.baseJsonPath || "https://w3c.github.io/mdn-spec-links/", s = await Za(o, r); if (!Object.values(s).some(e => e === t + ".json")) return; const a = await Za(`${i}/${t}.json`, r), c = await Va; document.head.appendChild(Qt`<style>
      ${c}
    </style>`), document.head.appendChild(Qt`<script>
    function toggleMDNStatus(div) {
      div.parentNode.classList.toggle("wrapped");
    }
  </script>`), [...document.querySelectorAll("[id]")].filter(e => -1 === ["STYLE", "SCRIPT", "BODY"].indexOf(e.tagName) && a[e.id] && Array.isArray(a[e.id])).forEach(e => { const t = a[e.id], n = function (e) { const t = e.closest("section"), { previousElementSibling: n, parentNode: r } = t; if (n && n.classList.contains("mdn")) return n; const o = Qt`<aside class="mdn before wrapped"></aside>`; return r.insertBefore(o, t), o }(e); t.map(e => { const t = document.createElement("div"); return Ya(t, e), t }).forEach(e => n.appendChild(e)) })
        }
      }); const Ka = new Map([["text/html", "html"], ["application/xml", "xml"]]); function Ja(e, t = document) {
        const n = Ka.get(e); if (!n) { const t = [...Ka.values()].join(", "); throw new TypeError(`Invalid format: ${e}. Expected one of: ${t}.`) } const o = function (e, t) {
          const n = t.cloneNode(!0); !function (e) {
            const { head: t, body: n, documentElement: o } = e; On(e), e.querySelectorAll(".removeOnSave, #toc-nav").forEach(e => e.remove()), n.classList.remove("toc-sidebar"), un(o); const i = e.createDocumentFragment(), s = e.querySelector("meta[name='viewport']"); s && t.firstChild !== s && i.appendChild(s); let a = e.querySelector("meta[charset], meta[content*='charset=']"); a || (a = Qt`<meta charset="utf-8" />`); i.appendChild(a); const c = "ReSpec " + (window.respecVersion || "Developer Channel"), l = Qt`
    <meta name="generator" content="${c}" />
  `; i.appendChild(l), t.prepend(i), r("beforesave", o)
          }(n); let o = ""; switch (e) { case "xml": o = (new XMLSerializer).serializeToString(n); break; default: n.doctype && (o += (new XMLSerializer).serializeToString(n.doctype)), o += n.documentElement.outerHTML }return o
        }(n, t); return `data:${e};charset=utf-8,${encodeURIComponent(o)}`
      } t("core/exporter", { rsDocToDataURL: Ja }); const Qa = yn({ en: { save_snapshot: "Export" }, nl: { save_snapshot: "Bewaar Snapshot" }, ja: { save_snapshot: "" }, de: { save_snapshot: "Exportieren" } }), ec = new URL("https://labs.w3.org/epub-generator/cgi-bin/epub-generator.py"); ec.searchParams.append("type", "respec"), ec.searchParams.append("url", document.location.href); const tc = [{ id: "respec-save-as-html", fileName: "index.html", title: "HTML", type: "text/html", get href() { return Ja(this.type) } }, { id: "respec-save-as-xml", fileName: "index.xhtml", title: "XML", type: "application/xml", get href() { return Ja(this.type) } }, { id: "respec-save-as-epub", fileName: "spec.epub", title: "EPUB 3", type: "application/epub+zip", href: ec.href }]; function nc(e) {
        const { id: t, href: n, fileName: r, title: o, type: i } = e; return Qt`<a
    href="${n}"
    id="${t}"
    download="${r}"
    type="${i}"
    class="respec-save-button"
    onclick=${() => wr.closeModal()}
    >${o}</a
  >`} const rc = {
    async show(e) {
      await document.respecIsReady; const t = Qt`<div class="respec-save-buttons">
      ${tc.map(nc)}
    </div>`; wr.freshModal(Qa.save_snapshot, t, e)
    }
  }, oc = "download" in HTMLAnchorElement.prototype; let ic; oc && (ic = wr.addCommand(Qa.save_snapshot, (function () { if (!oc) return; rc.show(ic) }), "Ctrl+Shift+Alt+S", "")); var sc = Object.freeze({ __proto__: null, name: "ui/save-html", exportDocument: function (e, t) { const n = "Exporting via ui/save-html module's `exportDocument()` is deprecated and will be removed. Use core/exporter `rsDocToDataURL()` instead."; return r("warn", n), console.warn(n), Ja(t) } }); const ac = yn({ en: { search_specref: "Search Specref" }, nl: { search_specref: "Doorzoek Specref" }, ja: { search_specref: "" }, de: { search_specref: "Spezifikationen durchsuchen" } }), cc = wr.addCommand(ac.search_specref, (function () { hc(), wr.freshModal(ac.search_specref, lc, cc); lc.querySelector("input[type=search]").focus() }), "Ctrl+Shift+Alt+space", ""), lc = document.createElement("form"), uc = Qt.bind(lc), dc = Qt.bind(document.createElement("div")); function pc([e, t]) {
    return Qt.wire(t)`
    <dt>
      [${e}]
    </dt>
    <dd>${Hi(t)}</dd>
  `} lc.id = "specref-ui", lc.addEventListener("submit", async e => { e.preventDefault(); const { searchBox: t } = lc, n = t.value; if (!n) return void t.focus(); hc({ state: "Searching Specref" }); const r = new URL("https://specref.herokuapp.com/search-refs"); r.searchParams.set("q", n); const o = new URL("https://specref.herokuapp.com/reverse-lookup"); o.searchParams.set("urls", n); try { const e = performance.now(), i = await Promise.all([fetch(r).then(e => e.json()), fetch(o).then(e => e.json())]), { checked: s } = lc.includeVersions, a = function ({ includeVersions: e = !1 } = {}) { return (...t) => { const n = Object.assign({}, ...t), r = new Map(Object.entries(n)); return Array.from(r).filter(([, e]) => e.aliasOf).map(([e]) => e).reduce((e, t) => e.delete(t) && e, r), e || Array.from(r.values()).filter(e => "object" == typeof e && "versions" in e).flat().forEach(e => { r.delete(e) }), Array.from(r).filter(([, e]) => "object" != typeof e).forEach(([e]) => r.delete(e)), r } }({ includeVersions: s }); hc({ query: n, results: a(...i), state: "", timeTaken: Math.round(performance.now() - e) / 1e3 }) } catch (e) { console.error(e), hc({ state: "Error! Couldn't do search." }) } finally { t.focus() } }); const fc = Qt.wire()`
  <header>
    <p>
      An Open-Source, Community-Maintained Database of
      Web Standards & Related References.
    </p>
  </header>
  <div class="searchcomponent">
    <input
      name="searchBox"
      type="search"
      aria-label="Search"
      autocomplete="off"
      placeholder="Keywords, titles, authors, urls">
    <button
      type="submit">
        Search
    </button>
    <label>
      <input type="checkbox" name="includeVersions"> Include all versions.
    </label>
  </div>
`; function hc({ state: e = "", results: t, timeTaken: n, query: r } = {}) {
    t ? uc`
    <div>${fc}</div>
    <p class="state" hidden="${!e}">
      ${e}
    </p>
    <section hidden="${!t}" aria-live="polite">${t ? function (e, t, n) {
        if (!e.size) return dc`
      <p class="state">
        Your search - <strong> ${t} </strong> -
        did not match any references.
      </p>
    `; const r = Array.from(e).slice(0, 99).map(pc).reduce((e, t) => e.concat(t), []); return dc`
    <p class="result-stats">
      ${e.size} results (${n} seconds).
      ${e.size > 99 ? "First 100 results." : ""}
    </p>
    <dl class="specref-results">${r}</dl>
  `}(t, r, n) : []}</section>
  `: uc`<div>${fc}</div>`
  } var mc = Object.freeze({ __proto__: null }); const gc = yn({ en: { definition_list: "Definitions", list_of_definitions: "List of Definitions" }, nl: { definition_list: "Lijst van Definities", list_of_definitions: "Lijst van Definities" }, ja: { definition_list: "", list_of_definitions: "" }, de: { definition_list: "Definitionen", list_of_definitions: "Liste der Definitionen" } }), bc = wr.addCommand(gc.definition_list, (function () {
    const e = Array.from(io).sort(([e], [t]) => e.localeCompare(t)).map(([, [e]]) => Qt.wire(e, ":li>a")`
        <li>
          <a href="${"#" + e.id}">
            ${e.textContent}
          </a>
          ${function (e) { if (e.hasAttribute("data-export")) return Qt`<span class="dfn-status exported">exported</span>`; return null }(e)} ${function (e) { if (!document.querySelector(`a[href^="#${e.id}"]`)) return Qt`<span class="dfn-status unused">unused</span>`; return null }(e)}
        </li>
      `); vc`${e}`, wr.freshModal(gc.list_of_definitions, yc, bc)
  }), "Ctrl+Shift+Alt+D", ""), yc = document.createElement("ul"); yc.classList.add("respec-dfn-list"); const vc = Qt.bind(yc); yc.addEventListener("click", e => { e.target instanceof HTMLElement && e.target.matches("a") && (wr.closeModal(), e.stopPropagation()) }); var wc = Object.freeze({ __proto__: null }); const xc = yn({ en: { about_respec: "About" }, zh: { about_respec: "" }, nl: { about_respec: "Over" }, ja: { about_respec: "" }, de: { about_respec: "ber" } }); window.respecVersion = window.respecVersion || "Developer Edition"; const kc = document.createElement("div"), $c = Qt.bind(kc), Cc = wr.addCommand(`${xc.about_respec} ${window.respecVersion}`, (function () {
    const e = []; "getEntriesByType" in performance && performance.getEntriesByType("measure").sort((e, t) => t.duration - e.duration).map(({ name: e, duration: t }) => ({ name: e, duration: t > 1e3 ? Math.round(t / 1e3) + " second(s)" : t.toFixed(2) + " milliseconds" })).map(Sc).forEach(t => { e.push(t) }); $c`
  <p>
    ReSpec is a document production toolchain, with a notable focus on W3C specifications.
  </p>
  <p>
    <a href='https://github.com/w3c/respec/wiki'>Documentation</a>,
    <a href='https://github.com/w3c/respec/issues'>Bugs</a>.
  </p>
  <table border="1" width="100%" hidden="${!e.length}">
    <caption>
      Loaded plugins
    </caption>
    <thead>
      <tr>
        <th>
          Plugin Name
        </th>
        <th>
          Processing time
        </th>
      </tr>
    </thead>
    <tbody>${e}</tbody>
  </table>
`, wr.freshModal(`${xc.about_respec} - ${window.respecVersion}`, kc, Cc)
  }), "Ctrl+Shift+Alt+A", ""); function Sc({ name: e, duration: t }) {
    return Qt`
    <tr>
      <td><a href="${`https://github.com/w3c/respec/blob/develop/src/${e}.js`}">${e}</a></td>
      <td>${t}</td>
    </tr>
  `} var _c = Object.freeze({ __proto__: null }); var Ec = Object.freeze({ __proto__: null, name: "core/seo", run: function () { const e = document.querySelector("#abstract p:first-of-type"); if (!e) return; const t = e.textContent.replace(/\s+/, " ").trim(), n = document.createElement("meta"); n.name = "description", n.content = t, document.head.appendChild(n) } }); function Tc({ name: e, url: t, mailto: n, company: r, companyURL: o }) { const i = { type: "Person", name: e, url: t, "foaf:mbox": n }; return (r || o) && (i.worksFor = { name: r, url: o }), i } function Ac(e) { const { href: t, title: n, href: r } = e, o = { id: t, type: "TechArticle", name: n, url: r }; return e.authors && (o.creator = e.authors.map(e => ({ name: e }))), e.rawDate && (o.publishedDate = e.rawDate), e.isbn && (o.identifier = e.isbn), e.publisher && (o.publisher = { name: e.publisher }), o } var Rc = Object.freeze({ __proto__: null, name: "w3c/seo", run: async function (e) { if (!e.canonicalURI) switch (e.specStatus) { case "CG-DRAFT": case "BG-DRAFT": case "unofficial": return }const t = e.shortName ? `https://www.w3.org/TR/${e.shortName}/` : null; switch (e.canonicalURI) { case "edDraft": e.edDraftURI ? e.canonicalURI = new URL(e.edDraftURI, document.location.href).href : (r("warn", "Canonical URI set to edDraft, but no edDraftURI is set in configuration"), e.canonicalURI = null); break; case "TR": t ? e.canonicalURI = t : (r("warn", "Canonical URI set to TR, but no shortName is set in configuration"), e.canonicalURI = null); break; default: if (e.canonicalURI) try { e.canonicalURI = new URL(e.canonicalURI, document.location.href).href } catch (t) { r("warn", "CanonicalURI is an invalid URL: " + t.message), e.canonicalURI = null } else t && (e.canonicalURI = t) }if (e.canonicalURI) { const t = document.createElement("link"); t.setAttribute("rel", "canonical"), t.setAttribute("href", e.canonicalURI), document.head.appendChild(t) } e.doJsonLd && await async function (e, t) { const n = ["TechArticle"]; e.rdfStatus && n.push(e.rdfStatus); const r = { "@context": ["http://schema.org", { "@vocab": "http://schema.org/", "@language": t.documentElement.lang || "en", w3p: "http://www.w3.org/2001/02pd/rec54#", foaf: "http://xmlns.com/foaf/0.1/", datePublished: { "@type": "http://www.w3.org/2001/XMLSchema#date" }, inLanguage: { "@language": null }, isBasedOn: { "@type": "@id" }, license: { "@type": "@id" } }], id: e.canonicalURI || e.thisVersion, type: n, name: document.title, inLanguage: t.documentElement.lang || "en", license: e.licenseInfo.url, datePublished: e.dashDate, copyrightHolder: { name: "World Wide Web Consortium", url: "https://www.w3.org/" }, discussionUrl: e.issueBase, alternativeHeadline: e.subtitle, isBasedOn: e.prevVersion }; if (e.additionalCopyrightHolders) { const t = Array.isArray(e.additionalCopyrightHolders) ? e.additionalCopyrightHolders : [e.additionalCopyrightHolders]; r.copyrightHolder = [r.copyrightHolder, ...t.map(e => ({ name: e }))] } const o = t.head.querySelector("meta[name=description]"); o && (r.description = o.content); e.editors && (r.editor = e.editors.map(Tc)); e.authors && (r.contributor = e.authors.map(Tc)); const i = [...e.normativeReferences, ...e.informativeReferences], s = await Promise.all(i.map(e => ji(e))); r.citation = s.filter(e => "object" == typeof e).map(Ac); const a = t.createElement("script"); a.type = "application/ld+json", a.textContent = JSON.stringify(r, null, 2), t.head.appendChild(a) }(e, document) } }); const Lc = ln({ hint: "preload", href: "https://www.w3.org/Tools/respec/respec-highlight.js", as: "script" }); document.head.appendChild(Lc); const Nc = async function () { const e = await async function () { try { return (await Promise.resolve().then((function () { return Sl }))).default } catch { return Hn("worker/respec-worker.js") } }(), t = URL.createObjectURL(new Blob([e], { type: "application/javascript" })); return new Worker(t) }(); t("core/worker", Nc.then(e => ({ worker: e }))); const Dc = function (e, t = 0) { const n = function* (e, t) { for (; ;)yield `${e}:${t}`, t++ }(e, t); return () => n.next().value }("highlight"), Pc = async function () { try { return (await Promise.resolve().then((function () { return _l }))).default } catch { return Gn("highlight.css") } }(); async function jc(e) { e.setAttribute("aria-busy", "true"); const t = (n = e.classList, Array.from(n).filter(e => "highlight" !== e && "nolinks" !== e).map(e => e.toLowerCase())); var n; let r; try { r = await async function (e, t) { const n = { action: "highlight", code: e, id: Dc(), languages: t }, r = await Nc; return r.postMessage(n), new Promise((e, t) => { const o = setTimeout(() => { t(new Error("Timed out waiting for highlight.")) }, 4e3); r.addEventListener("message", (function t(i) { const { data: { id: s, language: a, value: c } } = i; s === n.id && (r.removeEventListener("message", t), clearTimeout(o), e({ language: a, value: c })) })) }) }(e.innerText, t) } catch (e) { return void console.error(e) } const { language: o, value: i } = r; switch (e.localName) { case "pre": e.classList.remove(o), e.innerHTML = `<code class="hljs${o ? " " + o : ""}">${i}</code>`, e.classList.length || e.removeAttribute("class"); break; case "code": e.innerHTML = i, e.classList.add("hljs"), o && e.classList.add(o) }e.setAttribute("aria-busy", "false") } var Ic = Object.freeze({
      __proto__: null, name: "core/highlight", run: async function (e) {
        if (e.noHighlightCSS) return; const t = [...document.querySelectorAll("\n    pre:not(.idl):not(.nohighlight) > code:not(.nohighlight),\n    pre:not(.idl):not(.nohighlight),\n    code.highlight\n  ")].filter(e => "pre" !== e.localName || !e.querySelector("code")); if (!t.length) return; const n = t.filter(e => e.textContent.trim()).map(jc), r = await Pc; document.head.appendChild(Qt`<style>
      ${r}
    </style>`), await Promise.all(n)
      }
    }); const Oc = yn({ en: { missing_test_suite_uri: "Found tests in your spec, but missing '[`testSuiteURI`](https://github.com/w3c/respec/wiki/testSuiteURI)' in your ReSpec config.", tests: "tests", test: "test" }, ja: { missing_test_suite_uri: "ReSpec  '[`testSuiteURI`](https://github.com/w3c/respec/wiki/testSuiteURI)' ", tests: "", test: "" }, de: { missing_test_suite_uri: "Die Spezifikation enthlt Tests, aber in der ReSpec-Konfiguration ist keine '[`testSuiteURI`](https://github.com/w3c/respec/wiki/testSuiteURI)' angegeben.", tests: "Tests", test: "Test" } }); function qc(e) {
      const t = [], [n] = new URL(e).pathname.split("/").reverse(), r = n.split("."); let [o] = r; if (r.find(e => "https" === e)) { const e = document.createElement("span"); e.textContent = "", e.setAttribute("aria-label", "requires a secure connection"), e.setAttribute("title", "Test requires HTTPS"), o = o.replace(".https", ""), t.push(e) } if (o.split(".").join("-").split("-").find(e => "manual" === e)) { const e = document.createElement("span"); e.textContent = "", e.setAttribute("aria-label", "the test must be run manually"), e.setAttribute("title", "Manual test"), o = o.replace("-manual", ""), t.push(e) } return Qt`
    <li>
      <a href="${e}">
        ${o}
      </a>
      ${t}
    </li>
  `} function Wc(e, t) { return e.map(e => { try { return new URL(e, t).href } catch { r("warn", "Bad URI: " + e) } }).filter(e => e) } function Mc(e, t) { const n = e.filter((e, t, n) => n.indexOf(e) !== t); n.length && dn(t, "Duplicate tests found", 'To fix, remove duplicates from "data-tests": ' + n.map(e => new URL(e).pathname).join(", ")) } function zc(e) {
    const t = [...new Set(e)]; return Qt`
    <details class="respec-tests-details removeOnSave">
      <summary>
        tests: ${t.length}
      </summary>
      <ul>
        ${t.map(qc)}
      </ul>
    </details>
  `} var Fc = Object.freeze({ __proto__: null, name: "core/data-tests", run: function (e) { const t = [...document.querySelectorAll("[data-tests]")].filter(e => e.dataset.tests); if (t.length) if (e.testSuiteURI) for (const n of t) { const t = Wc(n.dataset.tests.split(/,/gm).map(e => e.trim()), e.testSuiteURI); Mc(t, n); const r = zc(t); n.append(r) } else r("error", Oc.missing_test_suite_uri) } }); function Uc(e) { return ({ textContent: t }, { textContent: n }) => "ascending" === e ? t.localeCompare(n) : n.localeCompare(t) } function Bc(e, t) { return [...e.querySelectorAll(":scope > li")].sort(Uc(t)).reduce((e, t) => (e.appendChild(t), e), document.createDocumentFragment()) } function Hc(e, t) { return [...e.querySelectorAll(":scope > dt")].sort(Uc(t)).reduce((e, t) => { const { nodeType: n, nodeName: r } = t, o = document.createDocumentFragment(); let { nextSibling: i } = t; for (; i && i.nextSibling;) { o.appendChild(i.cloneNode(!0)); const { nodeType: e, nodeName: t } = i.nextSibling; if (e === n && t === r) break; i = i.nextSibling } return o.prepend(t.cloneNode(!0)), e.appendChild(o), e }, document.createDocumentFragment()) } var Gc = Object.freeze({ __proto__: null, name: "core/list-sorter", sortListItems: Bc, sortDefinitionTerms: Hc, run: function () { const e = document.querySelectorAll("[data-sort]"); for (const t of e) { let e; const n = t.dataset.sort || "ascending"; switch (t.localName) { case "dl": e = Hc(t, n); break; case "ol": case "ul": e = Bc(t, n); break; default: r("warning", `ReSpec can't sort ${t.localName} elements.`) }if (e) { const n = document.createRange(); n.selectNodeContents(t), n.deleteContents(), t.appendChild(e) } } } }); const Vc = async function () { try { return (await Promise.resolve().then((function () { return El }))).default } catch { return Gn("var.css") } }(); function Zc(e) { e.stopPropagation(); const { target: t } = e, n = function (e) { const t = e.textContent.trim(), n = e.closest("section"), r = Xc(e), o = [...n.querySelectorAll("var")].filter(e => e.textContent.trim() === t && e.closest("section") === n), i = o[0].classList.contains("respec-hl"); if (Yc.set(r, i), i) return o.forEach(e => Kc(e, r)), []; o.forEach(e => function (e, t) { e.classList.add("respec-hl", t) }(e, r)); return o }(t), r = () => { const e = Xc(t); n.forEach(t => Kc(t, e)), [...Yc.keys()].forEach(e => Yc.set(e, !0)) }; n.length && document.body.addEventListener("click", r, { once: !0 }) } const Yc = new Map([["respec-hl-c1", !0], ["respec-hl-c2", !0], ["respec-hl-c3", !0], ["respec-hl-c4", !0], ["respec-hl-c5", !0], ["respec-hl-c6", !0], ["respec-hl-c7", !0]]); function Xc(e) { const { value: t } = e.classList, n = /respec-hl-\w+/, r = n.test(t) && t.match(n); return r ? r[0] : !0 === Yc.get("respec-hl-c1") ? "respec-hl-c1" : [...Yc.keys()].find(e => Yc.get(e)) || "respec-hl-c1" } function Kc(e, t) { e.classList.remove("respec-hl", t), e.classList.length || e.removeAttribute("class") } var Jc = Object.freeze({ __proto__: null, name: "core/highlight-vars", run: async function (e) { if (!e.highlightVars) return; const t = document.createElement("style"); t.textContent = await Vc, t.classList.add("removeOnSave"), document.head.appendChild(t), document.querySelectorAll("var").forEach(e => e.addEventListener("click", Zc)), o("beforesave", e => { e.querySelectorAll("var.respec-hl").forEach(Kc) }) } }); var Qc = Object.freeze({
      __proto__: null, name: "core/dfn-panel", run: async function () {
        const e = await async function () { try { return (await Promise.resolve().then((function () { return Tl }))).default } catch { return Gn("dfn-panel.css") } }(); let t; document.head.insertBefore(Qt`<style class="removeOnSave">${e}</style>`, document.querySelector("link")), document.body.addEventListener("click", e => {
          const n = e.target; switch (function (e) { const t = !!e.closest("a"); if (e.closest("dfn, .index-term")) return t ? null : "show"; if (e.closest("#dfn-panel")) { if (t) { return e.classList.contains("self-link") ? "hide" : "dock" } return e.closest("#dfn-panel").classList.contains("docked") ? "hide" : null } if (document.getElementById("dfn-panel")) return "hide"; return null }(n)) {
            case "show": {
              t && t.remove(); const r = n.closest("dfn, .index-term"); t = function (e) {
                const { id: t } = e, n = e.dataset.href || "#" + t, r = document.querySelectorAll(`a[href="${n}"]:not(.index-term)`); return Qt`
    <aside class="dfn-panel" id="dfn-panel">
      <b><a class="self-link" href="${n}">Permalink</a></b>
      <b>Referenced in:</b>
      ${function (e, t) { if (!t.length) return Qt`<ul><li>Not referenced in this document.</li></ul>`; const n = new Map; t.forEach((t, r) => { const o = t.id || `ref-for-${e}-${r + 1}`; t.id || (t.id = o); const i = function (e) { const t = e.closest("section"); if (!t) return null; const n = t.querySelector("h1, h2, h3, h4, h5, h6"); return n ? bn(n.textContent) : null }(t); (n.get(i) || n.set(i, []).get(i)).push(o) }); const r = [...n].map(e => Qt`<li>${(([e, t]) => [{ title: e, id: t[0] }].concat(t.slice(1).map((e, t) => ({ title: `(${t + 2})`, id: e }))))(e).map(e => Qt`<a href="#${e.id}">${e.title}</a>${" "}`)}</li>`); return Qt`<ul>${r}</ul>` }(t, r)}
    </aside>
  `}(r), function (e, t, { x: n, y: r }) { document.body.appendChild(t); const o = e.getClientRects(); let i = 0, s = 1 / 0; for (const e of o) { const { top: t, bottom: n } = e, o = Math.abs((t + n) / 2 - r); o < s && (s = o, i = t) } const a = window.scrollY + i + o[0].height, c = n - 20; t.style.setProperty("--left", c + "px"), t.style.setProperty("--top", a + "px"); const l = t.getBoundingClientRect(), u = Math.min(window.innerWidth, window.screen.width); if (l.right > u) { const e = Math.max(20, n + 20 - l.width), r = c - e; t.style.setProperty("--left", e + "px"), t.style.setProperty("--caret-offset", r + "px") } }(r, t, { x: e.clientX, y: e.clientY }); break
            } case "dock": t.classList.add("docked"); break; case "hide": t.remove()
          }
        })
      }
    }); const el = async function () { try { return (await Promise.resolve().then((function () { return Al }))).default } catch { return Gn("datatype.css") } }(); var tl = Object.freeze({ __proto__: null, name: "core/data-type", run: async function (e) { if (!e.highlightVars) return; const t = document.createElement("style"); t.textContent = await el, document.head.appendChild(t); let n = null; const r = new Map, o = document.querySelectorAll("section var"); for (const e of o) { const t = e.closest("section"); if (n !== t && (n = t, r.clear()), e.dataset.type) { r.set(e.textContent.trim(), e.dataset.type); continue } const o = r.get(e.textContent.trim()); o && (e.dataset.type = o) } } }); const nl = async function () { try { return (await Promise.resolve().then((function () { return Rl }))).default } catch { return Gn("algorithms.css") } }(); var rl = Object.freeze({ __proto__: null, name: "core/algorithms", run: async function () { if (Array.from(document.querySelectorAll("ol.algorithm li")).filter(e => e.textContent.trim().startsWith("Assert: ")).forEach(e => e.classList.add("assert")), document.querySelector(".assert")) { const e = document.createElement("style"); e.textContent = await nl, document.head.appendChild(e) } } }); function ol(e, t, n) { const r = e.querySelector(".marker .self-link"); if (!r) { n.textContent = n.getAttribute("href"); return void pn(n, `Found matching element "${t}", but it has no title or marker.`, "Missing title.") } const o = In(r); n.append(...o.childNodes), n.classList.add("box-ref") } function il(e, t, n) { const r = e.querySelector("figcaption"); if (!r) { n.textContent = n.getAttribute("href"); return void pn(n, `Found matching figure "${t}", but figure is lacking a \`<figcaption>\`.`, "Missing figcaption in referenced figure.") } const o = [...In(r).childNodes].filter(e => !e.classList || !e.classList.contains("fig-title")); o.pop(), n.append(...o), n.classList.add("fig-ref"); const i = r.querySelector(".fig-title"); !n.hasAttribute("title") && i && (n.title = bn(i.textContent)) } function sl(e, t, n) { const r = e.querySelector("h6, h5, h4, h3, h2"); if (r) al(r, n), cl(r, n); else { n.textContent = n.getAttribute("href"); pn(n, "Found matching section, but the section was lacking a heading element.", `No matching id in document: "${t}".`) } } function al(e, t) { const n = e.querySelector(".self-link"), r = [...In(e).childNodes].filter(e => !e.classList || !e.classList.contains("self-link")); t.append(...r), n && t.prepend(""), t.classList.add("sec-ref") } function cl(e, t) { for (const n of ["dir", "lang"]) { if (t.hasAttribute(n)) continue; const r = e.closest(`[${n}]`); if (!r) continue; const o = t.closest(`[${n}]`); o && o.getAttribute(n) === r.getAttribute(n) || t.setAttribute(n, r.getAttribute(n)) } } var ll = Object.freeze({ __proto__: null, name: "core/anchor-expander", run: function () { const e = [...document.querySelectorAll("a[href^='#']:not(.self-link):not([href$='the-empty-string'])")].filter(e => "" === e.textContent.trim()); for (const t of e) { const e = t.getAttribute("href").slice(1), n = document.getElementById(e); if (n) { switch (n.localName) { case "h6": case "h5": case "h4": case "h3": case "h2": al(n, t); break; case "section": sl(n, e, t); break; case "figure": il(n, e, t); break; case "aside": case "div": ol(n, e, t); break; default: t.textContent = t.getAttribute("href"); pn(t, "ReSpec doesn't support expanding this kind of reference.", `Can't expand "#${e}".`) }cl(n, t), t.normalize() } else { t.textContent = t.getAttribute("href"); pn(t, `Couldn't expand inline reference. The id "${e}" is not in the document.`, `No matching id in document: ${e}.`) } } } }); const ul = class extends HTMLElement {
      constructor() { super(), this.props = { from: this.getAttribute("from"), to: this.getAttribute("to") || "HEAD", filter: "function" == typeof window[this.getAttribute("filter")] ? window[this.getAttribute("filter")] : () => !0 } } connectedCallback() {
        const { from: e, to: t, filter: n } = this.props; Qt.bind(this)`
      <ul>
      ${{ any: dl(e, t, n).then(e => async function (e) { const { repoURL: t } = await xo; return e.map(e => { const [n, r = null] = e.message.split(/\(#(\d+)\)/, 2), o = `${t}commit/${e.hash}`, i = r && Qt` (<a href="${r ? `${t}pull/${r}` : null}">#${r}</a>)`; return Qt`<li><a href="${o}">${n.trim()}</a>${i}</li>` }) }(e)).catch(e => pn(this, e.message, e.message)).finally(() => { this.dispatchEvent(new CustomEvent("done")) }), placeholder: "Loading list of commits..." }}
      </ul>
    `}
    }; async function dl(e, t, n) { let r; try { const o = await xo; if (!o) throw new Error("`respecConfig.github` is not set"); const i = new URL("commits", `${o.apiBase}/${o.fullName}/`); i.searchParams.set("from", e), i.searchParams.set("to", t); const s = await fetch(i.href); if (!s.ok) throw new Error(`Request to ${i} failed with status code ${s.status}`); if (r = await s.json(), !r.length) throw new Error(`No commits between ${e}..${t}.`); r = r.filter(n) } catch (e) { const t = "Error loading commits from GitHub. " + e.message; throw console.error(e), new Error(t) } return r } const pl = [Object.freeze({ __proto__: null, name: "rs-changelog", element: ul })]; var fl = Object.freeze({ __proto__: null, name: "core/custom-elements/index", run: async function () { pl.forEach(e => { customElements.define(e.name, e.element) }); const e = pl.map(e => e.name).join(", "), t = [...document.querySelectorAll(e)].map(e => new Promise(t => e.addEventListener("done", t, { once: !0 }))); await Promise.all(t) } }); const hl = ["color-contrast", "landmark-one-main", "landmark-unique", "region"]; function ml(e) { const t = []; for (const n of e.split("\n\n")) { const [e, ...r] = n.split(/^\s{2}/m), o = r.map(e => "- " + e.trimEnd()).join("\n"); t.push(`${e}${o}`) } return t.join("\n\n") } var gl = Object.freeze({ __proto__: null, name: "core/a11y", run: async function (e) { if (!e.a11y) return; const t = !0 === e.a11y ? {} : e.a11y, n = await async function (e) { const { rules: t, ...n } = e, o = { rules: { ...Object.fromEntries(hl.map(e => [e, { enabled: !1 }])), ...t }, ...n, elementRef: !0, resultTypes: ["violations"], reporter: "v1" }; let i; try { i = await function () { const e = document.createElement("script"); return e.classList.add("remove"), e.src = "https://unpkg.com/axe-core@3/axe.min.js", document.head.appendChild(e), new Promise((t, n) => { e.onload = () => t(window.axe), e.onerror = n }) }() } catch (e) { return r("error", "Failed to load a11y linter. See developer console for details."), console.error(e), [] } try { return (await i.run(document, o)).violations } catch (e) { return r("error", "Error while looking for a11y issues."), console.error(e), [] } }(t); for (const e of n) { const t = new Map; for (const n of e.nodes) { const { failureSummary: e, element: r } = n; (t.get(e) || t.set(e, []).get(e)).push(r) } const { id: n, help: r, description: o, helpUrl: i } = e, s = `a11y/${n}: ${r}`; for (const [e, n] of t) { dn(n, s, s, { details: `\n\n${o}.\n\n${ml(e)}. ([Learn more](${i}))` }) } } } }), bl = Object.freeze({ __proto__: null, default: '.respec-modal .close-button{position:absolute;z-index:inherit;padding:.2em;font-weight:700;cursor:pointer;margin-left:5px;border:none;background:0 0}#respec-ui{position:fixed;display:flex;flex-direction:row-reverse;top:20px;right:20px;width:202px;text-align:right;z-index:9000}#respec-pill,.respec-info-button{background:#fff;height:2.5em;color:#787878;border:1px solid #ccc;box-shadow:1px 1px 8px 0 rgba(100,100,100,.5)}.respec-info-button{border:none;opacity:.75;border-radius:2em;margin-right:1em;min-width:3.5em}.respec-info-button:focus,.respec-info-button:hover{opacity:1;transition:opacity .2s}#respec-pill:disabled{font-size:2.8px;text-indent:-9999em;border-top:1.1em solid rgba(40,40,40,.2);border-right:1.1em solid rgba(40,40,40,.2);border-bottom:1.1em solid rgba(40,40,40,.2);border-left:1.1em solid #fff;transform:translateZ(0);animation:respec-spin .5s infinite linear;box-shadow:none}#respec-pill:disabled,#respec-pill:disabled:after{border-radius:50%;width:10em;height:10em}@keyframes respec-spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}.respec-hidden{visibility:hidden;opacity:0;transition:visibility 0s .2s,opacity .2s linear}.respec-visible{visibility:visible;opacity:1;transition:opacity .2s linear}#respec-pill:focus,#respec-pill:hover{color:#000;background-color:#f5f5f5;transition:color .2s}#respec-menu{position:absolute;margin:0;padding:0;font-family:sans-serif;background:#fff;box-shadow:1px 1px 8px 0 rgba(100,100,100,.5);width:200px;display:none;text-align:left;margin-top:32px;font-size:.8em}#respec-menu:not([hidden]){display:block}#respec-menu li{list-style-type:none;margin:0;padding:0}.respec-save-buttons{display:grid;grid-template-columns:repeat(auto-fill,minmax(47%,2fr));grid-gap:.5cm;padding:.5cm}.respec-save-button:link{padding-top:16px;color:#f0f0f0;background:#2a5aa8;justify-self:stretch;height:1cm;text-decoration:none;text-align:center;font-size:inherit;border:none;border-radius:.2cm}.respec-save-button:link:hover{color:#fff;background:#2a5aa8;padding:0;margin:0;border:0;padding-top:16px}.respec-save-button:link:focus{background:#193766}#respec-pill:focus,#respec-ui button:focus,.respec-option:focus{outline:0;outline-style:none}#respec-pill-error{background-color:red;color:#fff}#respec-pill-warning{background-color:orange;color:#fff}.respec-error-list,.respec-warning-list{margin:0;padding:0;list-style:none;font-family:sans-serif;background-color:#fffbe6;font-size:.85em}.respec-error-list>li,.respec-warning-list>li{padding:.4em .7em}.respec-warning-list>li::before{content:"";padding-right:.5em}.respec-error-list p,.respec-warning-list p{padding:0;margin:0}.respec-warning-list li{color:#5c3b00;border-bottom:thin solid #fff5c2}.respec-error-list,.respec-error-list li{background-color:#fff0f0}.respec-error-list li::before{content:"";padding-right:.5em}.respec-error-list li{padding:.4em .7em;color:#5c3b00;border-bottom:thin solid #ffd7d7}.respec-error-list li>p{margin:0;padding:0;display:inline-block}.respec-error-list li>p:first-child,.respec-warning-list li>p:first-child{display:inline}.respec-error-list>li li,.respec-warning-list>li li{margin:0;list-style:disc}#respec-overlay{display:block;position:fixed;z-index:10000;top:0;left:0;height:100%;width:100%;background:#000}.respec-show-overlay{transition:opacity .2s linear;opacity:.5}.respec-hide-overlay{transition:opacity .2s linear;opacity:0}.respec-modal{display:block;position:fixed;z-index:11000;margin:auto;top:10%;background:#fff;border:5px solid #666;min-width:20%;width:79%;padding:0;max-height:80%;overflow-y:auto;margin:0 -.5cm}@media screen and (min-width:78em){.respec-modal{width:62%}}.respec-modal h3{margin:0;padding:.2em;text-align:center;color:#000;background:linear-gradient(to bottom,#eee 0,#eee 50%,#ccc 100%);font-size:1em}.respec-modal .inside div p{padding-left:1cm}#respec-menu button.respec-option{background:#fff;padding:0 .2cm;border:none;width:100%;text-align:left;font-size:inherit;padding:1.2em 1.2em}#respec-menu button.respec-option:hover,#respec-menu button:focus{background-color:#eee}.respec-cmd-icon{padding-right:.5em}#respec-ui button.respec-option:last-child{border:none;border-radius:inherit}.respec-button-copy-paste{position:absolute;height:28px;width:40px;cursor:pointer;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #90b8de;border-left:0;border-radius:0 0 3px 0;-webkit-user-select:none;user-select:none;-webkit-appearance:none;top:0;left:127px}#specref-ui{margin:0 2%;margin-bottom:.5cm}#specref-ui header{font-size:.7em;background-color:#eee;text-align:center;padding:.2cm;margin-bottom:.5cm;border-radius:0 0 .2cm .2cm}#specref-ui header h1{padding:0;margin:0;color:#000}#specref-ui p{padding:0;margin:0;font-size:.8em;text-align:center}#specref-ui p.state{margin:1cm}#specref-ui .searchcomponent{font-size:16px;display:grid;grid-template-columns:auto 2cm}#specref-ui button,#specref-ui input{border:0;padding:6px 12px}#specref-ui label{font-size:.6em;grid-column-end:3;text-align:right;grid-column-start:1}#specref-ui input[type=search]{-webkit-appearance:none;font-size:16px;border-radius:.1cm 0 0 .1cm;border:1px solid #ccc}#specref-ui button[type=submit]{color:#fff;border-radius:0 .1cm .1cm 0;background-color:#337ab7}#specref-ui button[type=submit]:hover{background-color:#286090;border-color:#204d74}#specref-ui .result-stats{margin:0;padding:0;color:grey;font-size:.7em;font-weight:700}#specref-ui .specref-results{font-size:.8em}#specref-ui .specref-results dd+dt{margin-top:.51cm}#specref-ui .specref-results a{text-transform:capitalize}#specref-ui .specref-results .authors{display:block;color:#006621}@media print{#respec-ui{display:none}}#xref-ui{width:100%;min-height:550px;height:100%;overflow:hidden;padding:0;margin:0;border:0}#xref-ui:not(.ready){background:url(https://respec.org/xref/loader.gif) no-repeat center}.respec-dfn-list .dfn-status{margin-left:.5em;padding:.1em;text-align:center;white-space:nowrap;font-size:90%;border-radius:.2em}.respec-dfn-list .exported{background:#d1edfd;color:#040b1c;box-shadow:0 0 0 .125em #1ca5f940}.respec-dfn-list .unused{background:#fde0e6;color:#9d0c29;box-shadow:0 0 0 .125em #f1466840}#xref-ui+a[href]{font-size:.9rem;float:right;margin:0 .5em .5em;border-bottom-width:1px}' }), yl = Object.freeze({ __proto__: null, default: '@keyframes pop{0%{transform:scale(1,1)}25%{transform:scale(1.25,1.25);opacity:.75}100%{transform:scale(1,1)}}.hljs{background:0 0!important}a abbr,h1 abbr,h2 abbr,h3 abbr,h4 abbr,h5 abbr,h6 abbr{border:none}dfn{font-weight:700}a.internalDFN{color:inherit;border-bottom:1px solid #99c;text-decoration:none}a.externalDFN{color:inherit;border-bottom:1px dotted #ccc;text-decoration:none}a.bibref{text-decoration:none}.respec-offending-element:target{animation:pop .25s ease-in-out 0s 1}.respec-offending-element,a[href].respec-offending-element{text-decoration:red wavy underline}@supports not (text-decoration:red wavy underline){.respec-offending-element:not(pre){display:inline-block}.respec-offending-element{background:url(data:image/gif;base64,R0lGODdhBAADAPEAANv///8AAP///wAAACwAAAAABAADAEACBZQjmIAFADs=) bottom repeat-x}}#references :target{background:#eaf3ff;animation:pop .4s ease-in-out 0s 1}cite .bibref{font-style:normal}code{color:#c63501}th code{color:inherit}a[href].orcid{padding-left:4px;padding-right:4px}a[href].orcid>svg{margin-bottom:-2px}.toc a,.tof a{text-decoration:none}a .figno,a .secno{color:#000}ol.tof,ul.tof{list-style:none outside none}.caption{margin-top:.5em;font-style:italic}table.simple{border-spacing:0;border-collapse:collapse;border-bottom:3px solid #005a9c}.simple th{background:#005a9c;color:#fff;padding:3px 5px;text-align:left}.simple th a{color:#fff;padding:3px 5px;text-align:left}.simple th[scope=row]{background:inherit;color:inherit;border-top:1px solid #ddd}.simple td{padding:3px 10px;border-top:1px solid #ddd}.simple tr:nth-child(even){background:#f0f6ff}.section dd>p:first-child{margin-top:0}.section dd>p:last-child{margin-bottom:0}.section dd{margin-bottom:1em}.section dl.attrs dd,.section dl.eldef dd{margin-bottom:0}#issue-summary>ul,.respec-dfn-list{column-count:2}#issue-summary li,.respec-dfn-list li{list-style:none}details.respec-tests-details{margin-left:1em;display:inline-block;vertical-align:top}details.respec-tests-details>*{padding-right:2em}details.respec-tests-details[open]{z-index:999999;position:absolute;border:thin solid #cad3e2;border-radius:.3em;background-color:#fff;padding-bottom:.5em}details.respec-tests-details[open]>summary{border-bottom:thin solid #cad3e2;padding-left:1em;margin-bottom:1em;line-height:2em}details.respec-tests-details>ul{width:100%;margin-top:-.3em}details.respec-tests-details>li{padding-left:1em}a[href].self-link:hover{opacity:1;text-decoration:none;background-color:transparent}h2,h3,h4,h5,h6{position:relative}aside.example .marker>a.self-link{color:inherit}h2>a.self-link,h3>a.self-link,h4>a.self-link,h5>a.self-link,h6>a.self-link{border:none;color:inherit;font-size:83%;height:2em;left:-1.6em;opacity:.5;position:absolute;text-align:center;text-decoration:none;top:0;transition:opacity .2s;width:2em}h2>a.self-link::before,h3>a.self-link::before,h4>a.self-link::before,h5>a.self-link::before,h6>a.self-link::before{content:"";display:block}@media (max-width:767px){dd{margin-left:0}h2>a.self-link,h3>a.self-link,h4>a.self-link,h5>a.self-link,h6>a.self-link{left:auto;top:auto}}@media print{.removeOnSave{display:none}}' }), vl = Object.freeze({ __proto__: null, default: "span.example-title{text-transform:none}aside.example,div.example,div.illegal-example{padding:.5em;margin:1em 0;position:relative;clear:both}div.illegal-example{color:red}div.illegal-example p{color:#000}aside.example,div.example{padding:.5em;border-left-width:.5em;border-left-style:solid;border-color:#e0cb52;background:#fcfaee}aside.example div.example{border-left-width:.1em;border-color:#999;background:#fff}aside.example div.example span.example-title{color:#999}" }), wl = Object.freeze({ __proto__: null, default: '.issue-label{text-transform:initial}.warning>p:first-child{margin-top:0}.warning{padding:.5em;border-left-width:.5em;border-left-style:solid}span.warning{padding:.1em .5em .15em}.issue.closed span.issue-number{text-decoration:line-through}.warning{border-color:#f11;border-width:.2em;border-style:solid;background:#fbe9e9}.warning-title:before{content:"";font-size:1.3em;float:left;padding-right:.3em;margin-top:-.3em}li.task-list-item{list-style:none}input.task-list-item-checkbox{margin:0 .35em .25em -1.6em;vertical-align:middle}.issue a.respec-gh-label{padding:5px;margin:0 2px 0 2px;font-size:10px;text-transform:none;text-decoration:none;font-weight:700;border-radius:4px;position:relative;bottom:2px;border:none;display:inline-block}' }), xl = Object.freeze({ __proto__: null, default: "pre.idl{padding:1em;position:relative}@media print{pre.idl{white-space:pre-wrap}}.idlHeader{display:block;width:150px;background:#8ccbf2;color:#fff;font-family:sans-serif;font-weight:700;margin:-1em 0 1em -1em;height:28px;line-height:28px}.idlHeader a.self-link{margin-left:.3cm;text-decoration:none;border-bottom:none}.idlID{font-weight:700;color:#005a9c}.idlType{color:#005a9c}.idlName{color:#ff4500}.idlName a{color:#ff4500;border-bottom:1px dotted #ff4500;text-decoration:none}a.idlEnumItem{color:#000;border-bottom:1px dotted #ccc;text-decoration:none}.idlSuperclass{font-style:italic;color:#005a9c}.idlDefaultValue,.idlParamName{font-style:italic}.extAttr{color:#666}.idlSectionComment{color:gray}.idlIncludes a{font-weight:700}.respec-button-copy-paste:focus{text-decoration:none;border-color:#51a7e8;outline:0;box-shadow:0 0 5px rgba(81,167,232,.5)}.respec-button-copy-paste.selected:focus,.respec-button-copy-paste:focus:hover{border-color:#51a7e8}.respec-button-copy-paste.zeroclipboard-is-active,.respec-button-copy-paste.zeroclipboard-is-hover,.respec-button-copy-paste:active,.respec-button-copy-paste:hover{text-decoration:none;background-color:#ddd;background-image:linear-gradient(#eee,#ddd);border-color:#ccc}.respec-button-copy-paste.selected,.respec-button-copy-paste.zeroclipboard-is-active,.respec-button-copy-paste:active{background-color:#dcdcdc;background-image:none;border-color:#b5b5b5;box-shadow:inset 0 2px 4px rgba(0,0,0,.15)}.respec-button-copy-paste.selected:hover{background-color:#cfcfcf}.respec-button-copy-paste.disabled,.respec-button-copy-paste.disabled:hover,.respec-button-copy-paste:disabled,.respec-button-copy-paste:disabled:hover{color:rgba(102,102,102,.5);cursor:default;background-color:rgba(229,229,229,.5);background-image:none;border-color:rgba(197,197,197,.5);box-shadow:none}@media print{.respec-button-copy-paste{visibility:hidden}}" }), kl = Object.freeze({ __proto__: null, default: "ul.index{columns:30ch;column-gap:1.5em}ul.index li{list-style:inherit}ul.index li span{color:inherit;cursor:pointer;white-space:normal}#index-defined-here ul.index li{font-size:.9rem}ul.index code{color:inherit}#index-defined-here .print-only{display:none}@media print{#index-defined-here .print-only{display:initial}}" }), $l = Object.freeze({ __proto__: null, default: '.caniuse-stats{display:flex;flex-wrap:wrap;justify-content:flex-start;align-items:baseline;cursor:pointer}button.caniuse-cell{margin:1px 1px 0 0;border:none}.caniuse-browser{position:relative}@media print{.caniuse-cell.y::before{content:"";padding:.5em}.caniuse-cell.n::before{content:"";padding:.5em}.caniuse-cell.a::before,.caniuse-cell.d::before,.caniuse-cell.p::before,.caniuse-cell.x::before{content:"";padding:.5em}}.caniuse-browser ul{display:none;margin:0;padding:0;list-style:none;position:absolute;left:0;z-index:2;background:#fff;margin-top:1px}.caniuse-stats a{white-space:nowrap;align-self:center;margin-left:.5em}.caniuse-cell{display:flex;color:rgba(0,0,0,.8);font-size:90%;height:.8cm;margin-right:1px;margin-top:0;min-width:3cm;overflow:visible;justify-content:center;align-items:center}li.caniuse-cell{margin-bottom:1px}.caniuse-cell:focus{outline:0}.caniuse-cell:hover{color:#000}.caniuse-cell.y{background:#8bc34a}.caniuse-cell.n{background:#e53935}.caniuse-cell.a,.caniuse-cell.d,.caniuse-cell.p,.caniuse-cell.x{background:#ffc107}.caniuse-stats .caniuse-browser:hover>ul,.caniuse-stats button:focus+ul{display:block}' }), Cl = Object.freeze({ __proto__: null, default: '.mdn{display:block;font:12px sans-serif;position:absolute;z-index:9;right:.3em;background-color:#eee;margin:-26px 0 0 0;padding:7px 5px 5px 6px;min-width:140px;box-shadow:0 0 3px #999}.mdn button{cursor:pointer;border:none;color:#000;background:0 0;margin:-8px;outline:0}.mdn b{color:#fff;background-color:#000;font-weight:400;font-family:zillaslab,Palatino,"Palatino Linotype",serif;padding:2px 3px 0 3px;line-height:1.3em;vertical-align:top}.mdn>div>div{display:inline-block;margin-left:5px}.nosupportdata{font-style:italic;margin-top:4px;margin-left:8px;padding-bottom:8px}.mdnsupport{display:table;margin-top:4px}.mdnsupport>span{display:table-row;padding:.2em 0;padding-top:.2em;font-size:9.6px}.mdnsupport>span>span{display:table-cell;padding:0 .5em;vertical-align:top;line-height:1.5em}.mdnsupport>span>span:last-child{text-align:right;padding:0}.mdnsupport>span.no{color:#ccc;filter:grayscale(100%)}.mdnsupport>span.unknown{color:#ccc;filter:grayscale(100%)}.mdnsupport>span.no::before{opacity:.5}.mdnsupport>span.unknown::before{opacity:.5}.mdnsupport>span::before{content:"";display:table-cell;min-width:1.5em;height:1.5em;background:no-repeat center center/contain;text-align:right;font-size:.75em;font-weight:700}.mdnsupport>.chrome::before,.mdnsupport>.chrome_android::before{background-image:url(https://resources.whatwg.org/browser-logos/chrome.svg)}.mdnsupport>.edge::before,.mdnsupport>.edge_mobile::before{background-image:url(https://resources.whatwg.org/browser-logos/edge.svg)}.mdnsupport>.firefox::before,.mdnsupport>.firefox_android::before{background-image:url(https://resources.whatwg.org/browser-logos/firefox.png)}.mdnsupport>.ie::before{background-image:url(https://resources.whatwg.org/browser-logos/ie.png)}.mdnsupport>.opera::before,.mdnsupport>.opera_android::before{background-image:url(https://resources.whatwg.org/browser-logos/opera.svg)}.mdnsupport>.safari::before{background-image:url(https://resources.whatwg.org/browser-logos/safari.png)}.mdnsupport>.safari_ios::before{background-image:url(https://resources.whatwg.org/browser-logos/safari-ios.svg)}.mdnsupport>.samsunginternet_android::before{background-image:url(https://resources.whatwg.org/browser-logos/samsung.svg)}.mdnsupport>.webview_android::before{background-image:url(https://cdnjs.loli.net/ajax/libs/browser-logos/41.0.0/android-webview-beta/android-webview-beta_32x32.png)}.mdn.wrapped div:nth-child(n+3){display:none}.mdn div:nth-child(n+3)>b{color:#eee;background-color:#eee}p+.mdn{margin-top:-45px}.mdn.before{margin-top:3em}h2+.mdn{margin:-48px 0 0 0}h3+.mdn{margin:-46px 0 0 0}h4+.mdn{margin:-42px 0 0 0}h5+.mdn{margin:-40px 0 0 0}h6+.mdn{margin:-40px 0 0 0}.mdn div{margin:0}.mdn :link{color:#00e}.mdn :visited{color:#551a8b}.mdn :link:active,:visited:active{color:red}.mdn :link,:visited{text-decoration:underline;cursor:pointer}.mdn.wrapped{min-width:0}.mdn.wrapped>div>div{display:none}.mdn:hover{z-index:11}.mdn:focus-within{z-index:11}' }), Sl = Object.freeze({ __proto__: null, default: '// ReSpec Worker v1.0.0\n"use strict";\ntry {\n  importScripts("https://www.w3.org/Tools/respec/respec-highlight.js");\n} catch (err) {\n  console.error("Network error loading highlighter", err);\n}\n\nself.addEventListener("message", ({ data: originalData }) => {\n  const data = Object.assign({}, originalData);\n  switch (data.action) {\n    case "highlight-load-lang": {\n      const { langURL, propName, lang } = data;\n      importScripts(langURL);\n      self.hljs.registerLanguage(lang, self[propName]);\n      break;\n    }\n    case "highlight": {\n      const { code } = data;\n      const langs = data.languages.length ? data.languages : undefined;\n      try {\n        const { value, language } = self.hljs.highlightAuto(code, langs);\n        Object.assign(data, { value, language });\n      } catch (err) {\n        console.error("Could not transform some code?", err);\n        // Post back the original code\n        Object.assign(data, { value: code, language: "" });\n      }\n      break;\n    }\n  }\n  self.postMessage(data);\n});\n' }), _l = Object.freeze({ __proto__: null, default: ".hljs{display:block;overflow-x:auto;padding:.5em;color:#383a42;background:#fafafa}.hljs-comment,.hljs-quote{color:#717277;font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#ca4706;font-weight:700}.hljs-literal{color:#0b76c5}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#42803c}.hljs-built_in,.hljs-class .hljs-title{color:#9a6a01}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#336ae3}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}" }), El = Object.freeze({ __proto__: null, default: "var:hover{text-decoration:underline;cursor:pointer}var.respec-hl{color:var(--color,#000);background-color:var(--bg-color);box-shadow:0 0 0 2px var(--bg-color)}var.respec-hl-c1{--bg-color:#f4d200}var.respec-hl-c2{--bg-color:#ff87a2}var.respec-hl-c3{--bg-color:#96e885}var.respec-hl-c4{--bg-color:#3eeed2}var.respec-hl-c5{--bg-color:#eacfb6}var.respec-hl-c6{--bg-color:#82ddff}var.respec-hl-c7{--bg-color:#ffbcf2}@media print{var.respec-hl{background:0 0;color:#000;box-shadow:unset}}" }), Tl = Object.freeze({ __proto__: null, default: 'dfn{cursor:pointer}.dfn-panel{--fill:#fff;position:absolute;left:var(--left);top:var(--top);z-index:35;min-width:300px;max-width:500px;padding:.5em .75em;margin-top:.6em;font:small Helvetica Neue,sans-serif,Droid Sans Fallback;background:var(--fill);color:#000;box-shadow:0 1em 3em -.4em rgba(0,0,0,.3),0 0 1px 1px rgba(0,0,0,.05);border-radius:2px}.dfn-panel:not(.docked)::after,.dfn-panel:not(.docked)::before{content:"";position:absolute;border:10px solid transparent;border-top:0;border-bottom:9px solid #a2a9b1;top:-9px;left:calc(var(--caret-offset,0px) + .75em)}.dfn-panel:not(.docked)::after{border-bottom:10px solid var(--fill)}.dfn-panel *{margin:0}.dfn-panel>b{display:block}.dfn-panel ul a[href]{color:#333}.dfn-panel a:not(:hover){text-decoration:none!important;border-bottom:none!important}.dfn-panel a[href]:hover{border-bottom-width:1px}.dfn-panel>b+b{margin-top:.25em}.dfn-panel ul{padding:0}.dfn-panel li{margin-left:1em}.dfn-panel.docked{display:inline-block;position:fixed;left:.5em;top:unset;bottom:2em;margin:0 auto;max-width:calc(100vw - .75em * 2 - .5em - .2em * 2);max-height:30vh;overflow:auto}' }), Al = Object.freeze({ __proto__: null, default: 'var{position:relative;cursor:pointer}var[data-type]::after,var[data-type]::before{position:absolute;left:50%;top:-6px;opacity:0;transition:opacity .4s;pointer-events:none}var[data-type]::before{content:"";transform:translateX(-50%);border-width:4px 6px 0 6px;border-style:solid;border-color:transparent;border-top-color:#000}var[data-type]::after{content:attr(data-type);transform:translateX(-50%) translateY(-100%);background:#000;text-align:center;font-family:"Dank Mono","Fira Code",monospace;font-style:normal;padding:6px;border-radius:3px;color:#daca88;text-indent:0;font-weight:400}var[data-type]:hover::after,var[data-type]:hover::before{opacity:1}' }), Rl = Object.freeze({ __proto__: null, default: ".assert{background:#eee;border-left:.5em solid #aaa;padding:.3em}" })
}();
//# sourceMappingURL=respec-w3c-common.js.map
